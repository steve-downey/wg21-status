#+options: ':nil *:t -:t ::t <:t H:4 \n:nil ^:nil arch:headline author:nil
#+options: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:nil e:t
#+options: email:nil f:t inline:t num:nil p:nil pri:nil prop:nil stat:t tags:t
#+options: tasks:t tex:t timestamp:nil title:nil toc:nil todo:t |:t
#+options: html-link-use-abs-url:nil html-postamble:nil html-preamble:t
#+options: html-scripts:t html-style:t html5-fancy:nil tex:t
#+options: reveal_width:2400 reveal_height:1350
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+latex_class: article
#+latex_class_options: 
#+latex_header: 
#+latex_header_extra: 
#+keywords: 
#+description: 
#+subtitle: 
#+latex_compiler: pdflatex
#+startup: showeverything
#+html_doctype: xhtml-strict
#+html_container: div
#+description: 
#+keywords: 
#+html_link_home: 
#+html_link_up: 
#+html_mathjax: 
#+html_head: 
#+html_head_extra: 
#+subtitle: 
#+infojs_opt: 

#+reveal_trans: fade
#+html_head: <link rel="stylesheet" type="text/css" href="./vivendi-tinted.css" />

#+reveal_mathjax_url: https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML
#+reveal_extra_css: ./vivendi-tinted.css
#+reveal_theme: ./my_theme.css
#+reveal_extra_css: ./footer.css
#+reveal_title_slide_background: ./C++23_new.png

#+reveal_root: https://cdn.jsdelivr.net/npm/reveal.js
#+reveal_version: 4

#+reveal_hlevel: 4
#+reveal_export_notes_to_pdf: separate-page


* C++ 23 Status Report
This is a summary of what was approved for C++23.

All of the quoted text and example code is from the papers linked in the headings by the authors of the papers.

I've selected text to describe the purpose of the paper, usually quoting the abstract, and taking illustritive code that the paper provides to show the intent. Please see the linked papers for details.

The "Major" Section is my judgement, influenced by a few friends, about what I thought was most interesting or important in C++ 23.


* Major (in my opinion)
- 11 papers total

*** [[https://wg21.link/p2644][P2644]] Get Fix of Broken Range-based for Loop Finally Done (Nicolai Josuttis)
#+begin_quote
This paper summarizes the fix for the still open issues cwg900, cwg1498,
ewg120. The issue is a bug that is 13 years old now, applies to one of the most
important control structures of Modern C++, and leads to confusion and
ill-formed programs due to unexpected undefined behavior and effort for
teaching and training.
#+end_quote


|                                                    | Before | After |
|----------------------------------------------------+--------+-------|
| ~for (auto e : getTmp().getRef())~                 | BROKEN | OK    |
| ~for (auto e : getVector()[0])~                    | BROKEN | OK    |
| ~for (auto valueElem : getMap()["key"])~           | BROKEN | OK    |
| ~for (auto e : get<0>(getTuple()))~                | BROKEN | OK    |
| ~for (auto e : getOptionalColl().value())~         | BROKEN | OK    |
| ~for (char c : get<string>(getVariant()))~         | BROKEN | OK    |
| ~for (auto s : std::span{arrOfConst()}.last(2))~   | BROKEN | OK    |
| ~for (auto e : std::span(getVector().data(), 2))~  | BROKEN | OK    |
| ~for (auto e: co_await coroReturningRef())~        | BROKEN | OK    |
| ~// assume getValue() returns value by reference:~ |        |       |
| ~for (char c : getData().value)~                   | OK     | OK    |
| ~for (char c : getData().getValue())~              | BROKEN | OK    |

tags: CWG, C++23, plenary-approved

*** [[https://wg21.link/p0323][P0323]] ~std::expected~ (Vicente Botet, JF Bastien, Jonathan Wakely)
#+begin_quote
Class template ~expected<T, E>~ is a vocabulary type which contains an expected value of type ~T~, or an error ~E~. The class skews towards behaving like a ~T~, because its intended use is when the expected type is contained. When something unexpected occurs, more typing is required. When all is good, code mostly looks as if a ~T~ were being handled.
#+end_quote
tags: LWG, C++23, IS, B3 - addition, size - large, plenary-approved

*** [[https://wg21.link/p0798][P0798]] Monadic operations for std::optional (Sy Brand)
#+begin_quote
std::optional will be a very important vocabulary type in C++17 and up. Some uses of it can be very verbose and would benefit from operations which allow functional composition. I propose adding map, and_then, and or_else member functions to std::optional to support this monadic style of programming.
#+end_quote
**** Example
#+begin_src c++
std::optional<image> get_cute_cat(const image& img) {
    return crop_to_cat(img)
        .and_then(add_bow_tie)
        .and_then(make_eyes_sparkle)
        .map(make_smaller)
        .map(add_rainbow);
}
#+end_src
**** Quote
#+begin_quote
Here is a list of programming languages which have a optional-like type without a monadic interface or syntactic sugar:

- C++

- I couldn’t find any others
#+end_quote
**** Monadic interface
- map :: ~map~ applies a function to the value stored in the optional and returns the result wrapped in an optional. If there is no stored value, then it returns an empty optional.
- and_then :: ~and_then~ is like map, but it is used on functions which may not return a value.
- or_else :: ~or_else~ returns the optional if it has a value, otherwise it calls a given function. This allows you do things like logging or throwing exceptions in monadic contexts:


tags: LWG, SG14, C++23, IS, size - small, plenary-approved

*** [[https://wg21.link/p0847][P0847]] Deducing this (Gašper Ažman, Sy Brand, Ben Deane, Barry Revzin)
#+begin_quote
We propose a new mechanism for specifying or deducing the value category of an instance of a class — in other words, a way to tell from within a member function whether the object it’s invoked on is an lvalue or an rvalue; whether it is const or volatile; and the object’s type.
#+end_quote

#+begin_quote
A non-static member function can be declared to take as its first parameter an explicit object parameter, denoted with the prefixed keyword this. Once we elevate the object parameter to a proper function parameter, it can be deduced following normal function template deduction rules:
#+end_quote

**** Example
#+begin_src c++
struct X {
    void foo(this X const& self, int i);

    template <typename Self>
    void bar(this Self&& self);
};

struct D : X {};

void ex(X& x, D const& d) {
    x.foo(42);     // 'self' is bound to 'x', 'i' is 42
    x.bar();       // deduces Self as X&, calls X::bar<X&>
    move(x).bar(); // deduces Self as X, calls X::bar<X>

    d.foo(17); // 'self' is bound to 'd'
    d.bar();   // deduces Self as D const&, calls X::bar<D const&>
}
#+end_src

**** Example
#+begin_src c++
vector captured = {1, 2, 3, 4};
[captured](this auto&& self) -> decltype(auto) {
  return forward_like<decltype(self)>(captured);
}

[captured]<class Self>(this Self&& self) -> decltype(auto) {
  return forward_like<Self>(captured);
}
#+end_src


tags: CWG, C++23, plenary-approved

*** [[https://wg21.link/p1132][P1132]] out_ptr - a scalable output pointer abstraction (JeanHeyd Meneide, Todor Buyukliev, Isabella Muerte)
#+begin_quote
out_ptr is an abstraction to bring both C APIs and smart pointers back into the promised land by creating a temporary pointer-to-pointer that updates the smart pointer when it destructs.
#+end_quote
****** Example
#+begin_src c++
error_num c_api_create_handle(int seed_value, int** p_handle);
void      c_api_delete_handle(int* handle);

struct resource_deleter {
    void operator()(int* handle) { c_api_delete_handle(handle); }
};

std::unique_ptr<int, resource_deleter> resource(nullptr);
error_num err = c_api_create_handle(24, std::out_ptr(resource));
if (err == C_API_ERROR_CONDITION) {
    // handle errors
}
// resource.get() the out-value from the C API function
#+end_src
tags: LWG, C++23, IS, plenary-approved

*** [[https://wg21.link/p1206][P1206]] ranges::to: A function to convert any range to a container (Corentin Jabot, Eric Niebler, Casey Carter)
#+begin_quote
We propose a function to copy or materialize any range (containers and views alike) to a container.
#+end_quote
**** Before/After Table
Before:
#+begin_src c++
std::map<int, widget>                           map = get_widgets_map();
std::vector<typename decltype(map)::value_type> vec;
vec.reserve(map.size());
ranges::move(map, std::back_inserter(vec));
#+end_src
After:
#+begin_src c++
auto vec = get_widgets_map() | ranges::to<vector>
#+end_src
tags: LWG, ranges, C++23, IS, plenary-approved

*** [[https://wg21.link/p2286][P2286]] Formatting Ranges (Barry Revzin)
#+begin_quote
[LWG3478] addresses the issue of what happens when you split a string and the last character in the string is the delimiter that you are splitting on. One of the things I wanted to look at in research in that issue is: what do other languages do here?

For most languages, this is a pretty easy proposition. Do the split, print the results. This is usually only a few lines of code.
#+end_quote
**** Python
#+begin_src python
print("xyx".split("x"))
#+end_src

#+begin_example
['', 'y', '']
#+end_example

**** Java
#+begin_src java
import java.util.Arrays;

class Main {
  public static void main(String args[]) {
    System.out.println("xyx".split("x"));
    System.out.println(Arrays.toString("xyx".split("x")));
  }
}
#+end_src

#+begin_example
[Ljava.lang.String;@76ed5528
[, y]
#+end_example
**** rust
#+begin_src rust
use itertools::Itertools;

fn main() {
    println!("{:?}", "xyx".split('x'));
    println!("[{}]", "xyx".split('x').format(", "));
    println!("{:?}", "xyx".split('x').collect::<Vec<_>>());
}
#+end_src

#+begin_example
Split(SplitInternal { start: 0, end: 3, matcher: CharSearcher { haystack: "xyx", finger: 0, finger_back: 3, needle: 'x', utf8_size: 1, utf8_encoded: [120, 0, 0, 0] }, allow_trailing_empty: true, finished: false })
[, y, ]
["", "y", ""]
#+end_example

**** C++
#+begin_src c++
#include <iostream>
#include <string>
#include <ranges>

int main() {
    // need to predeclare this because we can't split an rvalue string
    std::string s     = "xyx";
    auto        parts = s | std::views::split('x');

    std::cout << "[";
    char const* delim = "";
    for (auto part : parts) {
        std::cout << delim;
        // this finally works
        for (char c : part) {
            std::cout << c;
        }
        delim = ", ";
    }
    std::cout << "]\n";
}
#+end_src
#+begin_example
[, y, ]
#+end_example
**** lib fmt
#+begin_src c++
#include <ranges>
#include <string>
#include <fmt/ranges.h>

int main() {
    std::string s = "xyx";
    auto parts = s | std::views::split('x');

    fmt::print("{}\n", parts);
    fmt::print("<<{}>>\n", fmt::join(parts, "--"));
}
#+end_src
#+begin_example
[[], ['y'], []]
<<[]--['y']--[]>>
#+end_example

tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved

*** [[https://wg21.link/p2412][P2465]] Standard Library Modules std and std.all (Stephan T. Lavavej, Gabriel Dos Reis, Bjarne Stroustrup, Jonathan Wakely)
#+begin_quote
Header files are a major source of complexity, errors caused by dependencies, and slow compilation.
Modules address all three problems, but are currently hard to use because the standard library is not
offered in a module form. This note presents logical arguments and a few measurements that
demonstrates that *import std* of a module *std* presenting all of the standard library can compile many
times faster than plain old *#include <iostream>*.
#+end_quote
**** As adopted
#+begin_quote
This paper provides Standardese for two named modules: ~std~ and ~std.compat~.

~import std;~ imports everything in namespace std from C++ headers (e.g.
~std::sort~ from ~<algorithm>~) and C wrapper headers (e.g. ~std::fopen~ from
~<cstdio>~). It also imports ~::operator new~ etc. from ~<new>~.

~import std.compat;~ imports all of the above, plus the global namespace
counterparts for the C wrapper headers (e.g. ~::fopen~).
#+end_quote

tags: CWG, LWG, straw-poll, C++23, tentatively-ready-for-plenary, IS, modular-standard-library, size - large, plenary-approved

*** [[https://wg21.link/p2093][P2093]] Formatted output (Victor Zverovich)
#+begin_quote


A new I/O-agnostic text formatting library was introduced in C++20 ([FORMAT]). This paper proposes integrating it with standard I/O facilities via a simple and intuitive API achieving the following goals:

- Usability

- Unicode support

- Good performance

- Small binary footprint
#+end_quote
**** Before/After Table
***** Before:
#+begin_src c++
std::cout << std::format("Hello, {}!", name);
#+end_src
***** After:
#+begin_src c++
std::print("Hello, {}!", name);
#+end_src
tags: LWG, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved

*** [[https://wg21.link/p2128][P2128]] Multidimensional subscript operator (Corentin Jabot, Isabella Muerte, Daisy Hollman, Christian Trott, Mark Hoemmen)
#+begin_quote
We propose that user-defined types can define a subscript operator with multiple arguments
to better support multi-dimensional containers and views.
#+end_quote
**** Before
#+begin_src c++
template <class ElementType, class Extents>
class mdspan {
    template <class... IndexType>
    constexpr reference operator()(IndexType...);
};
int main() {
    int  buffer[2 * 3 * 4] = {};
    auto s                 = mdspan<int, extents<2, 3, 4>>(buffer);
    s(1, 1, 1)             = 42;
}
#+end_src
**** After
#+begin_src c++
template <class ElementType, class Extents>
 class mdspan {
    template <class... IndexType>
    constexpr reference operator[](IndexType...);
};
int main() {
    int  buffer[2 * 3 * 4] = {};
    auto s                 = mdspan<int, extents<2, 3, 4>>(buffer);
    s[1, 1, 1]             = 42;
}
#+end_src
tags: CWG, C++23, plenary-approved

*** [[https://wg21.link/p0009][P0009]] mdspan: A Non-Owning Multidimensional Array Reference (H. Carter Edwards, Bryce Adelstein
#+begin_quote
This paper proposes adding to the C++ Standard Library a multidimensional array view, ~mdspan~, along with classes, class templates, and constants for describing and creating multidimensional array views. It also proposes adding the submdspan function that “slices” (returns an ~mdspan~ that views a subset of) an existing mdspan.
#+end_quote

#+begin_quote
The ~mdspan~ class template can represent arbitrary mixes of compile-time or run-time extents. Its element type can be any complete object type that is neither an abstract class type nor an array type. It has two customization opportunities for users: the _layout mapping_ and the _accessor_. The layout mapping specifies the formula, and properties of the formula, for mapping a multidimensional index to an element of the array. The accessor governs how elements are read and written.
#+end_quote
tags: LWG, C++23, linear-algebra, tentatively-ready-for-plenary, IS, size - large, plenary-approved, mdspan

* Core Working Group Features
** constexpr
- 5 Papers
**** [[https://wg21.link/p0533][P0533]] constexpr for <cmath> and <cstdlib> (Edward J. Rosten, Oliver J. Rosten)
#+begin_quote
We propose simple criteria for selecting functions in <cmath> which should be
declared constexpr.  There is a small degree of overlap with <cstdlib>. The aim
is to transparently select a sufficiently large portion of <cmath> in order to
be useful but without placing too much burden on compiler vendors.
#+end_quote

***** Example
#+begin_src c++
constexpr int foo(float x) {
int a{}; int* pa{&a};
std::frexpr(x, pa);
return a;
}

constexpr int i{foo(0.5f)}.
#+end_src

tags: CWG, LWG, C++23, IS, B3 - addition, size - medium, plenary-approved, constexpr

**** [[https://wg21.link/p2448][P2448]] Relaxing some constexpr restrictions (Barry Revzin)
#+begin_quote
There are two rules about constexpr programming that make code ill-formed or ill-formed (no diagnostic required) when functions or function templates are marked constexpr that might never evaluate to a constant expression. But… so what if they don’t? The goal of this paper is to stop diagnosing problems that don’t exist.
#+end_quote
tags: CWG, straw-poll, C++23, plenary-approved

**** [[https://wg21.link/p1938][P1938]] if consteval (Barry Revzin, Daveed Vandevoorde, Richard Smith)
#+begin_quote
We propose a new form of if statement which is spelled:

~if consteval { }~
#+end_quote
***** Example
#+begin_src c++
consteval int f(int i) { return i; }

constexpr int g(int i) {
    if consteval {
        return f(i) + 1; // ok: immediate function context
    } else {
        return 42;
    }
}

consteval int h(int i) {
    return f(i) + 1; // ok: immediate function context
}
#+end_src
tags: CWG, LWG, C++23, plenary-approved

**** [[https://wg21.link/p2242][P2242]] Non-literal variables (and labels and gotos) in constexpr functions (Ville Voutilainen)
#+begin_quote
This paper proposes to strike the restriction that a constexpr function cannot contain a definition of a variable of non-literal type (or of static or thread storage duration), or a goto statement, or an identifier label. The rationale is briefly that the mere presence of the aforementioned things in a function is not in and of itself problematic; we can allow them to be present, as long as constant evaluation doesn't evaluate them.
#+end_quote
***** Example
#+begin_src c++
template <typename T>
constexpr bool f() {
    if (std::is_constant_evaluated()) {
        // ...
        return true;
    } else {
        T t;
        // ...
        return true;
    }
}
struct nonliteral {
    nonliteral();
};
static_assert(f<nonliteral>());
#+end_src
tags: CWG, C++23, plenary-approved

**** [[https://wg21.link/p2280][P2280]] Using unknown references in constant expressions (Barry Revzin)
#+begin_src c++
template <typename T, size_t N>
constexpr auto array_size(T (&)[N]) -> size_t {
    return N;
}

void check(int const (&param)[3]) {
    int            local[] = {1, 2, 3};
    constexpr auto s0      = array_size(local); // ok
    constexpr auto s1      = array_size(param); // error
}
#+end_src
#+begin_quote
The proposal is to allow all these cases to just work. That is, if during constant evaluation, we run into a reference with unknown origin, this is still okay, we keep going. Similarly, if we run into a pointer with unknown origin, we allow indirecting through it.
#+end_quote

tags: CWG, straw-poll, C++23, plenary-approved

** Text Translation
- 12 Papers
**** [[https://wg21.link/p1949][P1949]] C++ Identifier Syntax using Unicode Standard Annex 31 (Steve Downey)
#+begin_quote
Adopt Unicode Annex 31 as part of C++ 23.

- That C++ identifiers match the pattern (XID_Start + _ ) + XID_Continue*.
- That portable source is required to be normalized as NFC.
- That using unassigned code points be ill-formed.

In addition adopt this proposal as a Defect Report against C++ 20 and earlier.
#+end_quote
***** Examples
#+begin_src c++
bool 👷 = true; //  Construction Worker
bool 👷‍♀ = false; // Woman Construction Worker ({Construction Worker}{ZWJ}{Female Sign})
int ⏰ = 0; //not valid
int 🕐 = 0;

int ☠ = 0; //not valid
int 💀 = 0;

int ✋ = 0; //not valid
int 👊 = 0;

int ✈ = 0; //not valid
int 🚀 = 0;

int ☹ = 0; //not valid
int 😀 = 0;
#+end_src

All Invalid After p1949

tags: CWG, C++23, plenary-approved

**** [[https://wg21.link/p2071][P2071]] Named universal character escapes (Tom Honermann, R. Martinho Fernandes, Peter Bindels, Corentin Jabot, Steve Downey)
#+begin_quote
A proposal to extend universal character names from hexadecimal sequences to include the official names and formal aliases of Unicode codepoints.
#+end_quote
***** Before/After Table
****** Before:
#+begin_src c++
// UTF-32 character literal with U+0100 {LATIN CAPITAL LETTER A WITH MACRON}
U'\u0100'
// UTF-8 string literal with U+0100 {LATIN CAPITAL LETTER A WITH MACRON} U+0300 {COMBINING GRAVE ACCENT}
u8"\u0100\u0300"
#+end_src
****** After:
#+begin_src c++
U'\N{LATIN CAPITAL LETTER A WITH MACRON}' // Equivalent to U'\u0100'
u8"\N{LATIN CAPITAL LETTER A WITH MACRON}\N{COMBINING GRAVE ACCENT}" // Equivalent to u8"\u0100\u0300"
#+end_src

tags: CWG, straw-poll, C++23, plenary-approved


**** [[https://wg21.link/p2201][P2201]] Mixed string literal concatenation (Jens Maurer)
#+begin_quote
String concatenation involving string-literals with encoding-prefixes mixing L"", u8"", u"", and U"" is currently conditionally-supported with implementation-defined behavior.
[...]
No meaningful use-case for such mixed concatenations is known.

This paper makes such mixed concatenations ill-formed.
#+end_quote
tags: CWG, C++23, plenary-approved

**** [[https://wg21.link/p2223][P2223]] Trimming whitespaces before line splicing (Corentin Jabot)
#+begin_quote
We propose to make trailing whitespaces after \ non-significant.
#+end_quote
#+begin_src c++
int main() {
int i = 1
// \
+ 42
;
return i;
}
#+end_src
tags: CWG, C++23, SG22, plenary-approved


**** [[https://wg21.link/p2246][P2246]] Character encoding of diagnostic text (Aaron Ballman)
#+begin_quote
The standard provides a few mechanisms that suggest an implementation issues a diagnostic based on
text written in the source code. However, the standard does not uniformly address what should happen
if the execution character set of the compiler cannot represent the text in the source character set.
#+end_quote

#+begin_quote
Because the display of diagnostic messages should be merely a matter of Quality of Implementation, the
proposal is to place no character set related requirements on the diagnostic output with the
understanding that implementations will do what makes the most sense for their situation when issuing
diagnostics in terms of which characters need to be escaped or otherwise handled in a special way.
#+end_quote
tags: CWG, C++23, plenary-approved

**** [[https://wg21.link/p2290][P2290]] Delimited escape sequences (Corentin Jabot)
#+begin_quote
We propose an additional, clearly delimited syntax for octal, hexadecimal and universal
character name escape sequences.
#+end_quote
#+begin_quote
We propose new syntaxes \u{}, \o{}, \x{} usable in places where \u, \x, \nnn currently are.
\o{} accepts an arbitrary number of octal digits while \u{} and \x{} accept an arbitrary number
of hexadecimal digit.
#+end_quote
tags: CWG, straw-poll, C++23, plenary-approved

**** [[https://wg21.link/p2314][P2314]] Character sets and encodings (Jens Maurer)
#+begin_quote
This paper implements the following changes:
- Switch C++ to a modified "model C" approach for universal-character-names as described in the C99 Rationale v5.10, section 5.2.1.
- Introduce the term "literal encoding". For purposes of the C++ specification, the actual set of characters is not relevant, but the sequence of code units (i.e. the encoding) specified by a given character or string literal are. The terms "execution (wide) character set" are retained to describe the locale-dependent runtime character set used by functions such as isalpha.
- (Not a wording change) Do not attempt to treat all string literals the same; their treatment depends on (phase 7) context.
#+end_quote
***** Before/After Table
Before:
#+begin_src c++
#define S(x) # x
const char * s1 = S(Köppe);       // "K\\u00f6ppe"
const char * s2 = S(K\u00f6ppe);  // "K\\u00f6ppe"
#+end_src
After:
#+begin_src c++
#define S(x) # x
const char * s1 = S(Köppe);       // "Köppe"
const char * s2 = S(K\u00f6ppe);  // "Köppe"
#+end_src
tags: CWG, C++23, plenary-approved


**** [[https://wg21.link/p2316][P2316]] Consistent character literal encoding (Corentin Jabot)
#+begin_quote
Character literals in preprocessor conditional should behave like they do in C++ expression.
#+end_quote
#+begin_src c++
#if 'A' == '\x41'
//...
#endif
if ('A' == 0x41){}
#+end_src
tags: CWG, C++23, plenary-approved

**** [[https://wg21.link/p2362][P2362]] Make obfuscating wide character literals ill-formed (Peter Brett, Corentin Jabot)
#+begin_quote
C++ currently permits writing a wide character literal with multiple characters or characters that
cannot fit into a single ~wchar_t~ codeunit. For example:
#+end_quote
***** Example
#+begin_src c++
wchar_t a = L'🤦'; // \u{1F926}
wchar_t b = L'ab';
wchar_t c = L'é'; // \u{65}\u{301};
#+end_src
#+begin_quote
Make these literals ill-formed.
#+end_quote

tags: CWG, straw-poll, C++23, plenary-approved

**** [[https://wg21.link/p2460][P2460]] Relax requirements on wchar_t to match existing practices (Corentin Jabot)
#+begin_quote
We propose to remove the constraints put on the encoding associated with ~wchar_t~ in the core wording.
#+end_quote

***** Proposal
Type wchar_t is a distinct type that has an implementation-defined signed or unsigned integer type as its underlying type. +The values of type wchar_t can represent distinct codes for all members of the largest extended character set
specified among the supported locales.+

tags: CWG, LWG, straw-poll, C++23, tentatively-ready-for-plenary, IS, lwg-fullreview, B2 - improvement, size - small, plenary-approved, ...

**** [[https://wg21.link/p2295][P2295]] Correct UTF-8 handling during phase 1 of translation (Corentin Jabot, Peter Brett)
#+begin_quote
We propose that UTF-8 source files should be supported by all C++ compilers.
#+end_quote
tags: CWG, straw-poll, C++23, plenary-approved


**** [[https://wg21.link/p2513][P2513]] char8_t Compatibility and Portability Fixes (JeanHeyd Meneide, Tom Honermann)
#+begin_quote
char8_t has compatibility problems and issues during deployment that people have had to spend energy working around. This paper aims to alleviate some of those compatibility problems, for both C and C++, around string and character literals for the char8_t type.
#+end_quote
tags: CWG, straw-poll, C++23, B2 - improvement, plenary-approved

** Other CWG
- 32 Papers
**** [[https://wg21.link/p0849][P0849]] auto(x): DECAY_COPY in the language (Zhihao Yuan)
#+begin_quote
This paper proposes auto(x) and auto{x} for transforming x into a prvalue with the same value as-if passed as a function argument by value. When users asked for this functionality, we claimed that the DECAY_COPY notion in the standard serves such purpose, but it is for exposition only.
#+end_quote
***** Example
#+begin_src c++
// instead of:
auto subparser = parser;
subparser.add_option(...);

// you can write:
auto subparser = auto(parser).add_option(...);
#+end_src

tags: CWG, LWG, C++23, IS, plenary-approved

**** [[https://wg21.link/p1272][P1272]] Byteswapping for fun&&nuf (Isabella Muerte)
#+begin_src c++
namespace std {
    template <class IntegerType>
    constexpr IntegerType byteswap (IntegerType value) noexcept;
}
// Where std::is_integral_v<IntegerType> is true.
#+end_src
tags: CWG, LWG, C++23, plenary-approved

**** [[https://wg21.link/p1401][P1401]] Narrowing contextual conversions to bool (Andrzej Krzemienski)
#+begin_quote
This paper proposes to allow narrowing conversions in *contextually converted constant expressions of type `bool`*.
#+end_quote

| Today                                     | If accepted                         |
|-------------------------------------------+-------------------------------------|
| ~if constexpr(bool(flags & Flags::Exec))~ | ~if constexpr(flags & Flags::Exec)~ |
| ~if constexpr(flags & Flags::Exec != 0)~  | ~if constexpr(flags & Flags::Exec)~ |
| ~static_assert(N % 4 != 0);~              | ~static_assert(N % 4);~             |
| ~static_assert(bool(N));~                 | ~static_assert(N);~                 |

tags: CWG, C++23, plenary-approved

**** [[https://wg21.link/p1467][P1467]] Extended floating-point types (Michał Dominiak, David Olsen)
#+begin_quote
This paper introduces the notion of _extended floating-point types_, modeled
after extended integer types. To accomodate them, this paper also attempts to
rewrite the current rules for floating-point types, to enable well-defined
interactions between all the floating-point types. The end goal of this paper,
together with [P1468], is to have a language to enable ~<cstdint>~-like aliases
for implementation specific floating point types, that can model more binary
layouts than just a single fundamental type (the previously proposed short
float) can provide for
#+end_quote
tags: CWG, LWG, straw-poll, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved

**** [[https://wg21.link/p1675][P1675]] rethrow_exception must be allowed to copy (Billy O'Neal)
#+begin_quote
The ~current_exception~ wording was carefully written to allow both ABIs like
MSVC++’s where the exception objects are generally constructed on the stack,
and ABIs like the Itanium C++ ABI where the exception objects are generally
constructed on the heap (and possibly reference counted).  Implementations are
given the freedom they need to (possibly) copy the exception object into the
memory held by the exception_ptr, and similar. See
http://eel.is/c++draft/propagation#8.

Unfortunately, such care was not taken for ~rethrow_exception~.
#+end_quote

tags: CWG, LWG, C++23, B2 - improvement, size - small, plenary-approved


**** [[https://wg21.link/p1774][P1774]] Portable optimisation hints (Timur Doumler)
#+begin_quote
We propose a standard facility providing the semantics of existing compiler intrinsics such as
~__builtin_assume~ (Clang) and ~__assume~ (MSVC, Intel) that tell the compiler to assume a
given C++ expression without evaluating it, and to optimise based on this assumption. This is
very useful for high-performance and low-latency applications in order to generate both faster
and smaller code.
#+end_quote

tags: CWG, straw-poll, C++23, plenary-approved

**** [[https://wg21.link/p1847][P1847]] Make declaration order layout mandated (Pal Balog)
#+begin_quote
The current rules allow implementations freedom to reorder members in the layout if they have different
access control. To our knowledge no implementation actually used that freedom. We propose to fix this
established industry practice in the standard as mandatory.
#+end_quote
tags: CWG, C++23, plenary-approved


**** [[https://wg21.link/p2036][P2036]] Changing scope for lambda trailing-return-type (Barry Revzin)
#+begin_quote
This paper proposes that name lookup in the trailing-return-type of a lambda
first consider that lambda’s captures before looking further outward. We may
not know at the time of parsing the return type which names actually are
captured, so this paper proposes to treat all capturable entities as if they
were captured.
#+end_quote
tags: CWG, C++23, plenary-approved

**** [[https://wg21.link/p2156][P2156]] Allow Duplicate Attributes (Erich Keane)
#+begin_quote
The standard attributes noreturn, carries dependency, and deprecated all
specify that they cannot appear more than once in an attribute-list, but there
is no such prohibition if they appear in separate attribute-specifiers within a
single attributespecifier-seq. Since intuitively these cases are equivalent,
they should be treated the same, accepting duplicates in both or neither.
#+end_quote
tags: CWG, C++23, plenary-approved


**** [[https://wg21.link/p2173][P2173]] Attributes on Lambda-Expressions (Daveed Vandevoorde, Inbal Levi, Ville Voutilainen)
#+begin_quote
This paper proposes a fix for
[[http://open-std.org/JTC1/SC22/WG21/docs/cwg_toc.html#2097][Core Issue 2097]],
to allow attributes for lambdas, those attributes appertaining to the function
call operator of the lambda.
#+end_quote
#+begin_src c++
auto lm = [] [[nodiscard, vendor::attr]] () -> int { return 42; };
#+end_src
tags: CWG, straw-poll, C++23, plenary-approved

**** [[https://wg21.link/p2186][P2186]] Removing Garbage Collection Support (JF Bastien, Alisdair Meredith)
#+begin_quote
We propose removing (not deprecating) C++'s Garbage Collection support. Specifically, these five library functions:
- declare_reachable
- undeclare_reachable
- declare_no_pointers
- undeclare_no_pointers
- get_pointer_safety

As well as the pointer_safety enum, the __STDCPP_STRICT_POINTER_SAFETY__ macro, and the Core Language wording.
#+end_quote
tags: CWG, LWG, C++23, IS, plenary-approved


**** [[https://wg21.link/p2266][P2266]] Simpler implicit move (Arthur O'Dwyer)
#+begin_quote
In C++20, return statements can implicitly move from local variables of rvalue reference type; but a defect in the wording means that implicit move fails to apply to functions that return references. C++20’s implicit move is specified via a complicated process involving two overload resolutions, which is hard to implement, causing implementation divergence. We fix the defect and simplify the spec by saying that a returned move-eligible id-expression is always an xvalue.
#+end_quote
tags: CWG, straw-poll, C++23, plenary-approved



**** [[https://wg21.link/p2324][P2324]] Labels at the end of compound statements (C compatibility) (Martin Uecker)
#+begin_quote
WG14 adopted a change for C2X that allows placement of labels everywhere inside a compound
statement (N2508). While this improves compatibility with C++ which previously diverged from C
by allowing labels in front of declarations, there is still a remaining incompatibility: C now does
allow labels at the end of a compound statement, while C++ does not. It is proposed to change the
C++ grammar to remove this remaining difference.
#+end_quote
***** Example
#+begin_src c++
void foo(void)
{
first: // allowed in C++, now also allowed in C
int x;
second: // allowed in both C++ and C
x = 1;
last: // not allowed in C++, but now allowed in C
}
#+end_src
tags: CWG, straw-poll, C++23, size - small, plenary-approved

**** [[https://wg21.link/p2327][P2327]] De-deprecating volatile compound assignment (Paul Bendixen, Jens Maurer, Arthur O'Dwyer, Ben Saks)
#+begin_quote
The C++ 20 standard deprecated many functionalities of the volatile keyword. This was due to
P1152[Bastien, 2019]. The reasoning is given in the R0 version of the paper[Bastien, 2018].

The deprecation was not received too well in the embedded community as volatile is commonly
used for communicating with peripheral devices in microcontrollers[van Ooijen, 2020].

The purpose of this paper is to give a solution that will not undo what was achieved with
P1152, and still keep the parts that are critical to the embedded community.
#+end_quote
tags: CWG, straw-poll, C++23, plenary-approved


**** [[https://wg21.link/p2334][P2334]] Add support for preprocessing directives elifdef and elifndef (Melanie Blower)
#+begin_quote
This paper is being submitted as a liaison activity from WG14 C Language Working Group. The proposal
was discussed in the March 2021 meeting and approved (15 in favor, 1 opposed, 4 abstentions) for
inclusion into C23. This paper is being proposed to WG21 to avoid preprocessor incompatibilities with C
and because the utility is valuable to C++ users of the preprocessor.
#+end_quote
tags: CWG, C++23, plenary-approved

**** [[https://wg21.link/p2360][P2360]] Extend init-statement to allow alias-declaration (Jens Maurer)
***** Before:
#+begin_src c++
  for (typedef int T; T e : v)
    /* something */;
#+end_src
***** After:
#+begin_src c++
  for (using T = int; T e : v)
    /* something */;
#+end_src
tags: CWG, C++23, plenary-approved

**** [[https://wg21.link/p2437][P2437]] Support for #warning (Aaron Ballman)
#+begin_quote
Almost all major C++ compilers support the #warning preprocessing directive to
generate a diagnostic message from the preprocessor without stopping
translation, as ~#error~ does, which can be useful for code authors who want to
warn consumers of the code about non-fatal concerns.
#+end_quote

#+begin_quote
WG14 considered a similar proposal as part of WG14 N2686 at our Sept 2021
meeting and adopted the feature into C23 (straw poll results were: 17 in favor,
0 oppose, 1 abstain). The WG21 proposal is functionally identical to the WG14
proposal, with the only difference being due to existing variance in
specification around how ~#error~ causes translation to stop.
#+end_quote
tags: CWG, straw-poll, C++23, size - tiny, plenary-approved

**** [[https://wg21.link/p2468][P2468]] The Equality Operator You Are Looking For (Barry Revzin, Bjarne Stroustrup, Cameron DaCamara, Daveed Vandevoorde, Gabriel Dos Reis, Herb Sutter, Jason Merrill, Jonathan Caves, Richard Smith, Ville Voutilainen)
#+begin_quote
This paper details some changes to make rewriting equality in expressions less of a breaking change
#+end_quote
#+begin_quote
- If you want an operator== that is used for rewrites (automatically reversed, and != automatically generated), write only an operator==, and make sure its return type is bool.

- If you want an operator== that is not used for rewrites, write both an operator== and a matching operator!=.

- operator<=> is always used for rewrites (from <, <=, >, >=); if you don’t want rewrites, don’t write an operator<=>.
#+end_quote
tags: CWG, straw-poll, C++23, plenary-approved

**** [[https://wg21.link/p2493][P2493]] Missing feature test macros for C++20 core papers (Barry Revzin)
#+begin_quote
As Jonathan Wakely pointed out on the SG10 mailing list, neither [P0848R3] (Conditionally Trivial Special Member Functions) nor [P1330R0] ( Changing the active member of a union inside constexpr) provided a feature-test macro.
#+end_quote

#+begin_quote
This paper proposes Richard’s second suggestion: bump __cpp_concepts and __cpp_constexpr to 202002L
#+end_quote
tags: CWG, straw-poll, C++23, plenary-approved

**** [[https://wg21.link/p2582][P2582]] Wording for class template argument deduction from inherited constructors (Timur Doumler)
#+begin_quote
This paper provides wording for class template argument deduction from inherited constructors.
#+end_quote
From [[https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1021r6.html][P1021R6]]

***** Before:
#+begin_src c++
template<class T>
struct Point { T x; T y; };

// Aggregate: Cannot deduce
Point<double> p{3.0, 4.0};
Point<double> p2{.x = 3.0, .y = 4.0};
#+end_src

***** After:
#+begin_src c++

template<class T>
struct Point { T x; T y; };

// Proposed: Aggregates deduce
Point p{3.0, 4.0};
Point p2{.x = 3.0, .y = 4.0};
#+end_src
tags: CWG, straw-poll, C++23, plenary-approved

**** [[https://wg21.link/p0330][P0330]] Literal Suffixes for ptrdiff_t and size_t (JeanHeyd Meneide, Rein Halbersma)
#+begin_quote
This paper proposes core language suffixes for size_t and its associated signed type.
#+end_quote

******* Before
#+begin_src c++
std::vector<int> v{0, 1, 2, 3};
for (auto i = 0u, s = v.size(); i < s; ++i) {
	/* use both i and v[i] */
}
⚠️ - Compiles on 32-bit, truncates (maybe with warnings) on 64-bit
std::vector<int> v{0, 1, 2, 3};
for (auto i = 0, s = v.size(); i < s; ++i) {
	/* use both i and v[i] */
}
❌ - Compilation error
#+end_src
******* After
#+begin_src c++
std::vector<int> v{0, 1, 2, 3};
for (auto i = 0uz, s = v.size(); i < s; ++i) {
	/* use both i and v[i] */
}
#+end_src
LWG, C++23, tiny, plenary-approved


tags: C++23, plenary-approved

**** [[https://wg21.link/p1102][P1102]] Down with ~()~! (Alex Christensen, JF Bastien)
#+begin_quote
A proposal for removing unnecessary ()’s from C++ lambdas.
#+end_quote

tags: C++23, IS, plenary-approved


**** [[https://wg21.link/p0943][P0943]] Support C atomics in C++ (Hans-J. Boehm)
#+begin_quote
We propose to define what it means to include the C ~<stdatomic.h>~ header from C++ code. The goal is to enable "shared" headers that use atomics, and can be included from either C or C++ code.
#+end_quote
tags: C++23, IS, B2 - improvement, size - small, plenary-approved

**** [[https://wg21.link/p1048][P1048]] A proposal for a type trait to detect scoped enumerations (Juan Alday)
#+begin_quote
This paper proposes ~is_scoped_enum~, a new trait for the C++ Standard Library, to detect
whether a type is a scoped enumeration.
#+end_quote
tags: C++23, IS, B3 - addition, size - small, plenary-approved



**** [[https://wg21.link/p1169][P1169]] static operator() (Barry Revzin, Casey Carter)
#+begin_quote
The proposal is to just allow the ability to make the call operator a static member function, instead of requiring it to be a non-static member function. We have many years of experience with member-less function objects being useful.
#+end_quote

tags: CWG, LWG, straw-poll, C++23, tentatively-ready-for-plenary, IS, B3 - addition, size - medium, plenary-approved, expedited-library-...



**** [[https://wg21.link/p1467][P1467]] Extended floating-point types (Michał Dominiak, David Olsen)
#+begin_quote
This paper introduces the notion of _extended floating-point types_, modeled
after extended integer types. To accomodate them, this paper also attempts to
rewrite the current rules for floating-point types, to enable well-defined
interactions between all the floating-point types. The end goal of this paper,
together with [P1468], is to have a language to enable ~<cstdint>~-like aliases
for implementation specific floating point types, that can model more binary
layouts than just a single fundamental type (the previously proposed short
float) can provide for
#+end_quote
tags: CWG, LWG, straw-poll, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved

**** [[https://wg21.link/p1642][P1642]] Freestanding Library: Easy [utilities] (Ben Craig)
#+begin_quote
This paper proposes adding many of the facilities in the ~[utilities]~, ~[ranges]~, and ~[iterators]~ clause to the freestanding subset of C++. The paper will be adding only complete entities, and will not tackle partial classes. For example, classes like ~pair~ and ~tuple~ are being added, but trickier classes like ~optional~, ~variant~, and ~bitset~ will come in another paper.

The ~<memory>~ header depends on facilities in ~<ranges>~ and ~<iterator>~, so those headers (and clauses) are addressed as well.
#+end_quote
tags: CWG, LWG, SG14, C++23, tentatively-ready-for-plenary, freestanding, IS, B2 - improvement, size - medium, plenary-approved


**** [[https://wg21.link/p1787][P1787]] Declarations and where to find them (S. Davis Herring)
#+begin_quote
The current descriptions of scope and name lookup are confusing, incomplete, and at times incorrect.
#+end_quote

tags: modules, C++23, IS, plenary-approved

**** [[https://wg21.link/p1938][P1938]] if consteval (Barry Revzin, Daveed Vandevoorde, Richard Smith)
#+begin_quote
We propose a new form of if statement which is spelled:

~if consteval { }~
#+end_quote
***** Example
#+begin_src c++
consteval int f(int i) { return i; }

constexpr int g(int i) {
    if consteval {
        return f(i) + 1; // ok: immediate function context
    } else {
        return 42;
    }
}

consteval int h(int i) {
    return f(i) + 1; // ok: immediate function context
}
#+end_src
tags: CWG, LWG, C++23, plenary-approved

**** [[https://wg21.link/p2036][P2036]] Changing scope for lambda trailing-return-type (Barry Revzin)
#+begin_quote
This paper proposes that name lookup in the trailing-return-type of a lambda
first consider that lambda’s captures before looking further outward. We may
not know at the time of parsing the return type which names actually are
captured, so this paper proposes to treat all capturable entities as if they
were captured.
#+end_quote
tags: CWG, C++23, plenary-approved



**** [[https://wg21.link/p2564][P2564]] consteval needs to propagate up (Barry Revzin)
#+begin_quote
This paper proposes avoiding the consteval coloring problem (or, at least, mitigating its annoyances) by allowing certain existing constexpr functions to implicitly become consteval functions when those functions can already only be invoked during compile time anyway.

Specifically, these three rules:

1. If a constexpr function contains a call to an immediate function outside of an immediate function context, and that call itself isn’t a constant expression, said constexpr function implicitly becomes a consteval function. This is intended to include lambdas, function template specializations, special member functions, and should cover member initializers as well.

2. If an expression-id designates a consteval function without it being an immediate call in such a context, it also makes the context implicitly consteval. Such expression-id’s are also allowed in contexts that are manifestly constant evaluated.

3. Other manifestly constant evaluated contexts (like constant-expression and the condition of a constexpr if statement) are now considered to be immediate function contexts.
#+end_quote

tags: CWG, straw-poll, C++23, nb-comment, plenary-approved

**** [[https://wg21.link/p2579][P2579]] Mitigation strategies for P2036 ”Changing scope for lambda trailing-return-type” (Corentin Jabot)
#+begin_quote
P2036R3 was adopted for C++23 and as a Defect Report, affecting C++11 and
greater. After implementing this paper in Clang, we observed the proposed
changes make ill-formed previously valid and relied upon code.
#+end_quote
#+begin_quote
identifiers refered to captured variables but do not take the mutable keyword
into account
#+end_quote

#+begin_src c++
struct F {
float x;
void mem1(decltype((x)) p3); // p3 is a float&
void mem2(decltype((x)) p4) const; // p4 is a float&
};
#+end_src

#+begin_src c++
int x;
[x=42.0]<decltype(x) a> // float
(decltype((x)) b) // float&
-> decltype((x)) // const float&
#+end_src

tags: CWG, straw-poll, C++23, plenary-approved

* Library Working Group Features
** Ranges
- 36 Papers + 2 from "Major"
**** [[https://wg21.link/p1659][P1659]] starts_with and ends_with (Christopher Di Bella)
#+begin_quote
This proposal seeks to add std::ranges::starts_with and std::ranges::ends_with, which would work on arbitrary ranges, and also answer questions such as "are the starting elements of `r1` less than the elements of `r2`?" and "are the final elements of `r1` greater than the elements of `r2`?"
#+end_quote
***** Before/After Table
Before:
#+begin_src c++
auto some_ints      = view::iota(0, 50);
auto some_more_ints = view::iota(0, 30);
if (ranges::mismatch(some_ints, some_more_ints).in2 == end(some_more_ints)) {
    // do something
}
#+end_src
After:
#+begin_src c++
auto some_ints      = view::iota(0, 50);
auto some_more_ints = view::iota(0, 30);
if (ranges::starts_with(some_ints, some_more_ints)) {
    // do something
}
#+end_src

tags: LWG, C++23, IS, size - small, plenary-approved

**** [[https://wg21.link/p1989][P1989]] Range constructor for std::string_view 2: Constrain Harder (Corentin Jabot)
#+begin_src c++
template<class R>
basic_string_view(R&&)
-> basic_string_view<ranges::range_value_t<R>>;
#+end_src
tags: LWG, ranges, C++23, plenary-approved

**** [[https://wg21.link/p2321][P2321]] zip (Tim Song)
#+begin_quote
This paper proposes
- four views, zip, zip_transform, adjacent, and adjacent_transform,
- changes to tuple and pair necessary to make them usable as proxy references (necessary for zip and adjacent), and
- changes to vector<bool>::reference to make it usable as a proxy reference for writing,
#+end_quote

***** Example
#+begin_src c++
std::vector v1 = {1, 2};
std::vector v2 = {'a', 'b', 'c'};
std::vector v3 = {3, 4, 5};

fmt::print("{}\n", std::views::zip(v1, v2));                              // {(1, 'a'), (2, 'b')}
fmt::print("{}\n", std::views::zip_transform(std::multiplies(), v1, v3)); // {3, 8}
fmt::print("{}\n", v2 | std::views::pairwise);                            // {('a', 'b'), ('b', 'c')}
fmt::print("{}\n", v3 | std::views::pairwise_transform(std::plus()));     // {7, 9}
#+end_src
tags: LWG, ranges, C++23, IS, B3 - addition, plenary-approved

**** [[https://wg21.link/p2302][P2302]] Prefer std::ranges::contains over std::basic_string_view::contains (Christopher Di Bella)
#+begin_quote
P2302 proposes two algorithms: one that checks whether or not a range contains an element, and one that checks whether or not a range contains a subrange
#+end_quote
Before:
#+begin_src c++
namespace stdr = std::ranges;
stdr::find(haystack.begin(), haystack.end(), 'o') != haystack.end()
stdr::find(haystack, 'o') != stdr::end(haystack)
not stdr::search(haystack, long_needle).empty()
not stdr::search(haystack, long_needle, bind_back(std::modulo(), 4)).empty()
#+end_src
After:
#+begin_src c++
namespace stdr = std::ranges;
stdr::contains(haystack.begin(), haystack.end(), 'o')
stdr::contains(haystack, 'o')
stdr::contains_subrange(haystack, long_needle)
stdr::contains_subrange(haystack, long_needle, bind_back(std::modulo(), 4))
#+end_src
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved

**** [[https://wg21.link/p2322][P2322]] ranges::fold (Barry Revzin)
#+begin_quote
While we do have an iterator-based version of fold in the standard library, it is currently named accumulate, defaults to performing + on its operands, and is found in the header <numeric>. But fold is much more than addition, so as described in the linked paper, it’s important to give it the more generic name and to avoid a default operator.
#+end_quote
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved

**** [[https://wg21.link/p2387][P2387]] Pipe support for user-defined range adaptors (Barry Revzin)
#+begin_quote
Walter Brown made an excellent observation: if we gave users the tools to write their own range adaptors that would properly inter-operate with standard library adaptors (as well as other users’ adaptors), then it becomes less important to provide more adaptors in the standard library.

The goal of this paper is provide that functionality: provide a standard customization mechanism for range adaptors, so that everybody can write their own adaptors.
#+end_quote

tags: LWG, ranges, C++23, IS, B2 - improvement, size - medium, plenary-approved

**** [[https://wg21.link/p2325][P2325]] Views should not be required to be default constructible (Barry Revzin)
#+begin_quote
Currently, the view concept is defined in 24.4.4 [range.view] as:
#+end_quote
#+begin_src c++
template <class T>
concept view =
    range<T> &&
    movable<T> &&
    default_initializable<T> &&
    enable_view<T>;
#+end_src
***** Discussion
#+begin_quote
Three of these four criteria, I understand. A view clearly needs to be a range, and it’s important that they be movable for various operations to work. And the difference between a view and range is largely semantic, and so there needs to be an explicit opt-in in the form of enable_view.

But why does a view need to be default_initializable?
#+end_quote
tags: LWG, ranges, C++23, IS, B2 - improvement, plenary-approved

**** [[https://wg21.link/p2367][P2367]] Remove misuses of list-initialization from Clause 24 (Tim Song)
#+begin_quote
This paper provides wording for [LWG3524] and resolves related issues caused by the erroneous use of list-initialization in ranges wording.
#+end_quote

#+begin_quote
As discussed in [LWG3524], the use of list-initialization in the ranges specification implies ordering guarantees that are unintended and unimplementable in ordinary C++, as well as narrowing checks that are unnecessary and sometimes unimplementable.
#+end_quote
tags: LWG, C++23, plenary-approved


**** [[https://wg21.link/P2432][P2432]] Fix istream_view (Nicolai Josuttis)
#+begin_quote
This paper fixes a fundamental design problem with the current helper function
std::ranges::istream_view<>() that cause multiple inconsistences and unnecessary code
overhead when declaring istream_view objects
#+end_quote
Before:
#+begin_src c++
std::ranges::istream_view<int> v{mystream}
 // ERROR
#+end_src
After:
#+begin_src c++
std::ranges::istream_view<int> v{mystream}
 // OK
#+end_src
tags: LWG, ranges, C++23, IS, B2 - improvement, size - small, plenary-approved


**** [[https://wg21.link/p2415][P2415]] What is a view? (Barry Revzin, Tim Song)
#+begin_quote
Once upon a time, a view was a cheaply copyable, non-owning range. We’ve already somewhat lost the “cheaply copyable” requirement since views don’t have to be copyable, and now this paper is suggesting that we also lose the non-owning part.
#+end_quote
tags: LWG, ranges, C++23, IS, B2 - improvement, size - medium, plenary-approved


**** [[https://wg21.link/p2408][P2408]] Ranges views as inputs to non-Ranges algorithms (David Olsen)
#+begin_quote
Change the iterator requirements for non-Ranges algorithms. For forward iterators and above that are constant iterators, instead of requiring that iterators meet certain /Cpp17...Iterator/ requirements, require that the iterators model certain iterator concepts. This makes iterators from several standard views usable with non-Ranges algorithms that require forward iterators or above, such as the parallel overloads of most algorithms.
#+end_quote
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, plenary-approved

**** [[https://wg21.link/p2210][P2210]] Superior String Splitting (Barry Revzin)
***** Proposal Part 1
#+begin_quote
This paper proposes the following:
Rename the existing ~views::split~ / ~ranges::split_view~ to ~views::lazy_split~ / ~ranges::lazy_split_view~. Add ~base()~ member functions to the ~inner-iterator~ type to get back to the adapted range’s iterators.
#+end_quote

***** Proposal Part 2
#+begin_quote
1. Introduce a new range adapter under the name ~views::split~ / ~ranges::split_view~ with the following design:

   1. It can only support splitting forward-or-better ranges.
   2. Splitting a ~V~ will yield ~subrange<iterator_t<V>>~s, ensuring that the adapted range’s category is preserved. Splitting a bidirectional range gives out bidirectional subranges. Spltiting a contiguous range gives out contiguous subranges.
   3. ~views::split~ will not be ~const~-iterable.
#+end_quote
***** Example
#+begin_src c++
auto ip = "127.0.0.1"s;
auto parts = ip | std::views::split('.')
                | std::views::transform([](std::span<char const> s){
                      int i;
                      std::from_chars(s.data(), s.data() + s.size(), i);
                      return i;
                  });
#+end_src
tags: LWG, ranges, C++23, IS, B2 - improvement, plenary-approved

**** [[https://wg21.link/p2440][P2440]] ranges::iota, ranges::shift_left, and ranges::shift_right (Tim Song)
#+begin_quote
This paper proposes adding the algorithms ranges::iota, ranges::shift_left, and ranges::shift_right, to match their std counterparts.
#+end_quote
tags: LWG, ranges, C++23, IS, B3 - addition, size - medium, plenary-approved

**** [[https://wg21.link/p2443][P2443]] views::chunk_by (Tim Song)
#+begin_quote
This paper proposes the range adaptor views::chunk_by as described in section 4.3 of [P2214R1].
#+end_quote
#+begin_src c++
std::vector v = {1, 2, 2, 3, 0, 4, 5, 2};
fmt::print("{}\n", v | std::views::chunk_by(ranges::less_equal{}));   // [[1, 2, 2, 3], [0, 4, 5], [2]]
#+end_src

tags: LWG, ranges, C++23, IS, B3 - addition, size - medium, plenary-approved

**** [[https://wg21.link/P2328][P2328]] join_view should join all views of ranges (Tim Song)
#+begin_quote
This paper proposes relaxing the constraint on join_view to support joining ranges of prvalue non-view ranges.
#+end_quote
tags: LWG, ranges, C++23, IS, B2: Improvement, plenary-approved

**** [[https://wg21.link/p2442][P2442]] Windowing range adaptors: views::chunk and views::slide (Tim Song)
#+begin_quote
This paper proposes two range adaptors, views::chunk and views::slide, as described in section 3.5 of [P2214R0].
#+end_quote
#+begin_src c++
std::vector v = {1, 2, 3, 4, 5};
fmt::print("{}\n", v | std::views::chunk(2));   // [[1, 2], [3, 4], [5]]
fmt::print("{}\n", v | std::views::slide(2));   // [[1, 2], [2, 3], [3, 4], [4, 5]]
#+end_src
tags: LWG, ranges, C++23, IS, B3 - addition, size - medium, plenary-approved

**** [[https://wg21.link/p2441][P2441]] views::join_with (Barry Revzin)
#+begin_quote
The behavior of ~views::join_with~ is an inverse of ~views::split~. That is, given a range ~r~ and a pattern ~p~, ~r | views::split(p) | views::join_with(p)~ should yield a range consisting of the same elements as ~r~.
#+end_quote
tags: LWG, ranges, C++23, IS, plenary-approved

**** [[https://wg21.link/p2446][P2446]] views::move (Barry Revzin)
#+begin_quote
~as_rvalue_view~ presents a view of an underlying sequence with the same behavior as the underlying sequence except that its elements are rvalues. Some generic algorithms can be called with a as_rvalue_view to replace copying with moving.

The name views::as_rvalue denotes a range adaptor object ([range.adaptor.object]).
#+end_quote
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, plenary-approved

**** [[https://wg21.link/p2494][P2494]] Relaxing range adaptors to allow for move only types (Michał Dominiak)
#+begin_quote
Currently, many range adaptors require that the user-provided types they store must be copy constructible, which is also required by the assignment wrapper they use, copyable-box.
#+end_quote

#+begin_quote
Similarly to how [P2325R3] turned semiregular-box into copyable-box, this paper proposes to turn copyable-box into movable-box. This name is probably not ideal, because it still turns types that happen to be copy constructible into copyable types, but it follows from the prior changes to the wrapper.
#+end_quote
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, plenary-approved

**** [[https://wg21.link/P2502][P2502]] std::generator: Synchronous Coroutine Generator for Ranges (Casey Carter)
#+begin_quote
We propose a standard library type std::generator which implements a coroutine generator
that models std::ranges::input_range.
#+end_quote
***** Example
#+begin_src c++
std::generator<int> fib() {
    auto a = 0, b = 1;
    while (true) {
        co_yield std::exchange(a, std::exchange(b, a + b));
    }
}
int answer_to_the_universe() {
    auto rng = fib() | std::views::drop(6) | std::views::take(3);
    return std::ranges::fold_left(std::move(range), 0, std::plus{});
}
#+end_src
tags: LWG, coroutines, ranges, C++23, tentatively-ready-for-plenary, IS, B1 - focus, plenary-approved

**** [[https://wg21.link/p2281][P2281]] Clarifying range adaptor objects (Tim Song)
#+begin_quote
The wording below clarifies that the partial application performed by range adaptor objects is essentially identical to that performed by bind_front. (Indeed, it is effectively a limited version of bind_back.) In particular, this means that the bound arguments are captured by copy or move, and never by reference. Invocation of the pipeline then either copies or moves the bound entities, depending on the value category of the pipeline.
#+end_quote
***** Example
#+begin_src c++
auto c = /* some range */;
auto f = /* expensive-to-copy function object */;
c | transform(f); // copies f and then move it into the view

auto t = transform(f); // copies f
c | t;                 // copies f again from t
c | std::move(t);      // moves f from t
#+end_src
tags: LWG, C++23, plenary-approved

**** [[https://wg21.link/p0429][P0429]] A Standard flatmap (Zach Laine)...
#+begin_quote
This paper outlines what a (mostly) API-compatible, non-node-based map might
look like. Rather than presenting a final design, this paper is intended as a
starting point for discussion and as a basis for future work. Specifically,
there is no mention of ~multimap~, ~set~, or ~multiset~.
#+end_quote

The final paper has wording for a map based on contiguous storage of keys and data.
tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved

**** [[https://wg21.link/p1222][P1222]] A Standard flatset (Zach Laine)
#+begin_quote
This paper outlines what a (mostly) API-compatible, non-node-based set might look like.
#+end_quote
tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved

**** [[https://wg21.link/p1899][P1899]] stride_view (Christopher Di Bella)
#+begin_quote
The ability to use algorithms over an evenly-spaced subset of a range has been missed in the STL for a quarter of a century. Given that there’s no way to compose a strided range adaptor in C++20, this should be adopted for C++23.
#+end_quote
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, plenary-approved, expedited-library-evolution-electronic-poll

**** [[https://wg21.link/p2017][P2017]] Conditionally safe ranges (Barry Revzin)
#+begin_quote
Several range adapters semantically behave as if they have a single member of some templated view type. If that underlying view type is a ~borrowed_range~, the range adapter itself can be transitively borrowed.
#+end_quote
tags: ranges, C++23, IS, size - small, plenary-approved

**** [[https://wg21.link/p2164][P2164]] views::enumerate (Corentin Jabot)
#+begin_quote
_A struct with 2 members, how hard can it be?_
#+end_quote

#+begin_quote
We propose a view ~enumerate~ whose value type is a +struct with 2 members index and value+ _tuple of two elements_
representing respectively the position and value of the elements in the adapted range.
#+end_quote
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B3 - addition, size - medium, plenary-approved

**** [[https://wg21.link/p2165][P2165]] Compatibility between ~tuple~, ~pair~ and _tuple-like_ objects (Corentin Jabot)
#+begin_quote
We propose to make pair constructible from ~tuple~ and ~std::array~ We mandate
~tuple_cat~ and friends to be compatible with these types, and associative
containers more compatible with them. The changes proposed in this paper make
the use of ~std::pair~ unnecessary in new code
#+end_quote

tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, lwg-fullreview, B2 - improvement, size - medium, plenary-approved

**** [[https://wg21.link/p2278][P2278]] cbegin should always return a constant iterator (Barry Revzin)
#+begin_quote
~cbegin~ should always return a constant iterator.
#+end_quote

***** Proposal
#+begin_quote
We can resolve this by extending ~std::ranges::cbegin~ and ~std::ranges::cend~
to conditionally wrap their provided range’s iterator/sentinel pairs to ensure
that the result is a constant iterator, and use these tools to build up a
views::as_const range adapter. This completely solves the problem without any
imposed boilerplate per range.
#+end_quote
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, plenary-approved

**** [[https://wg21.link/p2374][P2374]] views::cartesian_product (Sy Brand, Michał Dominiak )
#+begin_quote
This paper proposes std::ranges::cartesian_product_view for taking the cartesian product of multiple forward ranges.
#+end_quote

***** Before
#+begin_src c++
std::vector<int> a,b,c;
for (auto&& ea : a) {
    for (auto&& eb : b) {
        for (auto&& ec : c) {
            use(ea,eb,ec);
        }
    }
}
#+end_src
***** After
#+begin_src c++
std::vector<int> a,b,c;
for (auto&& [ea,eb,ec] : std::views::cartesian_product(a,b,c)) {
    use(ea,eb,ec);
}
#+end_src
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, plenary-approved

**** [[https://wg21.link/p2404][P2404]] Relaxing equality_comparable_with's and three_way_comparable_with's common reference requir...
#+begin_quote
None of ~equality_comparable_with~, ~totally_ordered_with~, or
~three_way_comparable_with~ support move-only types. For move-only types, these
concept’s common reference requirement currently ends up requiring that the two
types ~const T&~ and ~const U&~ can be converted to the non-reference
~common_reference_t~, meaning that it requires ~T~ and ~U~ to be copyable. This
common reference requirement should be relaxed to support these move-only
types, effectively turning the common reference requirement into a common
_supertype_ requirement, as the original reason to require formable references
no longer exists.
#+end_quote
tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, expedited-library-evolution-electronic-poll

**** [[https://wg21.link/p2474][P2474]] views::repeat (Michał Dominiak)
#+begin_quote
This paper proposes a new range factory, views::repeat, which creates a range that repeats the same value either infinitely, or a specified number of times.
#+end_quote

tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B3 - addition, size - small, plenary-approved, expedited-library-evolution-...

**** [[https://wg21.link/p2499][P2499]] string_view range constructor should be explicit (James Touton)
#+begin_quote
P1989R2 added a new constructor to ~basic_string_view~ that allows for implicit conversion from any contiguous range of the corresponding character type. This implicit conversion relies on the premise that a range of ~char~ is inherently string-like. While that premise holds in some situations, it is hardly universally true, and the implicit conversion is likely to cause problems. This paper proposes making the conversion explicit instead of implicit in order to avoid misleading programmers.
#+end_quote
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, plenary-approved

**** [[https://wg21.link/p2520][P2520]] move_iterator should be a random access iterator (Barry Revzin)
#+begin_quote
~move_iterator<T*>~ should be a random access iterator
#+end_quote
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved, expedited-library-evoluti...

**** [[https://wg21.link/p2540][P2540]] Empty Product for certain Views (Steve Downey)
#+begin_quote
This paper argues that the Cartesian product of no ranges should be a single
empty tuple, which is the identity element for Cartesian products. Other
product-like views, however, should not automatically have their identity be
the result, and in particular for zip, as it would introduce unsound
inconsistencies.
#+end_quote


tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, plenary-approved

**** [[https://wg21.link/p2602][P2602]] Poison Pills are Too Toxic (Barry Revzin)
Given the following declarations:

#+begin_src c++
struct A {
    friend auto begin(A const&) -> int const*;
    friend auto end(A const&)   -> int const*;
};

struct B {
    friend auto begin(B&) -> int*;
    friend auto end(B&) -> int*;
};
#+end_src

B and const A satisfy std::ranges::range, but A does not. The goal of this paper is that both of these should count as ranges.

tags: LWG, ranges, C++23, IS, B2 - improvement, size - small, plenary-approved

**** [[https://wg21.link/p2609][P2609]] Relaxing Ranges Just A Smidge (John Eivind Helset)
#+begin_quote
Ranges algorithms that take a function and a projection should, in the unary case, constrain the function to enable:
#+end_quote

#+begin_src c++
iter_value_t<It> x = *it;
f(proj(x));
#+end_src

#+begin_quote
Instead they are constrained to allow:
#+end_quote

#+begin_src c++
iter_value_t<projected<I,Proj>> u = proj(*it);
f(u);
#+end_src

#+begin_quote
And likewise in the binary case. This is caused by the composition of indirect callable concepts with projected, seen for example in the constraints of ranges::for_each as indirect_unary_invocable<projected<I,P>>.

A fix is proposed that introduces a type-trait and makes a slight change to the definitions of the indirect callable concepts, as well as iter_common_reference_t. The fix is a slight relaxation of the algorithmic constraints in ranges that does not break ABI.
#+end_quote

tags: LWG, ranges, C++23, IS, B2 - improvement, size - small, plenary-approved

** ~mdspan~
- 5 Papers + 1
**** [[https://wg21.link/p2553][P2553]] Make mdspan size_type controllable (Christian Trott, Damien Lebrun-Grandie, Mark Hoemmen, K. R. Walker, Daniel Sunderland)
#+begin_quote
P0009 explicitly sets the size_type of extents to size_t, which is then used by layout mappings and mdspan. While this matches span whose extent function returns size_t, this behavior has significant performance impact on various architectures where 64-bit integer throughput is significantly lower than 32-bit integer computation throughput.
#+end_quote

Proposal:

#+begin_quote
All in all we prefer the option of making extents require the additional argument (2.2.2), with the next best thing being the introduction basic_extents and making extents an alias to basic_extents with size_t as the size_type. If LEWG would prefer the second option, the wording is largely the same with the following changes at the end:

- Rename extents to basic_extents throughout P0009 and

- Add an alias in [mdspan.syn]:
#+end_quote

#+begin_src c++
template<size_t ... Extents>
using extents = basic_extents<size_t, Extents...>;
#+end_src
tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, mdspan

**** [[https://wg21.link/p2554][P2554]] C-Array Interoperability of MDSpan (Christian Trott, Damien Lebrun-Grandie, Mark Hoemmen, K. R. Walker, Daniel Sunderland)
#+begin_quote
We cannot currently fix the multidimensional c-array construction, since it is UB to alias a nested C-Array with a element type pointer - per discussion on the C++ committee reflector in January 2022. However, in practice it works (on the compilers we tested e.g. clang-based and gcc) - and it may be something the committee changes in the future - i.e. make it not-UB. We propotyped this capability, which requires an additional constructor from c-array and a few deduction guides.

What we can fix today is the deduction from 1D c-array, by adding a deduction guide from c-array constraint to rank-1 arrays.
#+end_quote

tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, mdspan

**** [[https://wg21.link/P2599][P2599]] mdspan::size_type should be index_type (Nevin Liber)
#+begin_quote
With the adoption of P2553R1, ~mdspan::size_type~ may now be a signed type.
~size_type~ is no longer an appropriate name for this type and it should be changed to ~index_type~.
#+end_quote

tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, mdspan

**** [[https://wg21.link/P2604][P2604]] mdspan: rename pointer and contiguous (Christian Trott)
#+begin_quote
During LWG review a few members of classes in the mdspan proposals were identified as problematic, this paper proposes renaming those members.
#+end_quote

***** ~pointer~ to ~data_handle_type~
***** ~data()~ to ~data_handle()~
***** ~contiguous~ to ~exhaustive~

tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, mdspan

**** [[https://wg21.link/p2613][P2613]] Add the missing =empty= to =mdspan= (Yihe Le)
#+begin_quote
This paper propose to fix a defect in [P0009R17]. During its LWG review, I found that even though the proposed std::mdspan type have a size() member function, it does not have an empty() member function, which makes it distinct from nearly all other STL containers. So this paper propose to add the missing member to increase consistency and performance of common operations.
#+end_quote

tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, mdspan

** Output
- 8 Papers
**** [[https://wg21.link/p1147][P1147]] Printing =volatile= Pointers (Bryce Adelstein Lelbach)
#+begin_quote
Printing pointers to volatile types with standard library output streams has unexpected results. Consider the following code:
#+end_quote
***** Example
#+begin_src c++
#include <iostream>

int main() {
    int*          p0 = reinterpret_cast<int*>(0xdeadbeef);
    volatile int* p1 = reinterpret_cast<volatile int*>(0xdeadbeef);

    std::cout << p0 << std::endl;
    std::cout << p1 << std::endl;
}
#+end_src
#+begin_quote
This produces the following output:

#+begin_example
0xdeadbeef
#+end_example

1
#+end_quote
tags: LWG, C++23, IS, plenary-approved

**** [[https://wg21.link/p2216][P2216]] std::format improvements (Victor Zverovich)
#+begin_quote
This paper proposes the following improvements to the C++20 formatting facility:
- Improving safety via compile-time format string checks
- Reducing binary code size of format_to
#+end_quote
#+begin_src c++
std::string s = std::format("{:d}", "I am not a number");
#+end_src
Becomes ill-formed
tags: LWG, C++23, IS, plenary-approved

**** [[https://wg21.link/P2372][P2372]] Fixing locale handling in chrono formatters (Victor Zverovich, Corentin Jabot)
#+begin_quote
In C++20 "Extending <chrono> to Calendars and Time Zones" ([P0355]) and "Text Formatting" ([P0645]) proposals were integrated ([P1361]). Unfortunately during this integration a design issue was missed: std::format is locale-independent by default and provides control over locale via format specifiers but the new formatter specializations for chrono types are localized by default and don’t provide such control.
#+end_quote
***** Solution
#+begin_quote
We propose fixing this issue by making chrono formatters locale-independent by default and providing the L specifier to opt into localized formatting in the same way as it is done for all other standard formatters (format.string.std).
#+end_quote
***** Before:
#+begin_src c++
auto s = std::format("{:%S}", sec(4.2));
// s == "04,200"

auto s = std::format("{:L%S}", sec(4.2));
// throws format_error
#+end_src
***** After:
#+begin_src c++
auto s = std::format("{:%S}", sec(4.2));
// s == "04.200"

auto s = std::format("{:L%S}", sec(4.2));
// s == "04,200"
#+end_src

tags: LWG, C++23, IS, plenary-approved

**** [[https://wg21.link/p2418][P2418]] Add support for std::generator-like types to std::format (Victor Zverovich)
#+begin_quote
Unfortunately we cannot make std::generator formattable because it is neither const-iterable nor copyable and std::format takes arguments by const&.
#+end_quote
#+begin_quote
This paper proposes solving the issue by making std::format and other formatting functions take arguments by forwarding references.
#+end_quote
tags: LWG, C++23, IS, B2 - improvement, size - medium, plenary-approved

**** [[https://wg21.link/p2508][P2508]] Exposing std::basic-format-string (Barry Revzin)
#+begin_quote
In 20.20.1 [format.syn], replace the exposition-only names basic-format-string, format-string, and wformat-string with the non-exposition-only names basic_format_string, format_string, and wformat_string.
#+end_quote
***** Example
#+begin_src c++
template <typename... Args>
void log(std::format_string<Args...> s, Args&&... args) {
    if (logging_enabled) {
        log_raw(std::format(s, std::forward<Args>(args)...));
    }
}
#+end_src
tags: LWG, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved

**** [[https://wg21.link/p2419][P2419]] Clarify handling of encodings in localized formatting of chrono types (Victor Zverovich)
#+begin_quote
C++20 added formatting of chrono types with std::format but left unspecified what happens during localized formatting when the locale and literal encodings do not match ([LWG3565]).
#+end_quote

***** Proposal
#+begin_quote
We propose clarifying the specification to prevent mojibake when possible by allowing implementation do transcoding or substituting the locale so that the result is in a consistent encoding.
#+end_quote
tags: LWG, C++23, tentatively-ready-for-plenary, IS, lwg-fullreview, B2 - improvement, size - tiny, plenary-approved

**** [[https://wg21.link/p2539][P2539]] Should the output of std::print to a terminal be synchronized with the underlying stream? (...
#+begin_quote
To prevent mojibake std::print may use a native Unicode API when writing to a terminal bypassing the stream buffer. During the review of [P2093] "Formatted output" Tim Song suggested that synchronizing std::print with the underlying stream may be beneficial for gradual adoption. This paper presents motivating examples, observes that this problem doesn’t normally happen in practice and proposes a minor update to the wording to provide a synchronization guarantee.
#+end_quote
tags: LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved

**** [[https://wg21.link/p2585][P2585]] Improving default container formatting (Barry Revzin)
#+begin_quote
[P2286R8] adds support for formatting any range whose underlying type is formattable. Additionally, it adds support for different kinds of formatting that users can opt into, while also providing a default choice for associating containers that is more suited to what those containers represent.
#+end_quote

#+begin_quote
However, this distinction is a result of [P2286R8] explicitly providing formatters for all the standard library map and set containers, and applying those changes to them. This is something that users can do for their own containers as well, but which also means that it is something users have to do - if this is the behavior they want.
#+end_quote

tags: LWG, C++23, tentatively-ready-for-plenary, IS, lwg-fullreview, B2 - improvement, size - medium, plenary-approved

** Constexpr
- 4 papers
**** [[https://wg21.link/p1328][P1328]] Making std::type_info::operator== constexpr (Peter Dimov)
#+begin_quote
This paper proposes std::type_info::operator== and operator!= be made constexpr, enabling practical, rather than theoretical, use of typeid in constant expressions.
#+end_quote
tags: LWG, C++23, IS, B3 - addition, size - tiny, plenary-approved


**** [[https://wg21.link/p2231][P2231]] Missing =constexpr= in =std::optional= and =std::variant= (Barry Revzin)
#+begin_quote
But even though the language provided the tools to make ~std::optional~ and ~std::variant~ completely ~constexpr~-able, there was no such update to the library. This paper seeks to remedy that omission by simply adding ~constexpr~ to all the relevant places.
#+end_quote
tags: LWG, C++23, IS, B2 - improvement, plenary-approved

**** [[https://wg21.link/p2273][P2273]] Making std::unique_ptr constexpr (Andreas Fertig)
#+begin_quote
std::unique_ptr is currently not constexpr friendly. With the loosening of requirements on
constexpr in [P0784R10] and the ability to use new and delete in a constexpr­context, we should
also provide a constexpr std::unique_ptr.
#+end_quote
***** Example
#+begin_src c++
constexpr auto fun() {
    auto p = std::make_unique<int>(4);
    return *p;
}
int main() {
    constexpr auto i = fun();
    static_assert(4 == i);
}
#+end_src

tags: LWG, C++23, B2 - improvement, plenary-approved, constexpr, expedited-library-evolution-electronic-poll

**** [[https://wg21.link/p2291][P2291]] Add Constexpr Modifiers to Functions =to_chars= and =from_chars= for Integral Types in =<charconv>= Header (Daniil Goncharov, Karaev Alexander)
#+begin_quote
There is currently no standard way to make conversion between numbers and strings /at compile time/.

~std::to_chars~ and ~std::from_chars~ are fundamental blocks for parsing and
formatting being localeindependent and non-throwing without memory allocation,
so they look like natural candidates for constexpr string conversions. The
paper proposes to make ~std::to_chars~ and ~std::from_chars~ functions for *integral
types* usable in constexpr context.
#+end_quote
tags: LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved, constexpr, expedited-library-evolution-electronic-poll

** Other Types and Utilities
35 papers

**** [[https://wg21.link/p0288][P0288]] any_invocable (Ryan McDougall, Matt Calabrese)
#+begin_quote
This paper proposes a conservative, move-only equivalent of std::function.
#+end_quote


tags: LWG, C++23, IS, large, plenary-approved


**** [[https://wg21.link/p0401r1][P0401R1]] Providing size feedback in the Allocator interface (Chris Kennelly, Jonathan Wakely)
LWG, C++23, size - small, plenary-approved
****** [[https://wg21.link/p0401][P0401]] Providing size feedback in the Allocator interface (Chris Kennelly, Jonathan Wakely)
#+begin_quote
Utilize size feedback from Allocator to reduce spurious reallocations
#+end_quote

tags: LWG, C++23, small, plenary-approved

**** [[https://wg21.link/p0448][P0448]] A strstream replacement using ~span<charT>~ as buffer (Peter Sommerlad)
#+begin_quote
This paper proposes a class template ~basic_spanbuf~ and the corresponding stream
class templates to enable the use of streams on externally provided memory
buffers. No ownership or re-allocation support is given. For those features we
have string-based streams
#+end_quote
******* Example
#+begin_src c++
char        input[] = "10 20 30";
ispanstream is{span<char>{input}};
int         i;
is >> i;
ASSERT_EQUAL(10, i);
is >> i;
ASSERT_EQUAL(20, i);
is >> i;
ASSERT_EQUAL(30, i);
is >> i;
ASSERT(!is);
#+end_src

tags: LWG, C++23, size - large, plenary-approved


**** [[https://wg21.link/p0627][P0627]] Function to mark unreachable code (Melissa Mears)
#+begin_quote
This proposal introduces a new standard library function, std::unreachable, for
marking locations in code execution as being known by the programmer to be
unreachable.
#+end_quote

******* Example
#+begin_src c++
[[noreturn]] void kill_self() {
    kill(getpid(), SIGKILL);
    std::unreachable();
}
#+end_src
tags: LWG, C++23, IS, B3 - addition, size - small, plenary-approved, expedited-library-evolution-electronic-poll


**** [[https://wg21.link/p1072][P1072]] basic_string::resize_default_init (Chris Kennelly, Mark Zeren)
#+begin_quote
Allow access to default initialized elements of basic_string.
#+end_quote
******* Example
#+begin_src c++
std::string GeneratePattern(const std::string& pattern, size_t count) {
    std::string ret;

    const auto step = pattern.size();
    // GOOD: No initialization
    ret.resize_default_init(step * count);
    for (size_t i = 0; i < count; i++) {
        // GOOD: No bookkeeping
        memcpy(ret.data() + i * step, pattern.data(), step);
    }

    return ret;
}
#+end_src
tags: LWG, C++23, IS, plenary-approved



**** [[https://wg21.link/p1413][P1413]] A safer interface for std::aligned_storage (CJ Johnson)
#+begin_quote
[] the standard library should provided two more symbols in the form of
typedefs that take in a single template type parameter and, on behalf of the
user, deduce the size and alignment of that type, passing in the values to
std::aligned_storage. The symbols should be ~std::aligned_storage_for~ and
~std::aligned_storage_for_t~. Like ~std::aligned_storage~ and
~std::aligned_storage_t~, they should be available in the ~<type_traits>~ header
of the standard library.
#+end_quote

tags: LWG, C++23, plenary-approved

**** [[https://wg21.link/p1425][P1425]] Iterators pair constructors for stack and queue (Corentin Jabot)
#+begin_quote
This paper proposes to add iterators-pair constructors to ~std::stack~ and ~std::queue~
#+end_quote
***** Example

| Before                                     | After                               |
|--------------------------------------------+-------------------------------------|
| ~std::vector<int> v(42);~                  | ~std::vector<int> v(42);~           |
| ~std::stack<int> s({v.begin(), v.end()});~ | ~std::stack s(v.begin(), v.end());~ |
| ~std::queue<int> q({v.begin(), v.end()});~ | ~std::queue q(v.begin(), v.end());~ |


tags: LWG, C++23, B2 - improvement, size - small, plenary-approved


**** [[https://wg21.link/p1518][P1518]] Stop overconstraining allocators in container deduction guides (Arthur O'Dwyer, Mike Spertus)
#+begin_quote
Discussion of flatmap’s deduction guides revealed that the deduction guides for sequence containers and container adaptors are needlessly overconstrained, making use cases such as pmr containers unnecessarily difficult.
#+end_quote

tags: LWG, C++23, IS, size - small, plenary-approved

**** [[https://wg21.link/p1951][P1951]] Default Arguments for pair's Forwarding Constructor (Logan R. Smith)
#+begin_quote
This paper proposes defaulting the template arguments U1 and U2 in pair's forwarding constructor to T1 and T2 respectively, so that braced initializers may be used as constructor arguments to it.
#+end_quote
#+begin_src c++
std::pair<std::string, std::vector<std::string>> p("hello", {});
#+end_src
tags: LWG, C++23, IS, plenary-approved

**** [[https://wg21.link/p2077][P2077]] Heterogeneous erasure overloads for associative containers (Konstantin Boyarinov, Sergey Vinogradov; Ruslan Arutyunyan)
#+begin_quote
The authors propose heterogeneous erasure overloads for ordered and unordered associative containers, which add an ability to erase values or extract nodes without creating a temporary key_type object.
#+end_quote
tags: LWG, C++23, IS, B2: Improvement, plenary-approved

**** [[https://wg21.link/p2136][P2136]] invoke<R> (Zhihao Yuan)
#+begin_quote
This paper proposes invoke_r, a variant of std::invoke that allows specifying the return type, realizing the semantics of INVOKE<R> rather than INVOKE.
#+end_quote
tags: LWG, C++23, IS, plenary-approved

**** [[https://wg21.link/p2166][P2166]] A Proposal to Prohibit std::basic_string and std::basic_string_view construction from nullptr (Yuriy Chernyshov)
#+begin_quote
the behavior of std::basic_string::basic_string(const CharT* s) constructor is undefined if [s, s + Traits::length(s)) is not a valid range (for example, if s is a null pointer)
#+end_quote
tags: LWG, C++23, IS, size - small, plenary-approved

**** [[https://wg21.link/p2251][P2251]] Require ~span~ & ~basic_string_view~ to be Trivially Copyable (Nevin Liber)
#+begin_quote
Given its definition, it is strongly implied that span & basic_string_view are
trivially copyable, but that is not yet a requirement.
#+end_quote

tags: LWG, C++23, IS, plenary-approved

**** [[https://wg21.link/p2255][P2255]] A type trait to detect reference binding to temporary (Tim Song)
#+begin_quote
This paper proposes adding two new type traits with compiler support to detect when the initialization of a reference would bind it to a lifetime-extended temporary, and changing several standard library components to make such binding ill-formed when it would inevitably produce a dangling reference.
#+end_quote
***** Before
#+begin_src c++
std::tuple<const std::string&>      x("hello");            // dangling
std::function<const std::string&()> f = [] { return ""; }; // OK

f(); // dangling
#+end_src
***** After
#+begin_src c++
std::tuple<const std::string&>      x("hello");            // ill-formed
std::function<const std::string&()> f = [] { return ""; }; // ill-formed
#+end_src
tags: LWG, C++23, IS, small, plenary-approved, expedited-library-evolution-electronic-poll

**** [[https://wg21.link/p2301][P2301]] Add a pmr alias for std::stacktrace (Steve Downey)
#+begin_quote
This paper proposes to add an alias in the pmr namespace defaulting the allocator used by the std::basic_stacktrace template to pmr::allocator. No changes to the api of std::stacktrace are necessary.
#+end_quote
***** Before
#+begin_src c++
char buffer[1024];

std::pmr::monotonic_buffer_resource pool{
    std::data(buffer), std::size(buffer)};

std::basic_stacktrace<
    std::pmr::polymorphic_allocator<std::stacktrace_entry>>
    trace{&pool};
#+end_src
***** After
#+begin_src c++
char buffer[1024];

std::pmr::monotonic_buffer_resource pool{
    std::data(buffer), std::size(buffer)};

std::pmr::stacktrace trace{&pool};
#+end_src

tags: LWG, C++23, tiny, plenary-approved

**** [[https://wg21.link/p2340][P2340]] Clarifying the status of the ‘C headers' (Thomas Köppe)
#+begin_quote
We propose to move the specification of “[depr.c.headers] C headers” from Annex D into the main document, and changing those headers’ status from “deprecated” to an explicitly discussed state “for foreign-language interoperability only”.
#+end_quote
tags: LWG, C++23, policy, IS, B2 - improvement, size - small, plenary-approved

**** [[https://wg21.link/p2393][P2393]] Cleaning up integer-class types (Tim Song)
#+begin_quote
This paper revamps the specification and use of integer-class types to resolve a number of issues, including [LWG3366], [LWG3376], and [LWG3575].
#+end_quote
tags: LWG, C++23, plenary-approved

**** [[https://wg21.link/p2401][P2401]] Add a conditional noexcept specification to std::exchange (Giuseppe D'Angelo)
#+begin_quote
We propose to add a noexcept-specification to std::exchange , which is currently lacking one.
#+end_quote
tags: LWG, C++23, IS, plenary-approved

**** [[https://wg21.link/p2438][P2438]] ~std::string::substr() &&~ (Federico Kircheis, Tomasz Kamiński)
#+begin_src c++
auto foo() -> std::string;

auto b = foo().substr(/* */);
#+end_src

Before:
#+begin_quote
foo() returns a temporary std::string. .substr creates a new string and copies the relevant content. At last, the temporary string returned by foo is released.
#+end_quote
After:
#+begin_quote
foo() returns a std::string. .substr implementation can reuse the storage of the string returned by foo and leave it in a valid but unspecified state. At last, the temporary string returned by foo() is released.
#+end_quote
tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, expedited-library-evolution-electronic-poll

**** [[https://wg21.link/p2445][P2445]] forward_like (Gašper Ažman)
#+begin_quote
Deducing This [P0847R7] is expected to land in C++23.
Its examples use a hypothetical ~std::forward_like<decltype(self)>(variable)~ facility because
~std::forward<decltype(v)>(v)~ is insufficient. This paper proposes ~std::forward_like~ to cater to
this scenario.
#+end_quote
***** Example
#+begin_src c++
auto callback = [m = get_message(), &scheduler](this auto&& self) -> bool {
    return scheduler.submit(std::forward_like<decltype(self)>(m));
};
callback();            // retry(callback)
std::move(callback)(); // try-or-fail(rvalue)
#+end_src

tags: LWG, C++23, tentatively-ready-for-plenary, IS, B3 - addition, size - small, plenary-approved


**** [[https://wg21.link/P2467][P2467]] Support exclusive mode for fstreams (Jonathan Wakely)
#+begin_quote
Historically, C++ iostreams libraries had a ~noreplace~ open mode that corresponded to the ~O_EXCL~ flag for POSIX ~open~. That mode was not included in the C++98 standard, presumably for portability reasons, because it wasn't in ISO C90.

Since then, ISO C added support for "exclusive" mode to ~fopen~, so now C++'s ~<fstream>~ is missing a feature that is present in both ISO C and POSIX. We should fix this for C++23.
#+end_quote
tags: LWG, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved, expedited-library-evolution-electronic-poll
**** [[https://wg21.link/p2588][P2588]] Relax std::barrier phase completion step guarantees (Gonzalo Brito Gadeschi, Eric Niebler, Anthony Williams, Thomas Rodgers)
#+begin_quote
Unintended consequences of ~std::barrier~ ’s specification constrain implementations to run the ~CompletionFunction~ on the last thread that arrives at the barrier during the phase. This prevents ~std::barrier~ from benefiting from hardware acceleration for thread synchronization. Removing these constraints is a _breaking change_. This paper aims to find a sweet spot for the barrier specification that delivers the functionality that applications need while allowing efficient implementations.
#+end_quote

tags: LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved

**** [[https://wg21.link/p2590][P2590]] Explicit lifetime management (Timur Doumler, Richard Smith)
#+begin_quote
This paper proposes a new standard library facility
~std::start_lifetime_as~. For objects of sufficiently trivial types, this
facility can be used to efficiently create objects and start their lifetime to
give programs defined behaviour, without running any constructor code. This
proposal completes the functionality proposed in [P0593R6] and adopted for
C++20 by providing the standard library portion of that paper (only the core
language portion of that paper made it into C++20).
#+end_quote

tags: CWG, LWG, C++23, tentatively-ready-for-plenary, lwg-fullreview, plenary-approved

**** [[https://wg21.link/p2614][P2614]] Deprecate numeric_limits::has_denorm (Matthias Kretz)
#+begin_quote
Since C is intent on obsoleting the ~*_HAS_SUBNORM~ macros, we should consider
the analogue change in C++: the deprecation of ~numeric_limits::has_denorm~. In
general, compile-time constants that describe floating-point behavior are
problematic, since behavior might change at runtime. Let’s also deprecate
~numeric_limits::has_denorm_loss~ while we’re at it.
#+end_quote
tags: LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved

**** [[https://wg21.link/p2655][P2655]] common_reference_t of reference_wrapper Should Be a Reference Type (Hui Xie, S. Levent Yilmaz)
#+begin_quote
This paper proposes a fix that makes the ~common_reference_t<T&,reference_wrapper<T>>~ a reference type ~T&~.
#+end_quote

***** Before
#+begin_src c++
static_assert(same_as<
              common_reference_t<int&, reference_wrapper<int>>,
              int>);

static_assert(same_as<
              common_reference_t<int&, reference_wrapper<int>&>,
              int>);

static_assert(same_as<
              common_reference_t<int&, const reference_wrapper<int>&>,
              const int&>);
#+end_src

***** After
#+begin_src c++
static_assert(same_as<
              common_reference_t<int&, reference_wrapper<int>>,
              int&>);

static_assert(same_as<
              common_reference_t<int&, reference_wrapper<int>&>,
              int&>);

static_assert(same_as<
              common_reference_t<int&, const reference_wrapper<int>&>,
              int&>);
#+end_src
tags: LWG, C++23, IS, B2 - improvement, size - small, plenary-approved

**** [[https://wg21.link/p2674][P2674]] A trait for implicit lifetime types (Timur Doumler, Vittorio Romeo)
#+begin_quote
C++20 introduced the notion of implicit-lifetime types. There are certain
operations that are only valid for such types. We therefore need a way to check
whether a type is implicit-lifetime, and constrain on this property. This paper
proposes a new type trait std::is_implicit_lifetime to achieve this.
#+end_quote


tags: LWG, C++23, tentatively-ready-for-plenary, IS, B3 - addition, size - small, plenary-approved

**** [[https://wg21.link/p1223][P1223]] find_backward (Zach Laine)
#+begin_quote
Consider how finding the last element that is equal to ‘x‘ in a range is typically done (for all the examples below, we assume a valid range of elements [first, last), and an iterator it within that range):
#+end_quote

#+begin_quote
Consider this instead:
~auto it = std::find_last(first, it, x);~
// Use it here...
That’s better! It’s a lot less verbose.
#+end_quote
tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, expedited-library-evolution-electronic-poll

**** [[https://wg21.link/p1264][P1264]] Revising the wording of stream input operations (Louis Dionne)
#+begin_quote
The wording in [istream], [istream.formatted] and [istream.unformatted] is very difficult to
follow when it comes to exceptions. Some requirements are specified more than once in different
locations, which makes it ambiguous how requirements should interact with each other.
#+end_quote
tags: LWG, C++23, IS, lwg-pending, B2 - improvement, size - medium, plenary-approved, lwg-wording-only


**** [[https://wg21.link/p1679][P1679]] String Contains function (Wim Leflere)
#+begin_quote
This paper proposes to add member function ~contains~ to class templates ~basic_string~ and ~basic_string_view~. This function checks, whether or not a string contains a given substring.
#+end_quote

tags: C++23, IS, size - small, plenary-approved

**** [[https://wg21.link/p1682][P1682]] std::to_underlying (JeanHeyd Meneide)
#+begin_quote
A proposal to add a short utility function to handle going from an enumeration to its underlying integral value for safety and ease of use.
#+end_quote
tags: C++23, IS, size - small, plenary-approved


**** [[https://wg21.link/p2212][P2212]] Relax Requirements for time_point::clock (Alexey Dmitriev, Howard Hinnant)
#+begin_quote
We propose to relax the requirements on the Clock template parameter of std::chrono::time_point.
#+end_quote

tags: C++23, IS, plenary-approved


**** [[https://wg21.link/p2417][P2417]] A more constexpr bitset (Daniil Goncharov)
#+begin_quote
constexpr bitset will allow to naturally use them as flags-mask in
constexpr/consteval functions. It's add, without limitations, new high-level
and more user-friendly class for bit mask in embedded developing.
#+end_quote

***** Proposal

#+begin_quote
Mark every member function except iostream operators. Make all of bitset::reference constexpr.
#+end_quote
tags: LWG, C++23, tentatively-ready-for-plenary, IS, B3 - addition, size - medium, plenary-approved, constexpr, expedited-library-evolut...

**** [[https://wg21.link/p2505][P2505]] Monadic Functions for std::expected (Jeff Garland)
#+begin_quote
With the final plenary vote of P0798 Monadic Functions for std::optional complete, we now have an design inconsistency with std::expected. P0323 std::expected has now also been voted into the working draft for C++23. This proposal corrects the inconsistency by adding 4 functions to std::expected and is targeted at C++23. The author believes this should be treated as a consistency/bug fix still in scope for C++23.
#+end_quote

***** Proposal
The following 3 functions are added to std::optional, but are currently not part of std::expected.

- ~and_then~ :: compose a chain of functions returning an expected
- ~or_else~ :: returns if it has a value, otherwise it calls a function with the error type
- ~transform~ :: apply a function to change the value (and possibly the type)

After feedback, this draft also proposes the addition of two additional functions for expected to facilitate additional cases:

- ~transform_error~ :: apply a function to change the value, otherwise call a function with error type
- ~error_or~ :: a value to return when there is not an error
tags: LWG, C++23, IS, lwg-fullreview, B2 - improvement, size - small, plenary-approved

**** [[https://wg21.link/p2517][P2517]] Add a conditional noexcept specification to std::apply (Hewill Kang)
#+begin_quote
This paper proposes to add a noexcept-specification to ~std::apply~.
#+end_quote

#+begin_quote
~invoke(f, args...)~ should be completely equivalent to ~apply(f,
forward_as_tuple(args...))~, adding ~noexcept~ to ~apply~ can easily achieve
this and make it more consistent with ~invoke~.
#+end_quote

tags: LWG, C++23, tentatively-ready-for-plenary, IS, lwg-fullreview, plenary-approved

**** [[https://wg21.link/p2549][P2549]] std::unexpected should have error() as member accessor (Yihe Li)

***** Before change:

#+begin_src c++
void fun()
{
    using namespace std::literals;
    using ET = std::expected<int, std::string>;
    auto unex = std::unexpected("Oops"s);
    auto wrapped = unex.value(); // okay, get "Oops"
    auto ex = ET(unex); // implicit, can also happen in parameter passing, etc.
    auto wrapped2 = ex.value(); // throws!
}
#+end_src

***** After change:
#+begin_src c++
void fun()
{
    using namespace std::literals;
    using ET = std::expected<int, std::string>;
    auto unex = std::unexpected("Oops"s);
    auto wrapped = unex.error(); // okay, get "Oops"
    auto ex = ET(unex); // implicit, can also happen in parameter passing, etc.
    auto wrapped2 = ex.error(); // okay, get "Oops" too.
}
#+end_src

tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved
