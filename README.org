#+options: ':nil *:t -:t ::t <:t H:2 \n:nil ^:nil arch:headline author:nil
#+options: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:nil e:t
#+options: email:nil f:t inline:t num:2 p:nil pri:nil prop:nil stat:t tags:t
#+options: tasks:t tex:t timestamp:nil title:nil toc:2 todo:t |:t
#+options: html-link-use-abs-url:nil html-postamble:nil html-preamble:t
#+options: html-scripts:t html-style:t html5-fancy:nil tex:t
#+options: reveal_width:1600 reveal_height:900
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+latex_class: article
#+latex_class_options: 
#+latex_header: 
#+latex_header_extra: 
#+keywords: 
#+description: 
#+subtitle: 
#+latex_compiler: pdflatex
#+startup: showeverything
#+html_doctype: xhtml-strict
#+html_container: div
#+description: 
#+keywords: 
#+html_link_home: 
#+html_link_up: 
#+html_mathjax: 
#+html_head: 
#+html_head_extra: 
#+subtitle: 
#+infojs_opt: 

#+reveal_trans: fade
#+html_head: <link rel="stylesheet" type="text/css" href="./vivendi-tinted.css" />

#+reveal_mathjax_url: https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML
#+reveal_extra_css: ./vivendi-tinted.css
#+reveal_theme: ./my_theme.css
#+reveal_extra_css: ./footer.css
#+reveal_title_slide_background: 

#+reveal_root: https://cdn.jsdelivr.net/npm/reveal.js
#+reveal_version: 4

#+reveal_hlevel: 2
#+reveal_export_notes_to_pdf: separate-page


* C++ 23 Features


** [[https://wg21.link/p0009][P0009]] mdspan: A Non-Owning Multidimensional Array Reference (H. Carter Edwards, Bryce Adelstein
LWG, C++23, linear-algebra, tentatively-ready-for-plenary, IS, size - large, plenary-approved, mdspan

** [[https://wg21.link/p0288][P0288]] any_invocable (Ryan McDougall, Matt Calabrese)
#+begin_quote
This paper proposes a conservative, move-only equivalent of std::function.
#+end_quote


LWG, C++23, IS, large, plenary-approved

** [[https://wg21.link/p0323][P0323]] std::expected (Vicente Botet, JF Bastien)...
LWG, C++23, IS, B3 - addition, size - large, plenary-approved

** [[https://wg21.link/p0330][P0330]] Literal Suffixes for ptrdiff_t and size_t (JeanHeyd Meneide, Rein Halbersma)
#+begin_quote
This paper proposes core language suffixes for size_t and its associated signed type.
#+end_quote

***** Before
#+begin_src c++
std::vector<int> v{0, 1, 2, 3};
for (auto i = 0u, s = v.size(); i < s; ++i) {
	/* use both i and v[i] */
}
‚ö†Ô∏è - Compiles on 32-bit, truncates (maybe with warnings) on 64-bit
std::vector<int> v{0, 1, 2, 3};
for (auto i = 0, s = v.size(); i < s; ++i) {
	/* use both i and v[i] */
}
‚ùå - Compilation error
#+end_src
***** After
#+begin_src c++
std::vector<int> v{0, 1, 2, 3};
for (auto i = 0uz, s = v.size(); i < s; ++i) {
	/* use both i and v[i] */
}
#+end_src
LWG, C++23, tiny, plenary-approved


C++23, plenary-approved

** [[https://wg21.link/p0401r1][P0401R1]] Providing size feedback in the Allocator interface (Chris Kennelly, Jonathan Wakely)
LWG, C++23, size - small, plenary-approved
**** [[https://wg21.link/p0401][P0401]] Providing size feedback in the Allocator interface (Chris Kennelly, Jonathan Wakely)
#+begin_quote
Utilize size feedback from Allocator to reduce spurious reallocations
#+end_quote

LWG, C++23, small, plenary-approved

18 papers

** [[https://wg21.link/p0429][P0429]] A Standard flatmap (Zach Laine)...
LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved

** [[https://wg21.link/p0448][P0448]] A strstream replacement using span<charT> as buffer (Peter Sommerlad)
#+begin_quote
This paper proposes a class template basic_spanbuf and the corresponding stream
class templates to enable the use of streams on externally provided memory
buffers. No ownership or re-allocation support is given. For those features we
have string-based streams
#+end_quote
***** Example
#+begin_src c++
char        input[] = "10 20 30";
ispanstream is{span<char>{input}};
int         i;
is >> i;
ASSERT_EQUAL(10, i);
is >> i;
ASSERT_EQUAL(20, i);
is >> i;
ASSERT_EQUAL(30, i);
is >> i;
ASSERT(!is);
#+end_src

LWG, C++23, size - large, plenary-approved

** [[https://wg21.link/p0533][P0533]] constexpr for <cmath> and <cstdlib> (Edward J. Rosten, Oliver J. Rosten)
#+begin_quote
We propose simple criteria for selecting functions in <cmath> which should be
declared constexpr.  There is a small degree of overlap with <cstdlib>. The aim
is to transparently select a sufficiently large portion of <cmath> in order to
be useful but without placing too much burden on compiler vendors.
#+end_quote

*** Example
#+begin_src c++
constexpr int foo(float x) {
int a{}; int* pa{&a};
std::frexpr(x, pa);
return a;
}

constexpr int i{foo(0.5f)}.
#+end_src

CWG, LWG, C++23, IS, B3 - addition, size - medium, plenary-approved, constexpr

** [[https://wg21.link/p0627][P0627]] Function to mark unreachable code (Melissa Mears)
#+begin_quote
This proposal introduces a new standard library function, std::unreachable, for
marking locations in code execution as being known by the programmer to be
unreachable.
#+end_quote

***** Example
#+begin_src c++
[[noreturn]] void kill_self() {
    kill(getpid(), SIGKILL);
    std::unreachable();
}
#+end_src
LWG, C++23, IS, B3 - addition, size - small, plenary-approved, expedited-library-evolution-electronic-poll

** [[https://wg21.link/p0798][P0798]] Monadic operations for std::optional (Sy Brand)
#+begin_quote
std::optional will be a very important vocabulary type in C++17 and up. Some uses of it can be very verbose and would benefit from operations which allow functional composition. I propose adding map, and_then, and or_else member functions to std::optional to support this monadic style of programming.
#+end_quote
*** Example
#+begin_src c++
std::optional<image> get_cute_cat(const image& img) {
    return crop_to_cat(img)
        .and_then(add_bow_tie)
        .and_then(make_eyes_sparkle)
        .map(make_smaller)
        .map(add_rainbow);
}
#+end_src
*** Quote
#+begin_quote
Here is a list of programming languages which have a optional-like type without a monadic interface or syntactic sugar:

- C++

- I couldn‚Äôt find any others
#+end_quote
*** Monadic interface
- map :: ~map~ applies a function to the value stored in the optional and returns the result wrapped in an optional. If there is no stored value, then it returns an empty optional.
- and_then :: ~and_then~ is like map, but it is used on functions which may not return a value.
- or_else :: ~or_else~ returns the optional if it has a value, otherwise it calls a given function. This allows you do things like logging or throwing exceptions in monadic contexts:


LWG, SG14, C++23, IS, size - small, plenary-approved

** [[https://wg21.link/p0847][P0847]] Deducing this (Ga≈°per A≈æman, Sy Brand, Ben Deane, Barry Revzin)
#+begin_quote
We propose a new mechanism for specifying or deducing the value category of an instance of a class ‚Äî in other words, a way to tell from within a member function whether the object it‚Äôs invoked on is an lvalue or an rvalue; whether it is const or volatile; and the object‚Äôs type.
#+end_quote

#+begin_quote
A non-static member function can be declared to take as its first parameter an explicit object parameter, denoted with the prefixed keyword this. Once we elevate the object parameter to a proper function parameter, it can be deduced following normal function template deduction rules:
#+end_quote

*** Example
#+begin_src c++
struct X {
    void foo(this X const& self, int i);

    template <typename Self>
    void bar(this Self&& self);
};

struct D : X {};

void ex(X& x, D const& d) {
    x.foo(42);     // 'self' is bound to 'x', 'i' is 42
    x.bar();       // deduces Self as X&, calls X::bar<X&>
    move(x).bar(); // deduces Self as X, calls X::bar<X>

    d.foo(17); // 'self' is bound to 'd'
    d.bar();   // deduces Self as D const&, calls X::bar<D const&>
}
#+end_src

*** Example
#+begin_src c++
vector captured = {1, 2, 3, 4};
[captured](this auto&& self) -> decltype(auto) {
  return forward_like<decltype(self)>(captured);
}

[captured]<class Self>(this Self&& self) -> decltype(auto) {
  return forward_like<Self>(captured);
}
#+end_src


CWG, C++23, plenary-approved

** [[https://wg21.link/p0943][P0943]] Support C atomics in C++ (Hans-J. Boehm)
C++23, IS, B2 - improvement, size - small, plenary-approved

** [[https://wg21.link/p1048][P1048]] A proposal for a type trait to detect scoped enumerations (Juan Alday)
C++23, IS, B3 - addition, size - small, plenary-approved

** [[https://wg21.link/p1072][P1072]] basic_string::resize_default_init (Chris Kennelly, Mark Zeren)
#+begin_quote
Allow access to default initialized elements of basic_string.
#+end_quote
***** Example
#+begin_src c++
std::string GeneratePattern(const std::string& pattern, size_t count) {
    std::string ret;

    const auto step = pattern.size();
    // GOOD: No initialization
    ret.resize_default_init(step * count);
    for (size_t i = 0; i < count; i++) {
        // GOOD: No bookkeeping
        memcpy(ret.data() + i * step, pattern.data(), step);
    }

    return ret;
}
#+end_src
LWG, C++23, IS, plenary-approved

** [[https://wg21.link/p1102][P1102]] Down with ()! (Alex Christensen, JF Bastien)
C++23, IS, plenary-approved

** [[https://wg21.link/p1132][P1132]] out_ptr - a scalable output pointer abstraction (JeanHeyd Meneide, Todor Buyukliev, Isabella Muerte)
#+begin_quote
out_ptr is an abstraction to bring both C APIs and smart pointers back into the promised land by creating a temporary pointer-to-pointer that updates the smart pointer when it destructs.
#+end_quote
***** Example
#+begin_src c++
error_num c_api_create_handle(int seed_value, int** p_handle);
void      c_api_delete_handle(int* handle);

struct resource_deleter {
    void operator()(int* handle) { c_api_delete_handle(handle); }
};

std::unique_ptr<int, resource_deleter> resource(nullptr);
error_num err = c_api_create_handle(24, std::out_ptr(resource));
if (err == C_API_ERROR_CONDITION) {
    // handle errors
}
// resource.get() the out-value from the C API function
#+end_src
LWG, C++23, IS, plenary-approved

** [[https://wg21.link/p1147][P1147]] Printing =volatile= Pointers (Bryce Adelstein Lelbach)
#+begin_quote
Printing pointers to volatile types with standard library output streams has unexpected results. Consider the following code:
#+end_quote
*** Example
#+begin_src c++
#include <iostream>

int main() {
    int*          p0 = reinterpret_cast<int*>(0xdeadbeef);
    volatile int* p1 = reinterpret_cast<volatile int*>(0xdeadbeef);

    std::cout << p0 << std::endl;
    std::cout << p1 << std::endl;
}
#+end_src
#+begin_quote
This produces the following output:

#+begin_example
0xdeadbeef
#+end_example

1
#+end_quote
LWG, C++23, IS, plenary-approved

** [[https://wg21.link/p1169][P1169]] static operator() (Barry Revzin, Casey Carter)
CWG, LWG, straw-poll, C++23, tentatively-ready-for-plenary, IS, B3 - addition, size - medium, plenary-approved, expedited-library-...

** [[https://wg21.link/p1206][P1206]] ranges::to: A function to convert any range to a container (Corentin Jabot, Eric Niebler, Casey Carter)
#+begin_quote
We propose a function to copy or materialize any range (containers and views alike) to a container.
#+end_quote
*** Before/After Table
Before:
#+begin_src c++
std::map<int, widget>                           map = get_widgets_map();
std::vector<typename decltype(map)::value_type> vec;
vec.reserve(map.size());
ranges::move(map, std::back_inserter(vec));
#+end_src
After:
#+begin_src c++
auto vec = get_widgets_map() | ranges::to<vector>
#+end_src
LWG, ranges, C++23, IS, plenary-approved

** [[https://wg21.link/p1222][P1222]] A Standard flatset (Zach Laine)
LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved

** [[https://wg21.link/p1223][P1223]] find_backward (Zach Laine)
LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, expedited-library-evolution-electronic-poll

** [[https://wg21.link/p1264][P1264]] Revising the wording of stream input operations (Louis Dionne)...
LWG, C++23, IS, lwg-pending, B2 - improvement, size - medium, plenary-approved, lwg-wording-only

** [[https://wg21.link/p1272][P1272]] Byteswapping for fun&&nuf (Isabella Muerte)
#+begin_src c++
namespace std {
    template <class IntegerType>
    constexpr IntegerType byteswap (IntegerType value) noexcept;
}
// Where std::is_integral_v<IntegerType> is true.
#+end_src
CWG, LWG, C++23, plenary-approved

** [[https://wg21.link/p1328][P1328]] Making std::type_info::operator== constexpr (Peter Dimov)
#+begin_quote
This paper proposes std::type_info::operator== and operator!= be made constexpr, enabling practical, rather than theoretical, use of typeid in constant expressions.
#+end_quote
LWG, C++23, IS, B3 - addition, size - tiny, plenary-approved

** [[https://wg21.link/p1401][P1401]] Narrowing contextual conversions to bool (Andrzej Krzemienski)
#+begin_quote
This paper proposes to allow narrowing conversions in *contextually converted constant expressions of type `bool`*.
#+end_quote

| Today                                     | If accepted                         |
|-------------------------------------------+-------------------------------------|
| ~if constexpr(bool(flags & Flags::Exec))~ | ~if constexpr(flags & Flags::Exec)~ |
| ~if constexpr(flags & Flags::Exec != 0)~  | ~if constexpr(flags & Flags::Exec)~ |
| ~static_assert(N % 4 != 0);~              | ~static_assert(N % 4);~             |
| ~static_assert(bool(N));~                 | ~static_assert(N);~                 |

CWG, C++23, plenary-approved

** [[https://wg21.link/p1413][P1413]] A safer interface for std::aligned_storage (CJ Johnson)
#+begin_quote
[] the standard library should provided two more symbols in the form of
typedefs that take in a single template type parameter and, on behalf of the
user, deduce the size and alignment of that type, passing in the values to
std::aligned_storage. The symbols should be ~std::aligned_storage_for~ and
~std::aligned_storage_for_t~. Like ~std::aligned_storage~ and
~std::aligned_storage_t~, they should be available in the ~<type_traits>~ header
of the standard library.
#+end_quote

LWG, C++23, plenary-approved

** [[https://wg21.link/p1425][P1425]] Iterators pair constructors for stack and queue (Corentin Jabot)
#+begin_quote
This paper proposes to add iterators-pair constructors to ~std::stack~ and ~std::queue~
#+end_quote
*** Example

| Before                                     | After                               |
|--------------------------------------------+-------------------------------------|
| ~std::vector<int> v(42);~                  | ~std::vector<int> v(42);~           |
| ~std::stack<int> s({v.begin(), v.end()});~ | ~std::stack s(v.begin(), v.end());~ |
| ~std::queue<int> q({v.begin(), v.end()});~ | ~std::queue q(v.begin(), v.end());~ |


LWG, C++23, B2 - improvement, size - small, plenary-approved

** [[https://wg21.link/p1467][P1467]] Extended floating-point types (Micha≈Ç Dominiak, David Olsen)
#+begin_quote
This paper introduces the notion of _extended floating-point types_, modeled
after extended integer types. To accomodate them, this paper also attempts to
rewrite the current rules for floating-point types, to enable well-defined
interactions between all the floating-point types. The end goal of this paper,
together with [P1468], is to have a language to enable ~<cstdint>~-like aliases
for implementation specific floating point types, that can model more binary
layouts than just a single fundamental type (the previously proposed short
float) can provide for
#+end_quote
CWG, LWG, straw-poll, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved

** [[https://wg21.link/p1518][P1518]] Stop overconstraining allocators in container deduction guides (Arthur O'Dwyer, Mike Spertus)
#+begin_quote
Discussion of flatmap‚Äôs deduction guides revealed that the deduction guides for sequence containers and container adaptors are needlessly overconstrained, making use cases such as pmr containers unnecessarily difficult.
#+end_quote

LWG, C++23, IS, size - small, plenary-approved

** [[https://wg21.link/p1642][P1642]] Freestanding Library: Easy [utilities] (Ben Craig)
CWG, LWG, SG14, C++23, tentatively-ready-for-plenary, freestanding, IS, B2 - improvement, size - medium, plenary-approved

** [[https://wg21.link/p1659][P1659]] starts_with and ends_with (Christopher Di Bella)
#+begin_quote
This proposal seeks to add std::ranges::starts_with and std::ranges::ends_with, which would work on arbitrary ranges, and also answer questions such as "are the starting elements of `r1` less than the elements of `r2`?" and "are the final elements of `r1` greater than the elements of `r2`?"
#+end_quote
*** Before/After Table
Before:
#+begin_src c++
auto some_ints      = view::iota(0, 50);
auto some_more_ints = view::iota(0, 30);
if (ranges::mismatch(some_ints, some_more_ints).in2 == end(some_more_ints)) {
    // do something
}
#+end_src
After:
#+begin_src c++
auto some_ints      = view::iota(0, 50);
auto some_more_ints = view::iota(0, 30);
if (ranges::starts_with(some_ints, some_more_ints)) {
    // do something
}
#+end_src

LWG, C++23, IS, size - small, plenary-approved

** [[https://wg21.link/p1675][P1675]] rethrow_exception must be allowed to copy (Billy O'Neal)
#+begin_quote
The ~current_exception~ wording was carefully written to allow both ABIs like
MSVC++‚Äôs where the exception objects are generally constructed on the stack,
and ABIs like the Itanium C++ ABI where the exception objects are generally
constructed on the heap (and possibly reference counted).  Implementations are
given the freedom they need to (possibly) copy the exception object into the
memory held by the exception_ptr, and similar. See
http://eel.is/c++draft/propagation#8.

Unfortunately, such care was not taken for ~rethrow_exception~.
#+end_quote

CWG, LWG, C++23, B2 - improvement, size - small, plenary-approved

** [[https://wg21.link/p1679][P1679]] String Contains function (Wim Leflere)
C++23, IS, size - small, plenary-approved

** [[https://wg21.link/p1682][P1682]] std::to_underlying (JeanHeyd Meneide)
C++23, IS, size - small, plenary-approved

** [[https://wg21.link/p1774][P1774]] Portable optimisation hints (Timur Doumler)
#+begin_quote
We propose a standard facility providing the semantics of existing compiler intrinsics such as
~__builtin_assume~ (Clang) and ~__assume~ (MSVC, Intel) that tell the compiler to assume a
given C++ expression without evaluating it, and to optimise based on this assumption. This is
very useful for high-performance and low-latency applications in order to generate both faster
and smaller code.
#+end_quote

CWG, straw-poll, C++23, plenary-approved

** [[https://wg21.link/p1787][P1787]] Declarations and where to find them (S. Davis Herring)
modules, C++23, IS, plenary-approved

** [[https://wg21.link/p1847][P1847]] Make declaration order layout mandated (Pal Balog)
#+begin_quote
The current rules allow implementations freedom to reorder members in the layout if they have different
access control. To our knowledge no implementation actually used that freedom. We propose to fix this
established industry practice in the standard as mandatory.
#+end_quote
CWG, C++23, plenary-approved

** [[https://wg21.link/p1899][P1899]] stride_view (Christopher Di Bella)
LWG, ranges, C++23, tentatively-ready-for-plenary, IS, plenary-approved, expedited-library-evolution-electronic-poll

** [[https://wg21.link/p1938][P1938]] if consteval (Barry Revzin, Daveed Vandevoorde, Richard Smith)
#+begin_quote
We propose a new form of if statement which is spelled:

~if consteval { }~
#+end_quote
*** Example
#+begin_src c++
consteval int f(int i) { return i; }

constexpr int g(int i) {
    if consteval {
        return f(i) + 1; // ok: immediate function context
    } else {
        return 42;
    }
}

consteval int h(int i) {
    return f(i) + 1; // ok: immediate function context
}
#+end_src
CWG, LWG, C++23, plenary-approved

** [[https://wg21.link/p1949][P1949]] C++ Identifier Syntax using Unicode Standard Annex 31 (Steve Downey)
#+begin_quote
Adopt Unicode Annex 31 as part of C++ 23.

- That C++ identifiers match the pattern (XID_Start + _ ) + XID_Continue*.
- That portable source is required to be normalized as NFC.
- That using unassigned code points be ill-formed.

In addition adopt this proposal as a Defect Report against C++ 20 and earlier.
#+end_quote
*** Examples
#+begin_src c++
bool üë∑ = true; //  Construction Worker
bool üë∑‚Äç‚ôÄ = false; // Woman Construction Worker ({Construction Worker}{ZWJ}{Female Sign})
int ‚è∞ = 0; //not valid
int üïê = 0;

int ‚ò† = 0; //not valid
int üíÄ = 0;

int ‚úã = 0; //not valid
int üëä = 0;

int ‚úà = 0; //not valid
int üöÄ = 0;

int ‚òπ = 0; //not valid
int üòÄ = 0;
#+end_src

All Invalid After p1949

CWG, C++23, plenary-approved

** [[https://wg21.link/p1951][P1951]] Default Arguments for pair's Forwarding Constructor (Logan R. Smith)
#+begin_quote
This paper proposes defaulting the template arguments U1 and U2 in pair's forwarding constructor to T1 and T2 respectively, so that braced initializers may be used as constructor arguments to it.
#+end_quote
#+begin_src c++
std::pair<std::string, std::vector<std::string>> p("hello", {});
#+end_src
LWG, C++23, IS, plenary-approved

** [[https://wg21.link/p1989][P1989]] Range constructor for std::string_view 2: Constrain Harder (Corentin Jabot)
#+begin_src c++
template<class R>
basic_string_view(R&&)
-> basic_string_view<ranges::range_value_t<R>>;
#+end_src
LWG, ranges, C++23, plenary-approved

** [[https://wg21.link/p2017][P2017]] Conditionally safe ranges (Barry Revzin)
ranges, C++23, IS, size - small, plenary-approved

** [[https://wg21.link/p2029][P2029]] Proposed resolution for core issues 411, 1656, and 2333; escapes in character and string li...
C++23, IS, plenary-approved

** [[https://wg21.link/p2036][P2036]] Changing scope for lambda trailing-return-type (Barry Revzin)
#+begin_quote
This paper proposes that name lookup in the trailing-return-type of a lambda
first consider that lambda‚Äôs captures before looking further outward. We may
not know at the time of parsing the return type which names actually are
captured, so this paper proposes to treat all capturable entities as if they
were captured.
#+end_quote
CWG, C++23, plenary-approved

** [[https://wg21.link/p2071][P2071]] Named universal character escapes (Tom Honermann, R. Martinho Fernandes, Peter Bindels, Corentin Jabot, Steve Downey)
#+begin_quote
A proposal to extend universal character names from hexadecimal sequences to include the official names and formal aliases of Unicode codepoints.
#+end_quote
*** Before/After Table
**** Before:
#+begin_src c++
// UTF-32 character literal with U+0100 {LATIN CAPITAL LETTER A WITH MACRON}
U'\u0100'
// UTF-8 string literal with U+0100 {LATIN CAPITAL LETTER A WITH MACRON} U+0300 {COMBINING GRAVE ACCENT}
u8"\u0100\u0300"
#+end_src
**** After:
#+begin_src c++
U'\N{LATIN CAPITAL LETTER A WITH MACRON}' // Equivalent to U'\u0100'
u8"\N{LATIN CAPITAL LETTER A WITH MACRON}\N{COMBINING GRAVE ACCENT}" // Equivalent to u8"\u0100\u0300"
#+end_src

CWG, straw-poll, C++23, plenary-approved

** [[https://wg21.link/p2077][P2077]] Heterogeneous erasure overloads for associative containers (Konstantin Boyarinov, Sergey Vinogradov; Ruslan Arutyunyan)
#+begin_quote
The authors propose heterogeneous erasure overloads for ordered and unordered associative containers, which add an ability to erase values or extract nodes without creating a temporary key_type object.
#+end_quote
LWG, C++23, IS, B2: Improvement, plenary-approved

** [[https://wg21.link/p2093][P2093]] Formatted output (Victor Zverovich)
#+begin_quote


A new I/O-agnostic text formatting library was introduced in C++20 ([FORMAT]). This paper proposes integrating it with standard I/O facilities via a simple and intuitive API achieving the following goals:

- Usability

- Unicode support

- Good performance

- Small binary footprint
#+end_quote
*** Before/After Table
**** Before:
#+begin_src c++
std::cout << std::format("Hello, {}!", name);
#+end_src
**** After:
#+begin_src c++
std::print("Hello, {}!", name);
#+end_src
LWG, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved

** [[https://wg21.link/p2096][P2096]] Generalized wording for partial specializations (James Touton)...
C++23, IS, plenary-approved

** [[https://wg21.link/p2128][P2128]] Multidimensional subscript operator (Corentin Jabot, Isabella Muerte, Daisy Hollman, Christian Trott, Mark Hoemmen)
#+begin_quote
We propose that user-defined types can define a subscript operator with multiple arguments
to better support multi-dimensional containers and views.
#+end_quote
*** Before
#+begin_src c++
template <class ElementType, class Extents>
class mdspan {
    template <class... IndexType>
    constexpr reference operator()(IndexType...);
};
int main() {
    int  buffer[2 * 3 * 4] = {};
    auto s                 = mdspan<int, extents<2, 3, 4>>(buffer);
    s(1, 1, 1)             = 42;
}
#+end_src
*** After
#+begin_src c++
template <class ElementType, class Extents>
 class mdspan {
    template <class... IndexType>
    constexpr reference operator[](IndexType...);
};
int main() {
    int  buffer[2 * 3 * 4] = {};
    auto s                 = mdspan<int, extents<2, 3, 4>>(buffer);
    s[1, 1, 1]             = 42;
}
#+end_src
CWG, C++23, plenary-approved

** [[https://wg21.link/p2136][P2136]] invoke<R> (Zhihao Yuan)
#+begin_quote
This paper proposes invoke_r, a variant of std::invoke that allows specifying the return type, realizing the semantics of INVOKE<R> rather than INVOKE.
#+end_quote
LWG, C++23, IS, plenary-approved

** [[https://wg21.link/p2156][P2156]] Allow Duplicate Attributes (Erich Keane)
#+begin_quote
The standard attributes noreturn, carries dependency, and deprecated all
specify that they cannot appear more than once in an attribute-list, but there
is no such prohibition if they appear in separate attribute-specifiers within a
single attributespecifier-seq. Since intuitively these cases are equivalent,
they should be treated the same, accepting duplicates in both or neither.
#+end_quote
CWG, C++23, plenary-approved

** [[https://wg21.link/p2160][P2160]] Locks lock lockables (wording for LWG 2363) (Tim Song)
C++23, IS, size - medium, plenary-approved

** [[https://wg21.link/p2162][P2162]] Inheriting from std::variant (resolving LWG3052) (Barry Revzin)
C++23, IS, size - small, plenary-approved

** [[https://wg21.link/p2164][P2164]] views::enumerate (Corentin Jabot)
LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B3 - addition, size - medium, plenary-approved

** [[https://wg21.link/p2165][P2165]] Comparing pair and tuples (Corentin Jabot)
LWG, ranges, C++23, tentatively-ready-for-plenary, IS, lwg-fullreview, B2 - improvement, size - medium, plenary-approved

** [[https://wg21.link/p2166][P2166]] A Proposal to Prohibit std::basic_string and std::basic_string_view construction from nullptr (Yuriy Chernyshov)
#+begin_quote
the behavior of std::basic_string::basic_string(const CharT* s) constructor is undefined if [s, s + Traits::length(s)) is not a valid range (for example, if s is a null pointer)
#+end_quote
LWG, C++23, IS, size - small, plenary-approved

** [[https://wg21.link/p2167][P2167]] Improved Proposed Wording for LWG 2114 (Daniel Kr√ºgler)
LWG, C++23, tentatively-ready-for-plenary, B2 - improvement, size - small, plenary-approved, lwg-wording-only

** [[https://wg21.link/p2173][P2173]] Attributes on Lambda-Expressions (Daveed Vandevoorde, Inbal Levi, Ville Voutilainen)
#+begin_quote
This paper proposes a fix for
[[http://open-std.org/JTC1/SC22/WG21/docs/cwg_toc.html#2097][Core Issue 2097]],
to allow attributes for lambdas, those attributes appertaining to the function
call operator of the lambda.
#+end_quote
#+begin_src c++
auto lm = [] [[nodiscard, vendor::attr]] () -> int { return 42; };
#+end_src
CWG, straw-poll, C++23, plenary-approved

** [[https://wg21.link/p2186][P2186]] Removing Garbage Collection Support (JF Bastien, Alisdair Meredith)
#+begin_quote
We propose removing (not deprecating) C++'s Garbage Collection support. Specifically, these five library functions:
- declare_reachable
- undeclare_reachable
- declare_no_pointers
- undeclare_no_pointers
- get_pointer_safety

As well as the pointer_safety enum, the \_\_STDCPP_STRICT_POINTER_SAFETY\_\_ macro, and the Core Language wording.
#+end_quote
CWG, LWG, C++23, IS, plenary-approved

** [[https://wg21.link/p2201][P2201]] Mixed string literal concatenation (Jens Maurer)
#+begin_quote
String concatenation involving string-literals with encoding-prefixes mixing L"", u8"", u"", and U"" is currently conditionally-supported with implementation-defined behavior.
[...]
No meaningful use-case for such mixed concatenations is known.

This paper makes such mixed concatenations ill-formed.
#+end_quote
CWG, C++23, plenary-approved

** [[https://wg21.link/p2210][P2210]] Superior String Splitting (Barry Revzin)
*** Proposal Part 1
#+begin_quote
This paper proposes the following:
Rename the existing ~views::split~ / ~ranges::split_view~ to ~views::lazy_split~ / ~ranges::lazy_split_view~. Add ~base()~ member functions to the ~inner-iterator~ type to get back to the adapted range‚Äôs iterators.
#+end_quote

*** Proposal Part 2
#+begin_quote
1. Introduce a new range adapter under the name ~views::split~ / ~ranges::split_view~ with the following design:

   1. It can only support splitting forward-or-better ranges.
   2. Splitting a ~V~ will yield ~subrange<iterator_t<V>>~s, ensuring that the adapted range‚Äôs category is preserved. Splitting a bidirectional range gives out bidirectional subranges. Spltiting a contiguous range gives out contiguous subranges.
   3. ~views::split~ will not be ~const~-iterable.
#+end_quote
*** Example
#+begin_src c++
auto ip = "127.0.0.1"s;
auto parts = ip | std::views::split('.')
                | std::views::transform([](std::span<char const> s){
                      int i;
                      std::from_chars(s.data(), s.data() + s.size(), i);
                      return i;
                  });
#+end_src
LWG, ranges, C++23, IS, B2 - improvement, plenary-approved

** [[https://wg21.link/p2212][P2212]] Relax Requirements for time_point::clock (Alexey Dmitriev, Howard Hinnant)
C++23, IS, plenary-approved

** [[https://wg21.link/p2216][P2216]] std::format improvements (Victor Zverovich)
#+begin_quote
This paper proposes the following improvements to the C++20 formatting facility:
- Improving safety via compile-time format string checks
- Reducing binary code size of format_to
#+end_quote
#+begin_src c++
std::string s = std::format("{:d}", "I am not a number");
#+end_src
Becomes ill-formed
LWG, C++23, IS, plenary-approved

** [[https://wg21.link/p2223][P2223]] Trimming whitespaces before line splicing (Corentin Jabot)
#+begin_quote
We propose to make trailing whitespaces after \ non-significant.
#+end_quote
#+begin_src c++
int main() {
int i = 1
// \
+ 42
;
return i;
}
#+end_src
CWG, C++23, SG22, plenary-approved

** [[https://wg21.link/p2227][P2227]] Update normative reference to POSIX (Jonathan Wakely)
C++23, IS, plenary-approved

** [[https://wg21.link/p2231][P2231]] Missing =constexpr= in =std::optional= and =std::variant= (Barry Revzin)
#+begin_quote
But even though the language provided the tools to make ~std::optional~ and ~std::variant~ completely ~constexpr~-able, there was no such update to the library. This paper seeks to remedy that omission by simply adding ~constexpr~ to all the relevant places.
#+end_quote
LWG, C++23, IS, B2 - improvement, plenary-approved

** [[https://wg21.link/p2236][P2236]] C++ Standard Library Issues to be moved in Virtual Plenary, Nov.¬†2020 (Jonathan Wakely)
info, C++23, plenary-approved

** [[https://wg21.link/p2238][P2238]] Core Language Working Group "tentatively ready" issues for the November, 2020 meeting (Will...
info, C++23, plenary-approved

** [[https://wg21.link/p2242][P2242]] Non-literal variables (and labels and gotos) in constexpr functions (Ville Voutilainen)
#+begin_quote
This paper proposes to strike the restriction that a constexpr function cannot contain a definition of a variable of non-literal type (or of static or thread storage duration), or a goto statement, or an identifier label. The rationale is briefly that the mere presence of the aforementioned things in a function is not in and of itself problematic; we can allow them to be present, as long as constant evaluation doesn't evaluate them.
#+end_quote
*** Example
#+begin_src c++
template <typename T>
constexpr bool f() {
    if (std::is_constant_evaluated()) {
        // ...
        return true;
    } else {
        T t;
        // ...
        return true;
    }
}
struct nonliteral {
    nonliteral();
};
static_assert(f<nonliteral>());
#+end_src
CWG, C++23, plenary-approved

** [[https://wg21.link/p2246][P2246]] Character encoding of diagnostic text (Aaron Ballman)
#+begin_quote
The standard provides a few mechanisms that suggest an implementation issues a diagnostic based on
text written in the source code. However, the standard does not uniformly address what should happen
if the execution character set of the compiler cannot represent the text in the source character set.
#+end_quote

#+begin_quote
Because the display of diagnostic messages should be merely a matter of Quality of Implementation, the
proposal is to place no character set related requirements on the diagnostic output with the
understanding that implementations will do what makes the most sense for their situation when issuing
diagnostics in terms of which characters need to be escaped or otherwise handled in a special way.
#+end_quote
CWG, C++23, plenary-approved

** [[https://wg21.link/p2251][P2251]] Require span & basic_string_view to be Trivially Copyable (Nevin Liber)
#+begin_quote
Given its definition, it is strongly implied that span & basic_string_view are
trivially copyable, but that is not yet a requirement.
#+end_quote

LWG, C++23, IS, plenary-approved

** [[https://wg21.link/p2255][P2255]] A type trait to detect reference binding to temporary (Tim Song)
#+begin_quote
This paper proposes adding two new type traits with compiler support to detect when the initialization of a reference would bind it to a lifetime-extended temporary, and changing several standard library components to make such binding ill-formed when it would inevitably produce a dangling reference.
#+end_quote
*** Before
#+begin_src c++
std::tuple<const std::string&>      x("hello");            // dangling
std::function<const std::string&()> f = [] { return ""; }; // OK

f(); // dangling
#+end_src
*** After
#+begin_src c++
std::tuple<const std::string&>      x("hello");            // ill-formed
std::function<const std::string&()> f = [] { return ""; }; // ill-formed
#+end_src
LWG, C++23, IS, small, plenary-approved, expedited-library-evolution-electronic-poll

** [[https://wg21.link/p2259][P2259]] Repairing input range adaptors and counted_iterator (Tim Song)
C++23, IS, plenary-approved

** [[https://wg21.link/p2266][P2266]] Simpler implicit move (Arthur O'Dwyer)
#+begin_quote
In C++20, return statements can implicitly move from local variables of rvalue reference type; but a defect in the wording means that implicit move fails to apply to functions that return references. C++20‚Äôs implicit move is specified via a complicated process involving two overload resolutions, which is hard to implement, causing implementation divergence. We fix the defect and simplify the spec by saying that a returned move-eligible id-expression is always an xvalue.
#+end_quote
CWG, straw-poll, C++23, plenary-approved

** [[https://wg21.link/p2273][P2273]] Making std::unique_ptr constexpr (Andreas Fertig)
#+begin_quote
std::unique_ptr is currently not constexpr friendly. With the loosening of requirements on
constexpr in [P0784R10] and the ability to use new and delete in a constexpr¬≠context, we should
also provide a constexpr std::unique_ptr.
#+end_quote
*** Example
#+begin_src c++
constexpr auto fun() {
    auto p = std::make_unique<int>(4);
    return *p;
}
int main() {
    constexpr auto i = fun();
    static_assert(4 == i);
}
#+end_src

LWG, C++23, B2 - improvement, plenary-approved, constexpr, expedited-library-evolution-electronic-poll

** [[https://wg21.link/p2278][P2278]] cbegin should always return a constant iterator (Barry Revzin)
LWG, ranges, C++23, tentatively-ready-for-plenary, IS, plenary-approved

** [[https://wg21.link/p2280][P2280]] Using unknown references in constant expressions (Barry Revzin)
#+begin_src c++
template <typename T, size_t N>
constexpr auto array_size(T (&)[N]) -> size_t {
    return N;
}

void check(int const (&param)[3]) {
    int            local[] = {1, 2, 3};
    constexpr auto s0      = array_size(local); // ok
    constexpr auto s1      = array_size(param); // error
}
#+end_src
#+begin_quote
The proposal is to allow all these cases to just work. That is, if during constant evaluation, we run into a reference with unknown origin, this is still okay, we keep going. Similarly, if we run into a pointer with unknown origin, we allow indirecting through it.
#+end_quote

CWG, straw-poll, C++23, plenary-approved

** [[https://wg21.link/p2281][P2281]] Clarifying range adaptor objects (Tim Song)
#+begin_quote
The wording below clarifies that the partial application performed by range adaptor objects is essentially identical to that performed by bind_front. (Indeed, it is effectively a limited version of bind_back.) In particular, this means that the bound arguments are captured by copy or move, and never by reference. Invocation of the pipeline then either copies or moves the bound entities, depending on the value category of the pipeline.
#+end_quote
*** Example
#+begin_src c++
auto c = /* some range */;
auto f = /* expensive-to-copy function object */;
c | transform(f); // copies f and then move it into the view

auto t = transform(f); // copies f
c | t;                 // copies f again from t
c | std::move(t);      // moves f from t
#+end_src
LWG, C++23, plenary-approved

** [[https://wg21.link/p2286][P2286]] Formatting Ranges (Barry Revzin)
#+begin_quote
[LWG3478] addresses the issue of what happens when you split a string and the last character in the string is the delimiter that you are splitting on. One of the things I wanted to look at in research in that issue is: what do other languages do here?

For most languages, this is a pretty easy proposition. Do the split, print the results. This is usually only a few lines of code.
#+end_quote
*** Python
#+begin_src python
print("xyx".split("x"))
#+end_src

#+begin_example
['', 'y', '']
#+end_example

*** Java
#+begin_src java
import java.util.Arrays;

class Main {
  public static void main(String args[]) {
    System.out.println("xyx".split("x"));
    System.out.println(Arrays.toString("xyx".split("x")));
  }
}
#+end_src

#+begin_example
[Ljava.lang.String;@76ed5528
[, y]
#+end_example
*** rust
#+begin_src rust
use itertools::Itertools;

fn main() {
    println!("{:?}", "xyx".split('x'));
    println!("[{}]", "xyx".split('x').format(", "));
    println!("{:?}", "xyx".split('x').collect::<Vec<_>>());
}
#+end_src

#+begin_example
Split(SplitInternal { start: 0, end: 3, matcher: CharSearcher { haystack: "xyx", finger: 0, finger_back: 3, needle: 'x', utf8_size: 1, utf8_encoded: [120, 0, 0, 0] }, allow_trailing_empty: true, finished: false })
[, y, ]
["", "y", ""]
#+end_example

*** C++
#+begin_src c++
#include <iostream>
#include <string>
#include <ranges>

int main() {
    // need to predeclare this because we can't split an rvalue string
    std::string s     = "xyx";
    auto        parts = s | std::views::split('x');

    std::cout << "[";
    char const* delim = "";
    for (auto part : parts) {
        std::cout << delim;
        // this finally works
        for (char c : part) {
            std::cout << c;
        }
        delim = ", ";
    }
    std::cout << "]\n";
}
#+end_src
#+begin_example
[, y, ]
#+end_example
*** lib fmt
#+begin_src c++
#include <ranges>
#include <string>
#include <fmt/ranges.h>

int main() {
    std::string s = "xyx";
    auto parts = s | std::views::split('x');

    fmt::print("{}\n", parts);
    fmt::print("<<{}>>\n", fmt::join(parts, "--"));
}
#+end_src
#+begin_example
[[], ['y'], []]
<<[]--['y']--[]>>
#+end_example

LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved

** [[https://wg21.link/p2290][P2290]] Delimited escape sequences (Corentin Jabot)
#+begin_quote
We propose an additional, clearly delimited syntax for octal, hexadecimal and universal
character name escape sequences.
#+end_quote
#+begin_quote
We propose new syntaxes \u{}, \o{}, \x{} usable in places where \u, \x, \nnn currently are.
\o{} accepts an arbitrary number of octal digits while \u{} and \x{} accept an arbitrary number
of hexadecimal digit.
#+end_quote
CWG, straw-poll, C++23, plenary-approved

** [[https://wg21.link/p2291][P2291]] Add Constexpr Modifiers to Functions =to_chars= and =from_chars= for Integral Types in =<charconv>= Header (Daniil Goncharov, Karaev Alexander)
#+begin_quote
There is currently no standard way to make conversion between numbers and strings /at compile time/.

~std::to_chars~ and ~std::from_chars~ are fundamental blocks for parsing and
formatting being localeindependent and non-throwing without memory allocation,
so they look like natural candidates for constexpr string conversions. The
paper proposes to make ~std::to_chars~ and ~std::from_chars~ functions for *integral
types* usable in constexpr context.
#+end_quote
LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved, constexpr, expedited-library-evolution-electronic-poll

** [[https://wg21.link/p2295][P2295]] Correct UTF-8 handling during phase 1 of translation (Corentin Jabot)
CWG, straw-poll, C++23, plenary-approved

** [[https://wg21.link/p2301][P2301]] Add a pmr alias for std::stacktrace (Steve Downey)
#+begin_quote
This paper proposes to add an alias in the pmr namespace defaulting the allocator used by the std::basic_stacktrace template to pmr::allocator. No changes to the api of std::stacktrace are necessary.
#+end_quote
*** Before
#+begin_src c++
char buffer[1024];

std::pmr::monotonic_buffer_resource pool{
    std::data(buffer), std::size(buffer)};

std::basic_stacktrace<
    std::pmr::polymorphic_allocator<std::stacktrace_entry>>
    trace{&pool};
#+end_src
*** After
#+begin_src c++
char buffer[1024];

std::pmr::monotonic_buffer_resource pool{
    std::data(buffer), std::size(buffer)};

std::pmr::stacktrace trace{&pool};
#+end_src

LWG, C++23, tiny, plenary-approved

** [[https://wg21.link/p2302][P2302]] Prefer std::ranges::contains over std::basic_string_view::contains (Christopher Di Bella)
#+begin_quote
P2302 proposes two algorithms: one that checks whether or not a range contains an element, and one that checks whether or not a range contains a subrange
#+end_quote
Before:
#+begin_src c++
namespace stdr = std::ranges;
stdr::find(haystack.begin(), haystack.end(), 'o') != haystack.end()
stdr::find(haystack, 'o') != stdr::end(haystack)
not stdr::search(haystack, long_needle).empty()
not stdr::search(haystack, long_needle, bind_back(std::modulo(), 4)).empty()
#+end_src
After:
#+begin_src c++
namespace stdr = std::ranges;
stdr::contains(haystack.begin(), haystack.end(), 'o')
stdr::contains(haystack, 'o')
stdr::contains_subrange(haystack, long_needle)
stdr::contains_subrange(haystack, long_needle, bind_back(std::modulo(), 4))
#+end_src
LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved

** [[https://wg21.link/p2313][P2313]] Core Language Working Group "tentatively ready" issues for the February, 2021 mee...
CWG, info, C++23, plenary-approved

** [[https://wg21.link/p2314][P2314]] Character sets and encodings (Jens Maurer)
#+begin_quote
This paper implements the following changes:
- Switch C++ to a modified "model C" approach for universal-character-names as described in the C99 Rationale v5.10, section 5.2.1.
- Introduce the term "literal encoding". For purposes of the C++ specification, the actual set of characters is not relevant, but the sequence of code units (i.e. the encoding) specified by a given character or string literal are. The terms "execution (wide) character set" are retained to describe the locale-dependent runtime character set used by functions such as isalpha.
- (Not a wording change) Do not attempt to treat all string literals the same; their treatment depends on (phase 7) context.
#+end_quote
*** Before/After Table
Before:
#+begin_src c++
#define S(x) # x
const char * s1 = S(K√∂ppe);       // "K\\u00f6ppe"
const char * s2 = S(K\u00f6ppe);  // "K\\u00f6ppe"
#+end_src
After:
#+begin_src c++
#define S(x) # x
const char * s1 = S(K√∂ppe);       // "K√∂ppe"
const char * s2 = S(K\u00f6ppe);  // "K√∂ppe"
#+end_src
CWG, C++23, plenary-approved

** [[https://wg21.link/p2315][P2315]] C++ Standard Library Issues to be moved in Virtual Plenary, Feb.¬†2021 (Jonathan Wakely)
LWG, info, C++23, plenary-approved

** [[https://wg21.link/p2316][P2316]] Consistent character literal encoding (Corentin Jabot)
#+begin_quote
Character literals in preprocessor conditional should behave like they do in C++ expression.
#+end_quote
#+begin_src c++
#if 'A' == '\x41'
//...
#endif
if ('A' == 0x41){}
#+end_src
CWG, C++23, plenary-approved

** [[https://wg21.link/p2321][P2321]] zip (Tim Song)
#+begin_quote
This paper proposes
- four views, zip, zip_transform, adjacent, and adjacent_transform,
- changes to tuple and pair necessary to make them usable as proxy references (necessary for zip and adjacent), and
- changes to vector<bool>::reference to make it usable as a proxy reference for writing,
#+end_quote
cccgs** Example
#+begin_src c++
std::vector v1 = {1, 2};
std::vector v2 = {'a', 'b', 'c'};
std::vector v3 = {3, 4, 5};

fmt::print("{}\n", std::views::zip(v1, v2));                              // {(1, 'a'), (2, 'b')}
fmt::print("{}\n", std::views::zip_transform(std::multiplies(), v1, v3)); // {3, 8}
fmt::print("{}\n", v2 | std::views::pairwise);                            // {('a', 'b'), ('b', 'c')}
fmt::print("{}\n", v3 | std::views::pairwise_transform(std::plus()));     // {7, 9}
#+end_src
LWG, ranges, C++23, IS, B3 - addition, plenary-approved

** [[https://wg21.link/p2322][P2322]] ranges::fold (Barry Revzin)
#+begin_quote
While we do have an iterator-based version of fold in the standard library, it is currently named accumulate, defaults to performing + on its operands, and is found in the header <numeric>. But fold is much more than addition, so as described in the linked paper, it‚Äôs important to give it the more generic name and to avoid a default operator.
#+end_quote
LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved

** [[https://wg21.link/p2324][P2324]] Labels at the end of compound statements (C compatibility) (Martin Uecker)
#+begin_quote
WG14 adopted a change for C2X that allows placement of labels everywhere inside a compound
statement (N2508). While this improves compatibility with C++ which previously diverged from C
by allowing labels in front of declarations, there is still a remaining incompatibility: C now does
allow labels at the end of a compound statement, while C++ does not. It is proposed to change the
C++ grammar to remove this remaining difference.
#+end_quote
*** Example
#+begin_src c++
void foo(void)
{
first: // allowed in C++, now also allowed in C
int x;
second: // allowed in both C++ and C
x = 1;
last: // not allowed in C++, but now allowed in C
}
#+end_src
CWG, straw-poll, C++23, size - small, plenary-approved

** [[https://wg21.link/p2325][P2325]] Views should not be required to be default constructible (Barry Revzin)
#+begin_quote
Currently, the view concept is defined in 24.4.4 [range.view] as:
#+end_quote
#+begin_src
template <class T>
concept view =
    range<T> &&
    movable<T> &&
    default_initializable<T> &&
    enable_view<T>;
#+end_src
*** Discussion
#+begin_quote
Three of these four criteria, I understand. A view clearly needs to be a range, and it‚Äôs important that they be movable for various operations to work. And the difference between a view and range is largely semantic, and so there needs to be an explicit opt-in in the form of enable_view.

But why does a view need to be default_initializable?
#+end_quote
LWG, ranges, C++23, IS, B2 - improvement, plenary-approved

** [[https://wg21.link/p2327][P2327]] De-deprecating volatile compound assignment (Paul Bendixen, Jens Maurer, Arthur O'Dwyer, Ben Saks)
#+begin_quote
The C++ 20 standard deprecated many functionalities of the volatile keyword. This was due to
P1152[Bastien, 2019]. The reasoning is given in the R0 version of the paper[Bastien, 2018].

The deprecation was not received too well in the embedded community as volatile is commonly
used for communicating with peripheral devices in microcontrollers[van Ooijen, 2020].

The purpose of this paper is to give a solution that will not undo what was achieved with
P1152, and still keep the parts that are critical to the embedded community.
#+end_quote
CWG, straw-poll, C++23, plenary-approved

** [[https://wg21.link/P2328][P2328]] join_view should join all views of ranges (Tim Song)
#+begin_quote
This paper proposes relaxing the constraint on join_view to support joining ranges of prvalue non-view ranges.
#+end_quote
LWG, ranges, C++23, IS, B2: Improvement, plenary-approved

** [[https://wg21.link/p2334][P2334]] Add support for preprocessing directives elifdef and elifndef (Melanie Blower)
#+begin_quote
This paper is being submitted as a liaison activity from WG14 C Language Working Group. The proposal
was discussed in the March 2021 meeting and approved (15 in favor, 1 opposed, 4 abstentions) for
inclusion into C23. This paper is being proposed to WG21 to avoid preprocessor incompatibilities with C
and because the utility is valuable to C++ users of the preprocessor.
#+end_quote
CWG, C++23, plenary-approved

** [[https://wg21.link/p2340][P2340]] Clarifying the status of the ‚ÄòC headers' (Thomas K√∂ppe)
#+begin_quote
We propose to move the specification of ‚Äú[depr.c.headers] C headers‚Äù from Annex D into the main document, and changing those headers‚Äô status from ‚Äúdeprecated‚Äù to an explicitly discussed state ‚Äúfor foreign-language interoperability only‚Äù.
#+end_quote
LWG, C++23, policy, IS, B2 - improvement, size - small, plenary-approved

** [[https://wg21.link/p2360][P2360]] Extend init-statement to allow alias-declaration (Jens Maurer)
*** Before:
#+begin_src c++
  for (typedef int T; T e : v)
    /* something */;
#+end_src
*** After:
#+begin_src c++
  for (using T = int; T e : v)
    /* something */;
#+end_src
CWG, C++23, plenary-approved

** [[https://wg21.link/p2362][P2362]] Make obfuscating wide character literals ill-formed (Peter Brett, Corentin Jabot)
#+begin_quote
C++ currently permits writing a wide character literal with multiple characters or characters that
cannot fit into a single ~wchar_t~ codeunit. For example:
#+end_quote
*** Example
#+begin_src c++
wchar_t a = L'ü§¶'; // \u{1F926}
wchar_t b = L'ab';
wchar_t c = L'√©'; // \u{65}\u{301};
#+end_src
#+begin_quote
Make these literals ill-formed.
#+end_quote

CWG, straw-poll, C++23, plenary-approved

** [[https://wg21.link/p2367][P2367]] Remove misuses of list-initialization from Clause 24 (Tim Song)
#+begin_quote
This paper provides wording for [LWG3524] and resolves related issues caused by the erroneous use of list-initialization in ranges wording.
#+end_quote

#+begin_quote
As discussed in [LWG3524], the use of list-initialization in the ranges specification implies ordering guarantees that are unintended and unimplementable in ordinary C++, as well as narrowing checks that are unnecessary and sometimes unimplementable.
#+end_quote
LWG, C++23, plenary-approved

** [[https://wg21.link/P2372][P2372]] Fixing locale handling in chrono formatters (Victor Zverovich, Corentin Jabot)
#+begin_quote
In C++20 "Extending <chrono> to Calendars and Time Zones" ([P0355]) and "Text Formatting" ([P0645]) proposals were integrated ([P1361]). Unfortunately during this integration a design issue was missed: std::format is locale-independent by default and provides control over locale via format specifiers but the new formatter specializations for chrono types are localized by default and don‚Äôt provide such control.
#+end_quote
*** Solution
#+begin_quote
We propose fixing this issue by making chrono formatters locale-independent by default and providing the L specifier to opt into localized formatting in the same way as it is done for all other standard formatters (format.string.std).
#+end_quote
*** Before:
#+begin_src c++
auto s = std::format("{:%S}", sec(4.2));
// s == "04,200"

auto s = std::format("{:L%S}", sec(4.2));
// throws format_error
#+end_src
*** After:
#+begin_src c++
auto s = std::format("{:%S}", sec(4.2));
// s == "04.200"

auto s = std::format("{:L%S}", sec(4.2));
// s == "04,200"
#+end_src

LWG, C++23, IS, plenary-approved

** [[https://wg21.link/p2374][P2374]] views::cartesian_product (Sy Brand)
LWG, ranges, C++23, tentatively-ready-for-plenary, IS, plenary-approved

** [[https://wg21.link/p2385][P2385]] C++ Standard Library Issues to be moved in Virtual Plenary, June 2021 (Jonathan Wakely)
info, C++23, plenary-approved

** [[https://wg21.link/p2386][P2386]] Core Language Working Group "ready" Issues for the June, 2021 meeting (William M....
info, C++23, plenary-approved

** [[https://wg21.link/p2387][P2387]] Pipe support for user-defined range adaptors (Barry Revzin)
#+begin_quote
Walter Brown made an excellent observation: if we gave users the tools to write their own range adaptors that would properly inter-operate with standard library adaptors (as well as other users‚Äô adaptors), then it becomes less important to provide more adaptors in the standard library.

The goal of this paper is provide that functionality: provide a standard customization mechanism for range adaptors, so that everybody can write their own adaptors.
#+end_quote

LWG, ranges, C++23, IS, B2 - improvement, size - medium, plenary-approved

** [[https://wg21.link/p2393][P2393]] Cleaning up integer-class types (Tim Song)
#+begin_quote
This paper revamps the specification and use of integer-class types to resolve a number of issues, including [LWG3366], [LWG3376], and [LWG3575].
#+end_quote
LWG, C++23, plenary-approved

** [[https://wg21.link/p2401][P2401]] Add a conditional noexcept specification to std::exchange (Giuseppe D'Angelo)
#+begin_quote
We propose to add a noexcept-specification to std::exchange , which is currently lacking one.
#+end_quote
LWG, C++23, IS, plenary-approved

** [[https://wg21.link/p2404][P2404]] Relaxing equality_comparable_with's and three_way_comparable_with's common reference requir...
LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, expedited-library-evolution-electronic-poll

** [[https://wg21.link/p2408][P2408]] Ranges views as inputs to non-Ranges algorithms (David Olsen)
#+begin_quote
Change the iterator requirements for non-Ranges algorithms. For forward iterators and above that are constant iterators, instead of requiring that iterators meet certain /Cpp17...Iterator/ requirements, require that the iterators model certain iterator concepts. This makes iterators from several standard views usable with non-Ranges algorithms that require forward iterators or above, such as the parallel overloads of most algorithms.
#+end_quote
LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, plenary-approved

** [[https://wg21.link/p2415][P2415]] What is a view? (Barry Revzin, Tim Song)
#+begin_quote
Once upon a time, a view was a cheaply copyable, non-owning range. We‚Äôve already somewhat lost the ‚Äúcheaply copyable‚Äù requirement since views don‚Äôt have to be copyable, and now this paper is suggesting that we also lose the non-owning part.
#+end_quote
LWG, ranges, C++23, IS, B2 - improvement, size - medium, plenary-approved

** [[https://wg21.link/p2417][P2417]] A more constexpr bitset (Daniil Goncharov)
LWG, C++23, tentatively-ready-for-plenary, IS, B3 - addition, size - medium, plenary-approved, constexpr, expedited-library-evolut...

** [[https://wg21.link/p2418][P2418]] Add support for std::generator-like types to std::format (Victor Zverovich)
#+begin_quote
Unfortunately we cannot make std::generator formattable because it is neither const-iterable nor copyable and std::format takes arguments by const&.
#+end_quote
#+begin_quote
This paper proposes solving the issue by making std::format and other formatting functions take arguments by forwarding references.
#+end_quote
LWG, C++23, IS, B2 - improvement, size - medium, plenary-approved

** [[https://wg21.link/p2419][P2419]] Clarify handling of encodings in localized formatting of chrono types (Victor Zverovich)
LWG, C++23, tentatively-ready-for-plenary, IS, lwg-fullreview, B2 - improvement, size - tiny, plenary-approved

** [[https://wg21.link/P2432][P2432]] Fix istream_view (Nicolai Josuttis)
#+begin_quote
This paper fixes a fundamental design problem with the current helper function
std::ranges::istream_view<>() that cause multiple inconsistences and unnecessary code
overhead when declaring istream_view objects
#+end_quote
Before:
#+begin_src c++
std::ranges::istream_view<int> v{mystream}
 // ERROR
#+end_src
After:
#+begin_src c++
std::ranges::istream_view<int> v{mystream}
 // OK
#+end_src
LWG, ranges, C++23, IS, B2 - improvement, size - small, plenary-approved

** [[https://wg21.link/p2437][P2437]] Support for #warning (Aaron Ballman)
#+begin_quote
Almost all major C++ compilers support the #warning preprocessing directive to generate a diagnostic
message from the preprocessor without stopping translation, as #error does, which can be useful for
code authors who want to warn consumers of the code about non-fatal concerns. C
#+end_quote
#+begin_quote
WG14 considered a similar proposal as part of WG14 N2686 at our Sept 2021 meeting and adopted the
feature into C23 (straw poll results were: 17 in favor, 0 oppose, 1 abstain). The WG21 proposal is
functionally identical to the WG14 proposal, with the only difference being due to existing variance in
specification around how #error causes translation to stop.
#+end_quote
CWG, straw-poll, C++23, size - tiny, plenary-approved

** [[https://wg21.link/p2438][P2438]] std::string::substr() && (Federico Kircheis, Tomasz Kami≈Ñski)
#+begin_src c++
auto foo() -> std::string;

auto b = foo().substr(/* */);
#+end_src
Before:
#+begin_quote
foo() returns a temporary std::string. .substr creates a new string and copies the relevant content. At last, the temporary string returned by foo is released.
#+end_quote
After:
#+begin_quote
foo() returns a std::string. .substr implementation can reuse the storage of the string returned by foo and leave it in a valid but unspecified state. At last, the temporary string returned by foo() is released.
#+end_quote
LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, expedited-library-evolution-electronic-poll

** [[https://wg21.link/p2440][P2440]] ranges::iota, ranges::shift_left, and ranges::shift_right (Tim Song)
#+begin_quote
This paper proposes adding the algorithms ranges::iota, ranges::shift_left, and ranges::shift_right, to match their std counterparts.
#+end_quote
LWG, ranges, C++23, IS, B3 - addition, size - medium, plenary-approved

** [[https://wg21.link/p2441][P2441]] views::join_with (Barry Revzin)
#+begin_quote
The behavior of ~views::join_with~ is an inverse of ~views::split~. That is, given a range ~r~ and a pattern ~p~, ~r | views::split(p) | views::join_with(p)~ should yield a range consisting of the same elements as ~r~.
#+end_quote
LWG, ranges, C++23, IS, plenary-approved

** [[https://wg21.link/p2442][P2442]] Windowing range adaptors: views::chunk and views::slide (Tim Song)
#+begin_quote
This paper proposes two range adaptors, views::chunk and views::slide, as described in section 3.5 of [P2214R0].
#+end_quote
#+begin_src c++
std::vector v = {1, 2, 3, 4, 5};
fmt::print("{}\n", v | std::views::chunk(2));   // [[1, 2], [3, 4], [5]]
fmt::print("{}\n", v | std::views::slide(2));   // [[1, 2], [2, 3], [3, 4], [4, 5]]
#+end_src
LWG, ranges, C++23, IS, B3 - addition, size - medium, plenary-approved

** [[https://wg21.link/p2443][P2443]] views::chunk_by (Tim Song)
#+begin_quote
This paper proposes the range adaptor views::chunk_by as described in section 4.3 of [P2214R1].
#+end_quote
#+begin_src c++
std::vector v = {1, 2, 2, 3, 0, 4, 5, 2};
fmt::print("{}\n", v | std::views::chunk_by(ranges::less_equal{}));   // [[1, 2, 2, 3], [0, 4, 5], [2]]
#+end_src

LWG, ranges, C++23, IS, B3 - addition, size - medium, plenary-approved

** [[https://wg21.link/p2445][P2445]] forward_like (Ga≈°per A≈æman)
#+begin_quote
Deducing This [P0847R7] is expected to land in C++23.
Its examples use a hypothetical ~std::forward_like<decltype(self)>(variable)~ facility because
~std::forward<decltype(v)>(v)~ is insufficient. This paper proposes ~std::forward_like~ to cater to
this scenario.
#+end_quote
*** Example
#+begin_src c++
auto callback = [m = get_message(), &scheduler](this auto&& self) -> bool {
    return scheduler.submit(std::forward_like<decltype(self)>(m));
};
callback();            // retry(callback)
std::move(callback)(); // try-or-fail(rvalue)
#+end_src

LWG, C++23, tentatively-ready-for-plenary, IS, B3 - addition, size - small, plenary-approved

** [[https://wg21.link/p2446][P2446]] views::move (Barry Revzin)
#+begin_quote
~as_rvalue_view~ presents a view of an underlying sequence with the same behavior as the underlying sequence except that its elements are rvalues. Some generic algorithms can be called with a as_rvalue_view to replace copying with moving.

The name views::as_rvalue denotes a range adaptor object ([range.adaptor.object]).
#+end_quote
LWG, ranges, C++23, tentatively-ready-for-plenary, IS, plenary-approved

** [[https://wg21.link/p2448][P2448]] Relaxing some constexpr restrictions (Barry Revzin)
#+begin_quote
There are two rules about constexpr programming that make code ill-formed or ill-formed (no diagnostic required) when functions or function templates are marked constexpr that might never evaluate to a constant expression. But‚Ä¶ so what if they don‚Äôt? The goal of this paper is to stop diagnosing problems that don‚Äôt exist.
#+end_quote
CWG, straw-poll, C++23, plenary-approved

** [[https://wg21.link/p2450][P2450]] C++ Standard Library Issues to be moved in Virtual Plenary, Oct.¬†2021 (Jonathan Wakely)
LWG, C++23, plenary-approved

** [[https://wg21.link/p2460][P2460]] Relax requirements on wchar_t to match existing practices (Corentin Jabot)
CWG, LWG, straw-poll, C++23, tentatively-ready-for-plenary, IS, lwg-fullreview, B2 - improvement, size - small, plenary-approved, ...

** [[https://wg21.link/p2462][P2462]] Core Language Working Group ‚Äúready‚Äù issues for the October, 2021 meeting (Willi...
CWG, C++23, plenary-approved

** [[https://wg21.link/p2412][P2465]] Standard Library Modules std and std.all (Stephan T. Lavavej, Gabriel Dos Reis, Bjarne Stroustrup, Jonathan Wakely)
#+begin_quote
Header files are a major source of complexity, errors caused by dependencies, and slow compilation.
Modules address all three problems, but are currently hard to use because the standard library is not
offered in a module form. This note presents logical arguments and a few measurements that
demonstrates that *import std* of a module *std* presenting all of the standard library can compile many
times faster than plain old *#include <iostream>*.
#+end_quote
*** As adopted
#+begin_quote
This paper provides Standardese for two named modules: ~std~ and ~std.compat~.

~import std;~ imports everything in namespace std from C++ headers (e.g.
~std::sort~ from ~<algorithm>~) and C wrapper headers (e.g. ~std::fopen~ from
~<cstdio>~). It also imports ~::operator new~ etc. from ~<new>~.

~import std.compat;~ imports all of the above, plus the global namespace
counterparts for the C wrapper headers (e.g. ~::fopen~).
#+end_quote

CWG, LWG, straw-poll, C++23, tentatively-ready-for-plenary, IS, modular-standard-library, size - large, plenary-approved

** [[https://wg21.link/P2467][P2467]] Support exclusive mode for fstreams (Jonathan Wakely)
#+begin_quote
Historically, C++ iostreams libraries had a ~noreplace~ open mode that corresponded to the ~O_EXCL~ flag for POSIX ~open~. That mode was not included in the C++98 standard, presumably for portability reasons, because it wasn't in ISO C90.

Since then, ISO C added support for "exclusive" mode to ~fopen~, so now C++'s ~<fstream>~ is missing a feature that is present in both ISO C and POSIX. We should fix this for C++23.
#+end_quote
LWG, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved, expedited-library-evolution-electronic-poll

** [[https://wg21.link/p2468][P2468]] The Equality Operator You Are Looking For (Barry Revzin, Bjarne Stroustrup, Cameron DaCamara, Daveed Vandevoorde, Gabriel Dos Reis, Herb Sutter, Jason Merrill, Jonathan Caves, Richard Smith, Ville Voutilainen)
#+begin_quote
This paper details some changes to make rewriting equality in expressions less of a breaking change
#+end_quote
#+begin_quote
- If you want an operator== that is used for rewrites (automatically reversed, and != automatically generated), write only an operator==, and make sure its return type is bool.

- If you want an operator== that is not used for rewrites, write both an operator== and a matching operator!=.

- operator<=> is always used for rewrites (from <, <=, >, >=); if you don‚Äôt want rewrites, don‚Äôt write an operator<=>.
#+end_quote
CWG, straw-poll, C++23, plenary-approved

** [[https://wg21.link/p2474][P2474]] views::repeat (Micha≈Ç Dominiak)
LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B3 - addition, size - small, plenary-approved, expedited-library-evolution-...

** [[https://wg21.link/p2493][P2493]] Missing feature test macros for C++20 core papers (Barry Revzin)
#+begin_quote
As Jonathan Wakely pointed out on the SG10 mailing list, neither [P0848R3] (Conditionally Trivial Special Member Functions) nor [P1330R0] ( Changing the active member of a union inside constexpr) provided a feature-test macro.
#+end_quote

#+begin_quote
This paper proposes Richard‚Äôs second suggestion: bump __cpp_concepts and __cpp_constexpr to 202002L
#+end_quote
CWG, straw-poll, C++23, plenary-approved

** [[https://wg21.link/p2494][P2494]] Relaxing range adaptors to allow for move only types (Micha≈Ç Dominiak)
#+begin_quote
Currently, many range adaptors require that the user-provided types they store must be copy constructible, which is also required by the assignment wrapper they use, copyable-box.
#+end_quote

#+begin_quote
Similarly to how [P2325R3] turned semiregular-box into copyable-box, this paper proposes to turn copyable-box into movable-box. This name is probably not ideal, because it still turns types that happen to be copy constructible into copyable types, but it follows from the prior changes to the wrapper.
#+end_quote
LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, plenary-approved

** [[https://wg21.link/p2499][P2499]] string_view range constructor should be explicit (James Touton)
LWG, ranges, C++23, tentatively-ready-for-plenary, IS, plenary-approved

** [[https://wg21.link/P2502][P2502]] std::generator: Synchronous Coroutine Generator for Ranges (Casey Carter)
#+begin_quote
We propose a standard library type std::generator which implements a coroutine generator
that models std::ranges::input_range.
#+end_quote
*** Example
#+begin_src c++
std::generator<int> fib() {
    auto a = 0, b = 1;
    while (true) {
        co_yield std::exchange(a, std::exchange(b, a + b));
    }
}
int answer_to_the_universe() {
    auto rng = fib() | std::views::drop(6) | std::views::take(3);
    return std::ranges::fold_left(std::move(range), 0, std::plus{});
}
#+end_src
LWG, coroutines, ranges, C++23, tentatively-ready-for-plenary, IS, B1 - focus, plenary-approved

** [[https://wg21.link/p2505][P2505]] Monadic Functions for std::expected (Jeff Garland)
LWG, C++23, IS, lwg-fullreview, B2 - improvement, size - small, plenary-approved

** [[https://wg21.link/p2508][P2508]] Exposing std::basic-format-string (Barry Revzin)
#+begin_quote
In 20.20.1 [format.syn], replace the exposition-only names basic-format-string, format-string, and wformat-string with the non-exposition-only names basic_format_string, format_string, and wformat_string.
#+end_quote
*** Example
#+begin_src c++
template <typename... Args>
void log(std::format_string<Args...> s, Args&&... args) {
    if (logging_enabled) {
        log_raw(std::format(s, std::forward<Args>(args)...));
    }
}
#+end_src
LWG, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved

** [[https://wg21.link/p2513][P2513]] char8_t Compatibility and Portability Fixes (JeanHeyd Meneide, Tom Honermann)
#+begin_quote
char8_t has compatibility problems and issues during deployment that people have had to spend energy working around. This paper aims to alleviate some of those compatibility problems, for both C and C++, around string and character literals for the char8_t type.
#+end_quote
CWG, straw-poll, C++23, B2 - improvement, plenary-approved

** [[https://wg21.link/p2517][P2517]] Add a conditional noexcept specification to std::apply (Hewill Kang)
#+begin_quote
This paper proposes to add a noexcept-specification to ~std::apply~.
#+end_quote

#+begin_quote
~invoke(f, args...)~ should be completely equivalent to ~apply(f,
forward_as_tuple(args...))~, adding ~noexcept~ to ~apply~ can easily achieve
this and make it more consistent with ~invoke~.
#+end_quote

LWG, C++23, tentatively-ready-for-plenary, IS, lwg-fullreview,
plenary-approved

** [[https://wg21.link/p2520][P2520]] move_iterator should be a random access iterator (Barry Revzin)
#+begin_quote
~move_iterator<T*>~ should be a random access iterator
#+end_quote
LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved, expedited-library-evoluti...

** [[https://wg21.link/p2539][P2539]] Should the output of std::print to a terminal be synchronized with the underlying stream? (...
#+begin_quote
To prevent mojibake std::print may use a native Unicode API when writing to a terminal bypassing the stream buffer. During the review of [P2093] "Formatted output" Tim Song suggested that synchronizing std::print with the underlying stream may be beneficial for gradual adoption. This paper presents motivating examples, observes that this problem doesn‚Äôt normally happen in practice and proposes a minor update to the wording to provide a synchronization guarantee.
#+end_quote
LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved

** [[https://wg21.link/p2540][P2540]] Empty Product for certain Views (Steve Downey)
#+begin_quote
This paper argues that the Cartesian product of no ranges should be a single
empty tuple, which is the identity element for Cartesian products. Other
product-like views, however, should not automatically have their identity be
the result, and in particular for zip, as it would introduce unsound
inconsistencies.
#+end_quote


LWG, ranges, C++23, tentatively-ready-for-plenary, IS, plenary-approved

** [[https://wg21.link/p2549][P2549]] std::unexpected should have error() as member accessor (Yihe Li)

*** Before change:

#+begin_src c++
void fun()
{
    using namespace std::literals;
    using ET = std::expected<int, std::string>;
    auto unex = std::unexpected("Oops"s);
    auto wrapped = unex.value(); // okay, get "Oops"
    auto ex = ET(unex); // implicit, can also happen in parameter passing, etc.
    auto wrapped2 = ex.value(); // throws!
}
#+end_src

*** After change:
#+begin_src c++
void fun()
{
    using namespace std::literals;
    using ET = std::expected<int, std::string>;
    auto unex = std::unexpected("Oops"s);
    auto wrapped = unex.error(); // okay, get "Oops"
    auto ex = ET(unex); // implicit, can also happen in parameter passing, etc.
    auto wrapped2 = ex.error(); // okay, get "Oops" too.
}
#+end_src

LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved

** [[https://wg21.link/p2553][P2553]] Make mdspan size_type controllable (Christian Trott, Damien Lebrun-Grandie, Mark Hoemmen, K. R. Walker, Daniel Sunderland)
#+begin_quote
P0009 explicitly sets the size_type of extents to size_t, which is then used by layout mappings and mdspan. While this matches span whose extent function returns size_t, this behavior has significant performance impact on various architectures where 64-bit integer throughput is significantly lower than 32-bit integer computation throughput.
#+end_quote

Proposal:

#+begin_quote
All in all we prefer the option of making extents require the additional argument (2.2.2), with the next best thing being the introduction basic_extents and making extents an alias to basic_extents with size_t as the size_type. If LEWG would prefer the second option, the wording is largely the same with the following changes at the end:

- Rename extents to basic_extents throughout P0009 and

- Add an alias in [mdspan.syn]:
#+end_quote

#+begin_src c++
template<size_t ... Extents>
using extents = basic_extents<size_t, Extents...>;
#+end_src
LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, mdspan

** [[https://wg21.link/p2554][P2554]] C-Array Interoperability of MDSpan (Christian Trott, Damien Lebrun-Grandie, Mark Hoemmen, K. R. Walker, Daniel Sunderland)
#+begin_quote
We cannot currently fix the multidimensional c-array construction, since it is UB to alias a nested C-Array with a element type pointer - per discussion on the C++ committee reflector in January 2022. However, in practice it works (on the compilers we tested e.g. clang-based and gcc) - and it may be something the committee changes in the future - i.e. make it not-UB. We propotyped this capability, which requires an additional constructor from c-array and a few deduction guides.

What we can fix today is the deduction from 1D c-array, by adding a deduction guide from c-array constraint to rank-1 arrays.
#+end_quote

LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, mdspan

** [[https://wg21.link/p2564][P2564]] consteval needs to propagate up (Barry Revzin)
#+begin_quote
This paper proposes avoiding the consteval coloring problem (or, at least, mitigating its annoyances) by allowing certain existing constexpr functions to implicitly become consteval functions when those functions can already only be invoked during compile time anyway.

Specifically, these three rules:

1. If a constexpr function contains a call to an immediate function outside of an immediate function context, and that call itself isn‚Äôt a constant expression, said constexpr function implicitly becomes a consteval function. This is intended to include lambdas, function template specializations, special member functions, and should cover member initializers as well.

2. If an expression-id designates a consteval function without it being an immediate call in such a context, it also makes the context implicitly consteval. Such expression-id‚Äôs are also allowed in contexts that are manifestly constant evaluated.

3. Other manifestly constant evaluated contexts (like constant-expression and the condition of a constexpr if statement) are now considered to be immediate function contexts.
#+end_quote

CWG, straw-poll, C++23, nb-comment, plenary-approved

** [[https://wg21.link/p2579][P2579]] Mitigation strategies for P2036 ‚ÄùChanging scope for lambda trailing-return-type‚Äù (Corentin Jabot)
#+begin_quote
P2036R3 was adopted for C++23 and as a Defect Report, affecting C++11 and
greater. After implementing this paper in Clang, we observed the proposed
changes make ill-formed previously valid and relied upon code.
#+end_quote
#+begin_quote
identifiers refered to captured variables but do not take the mutable keyword
into account
#+end_quote

#+begin_src c++
struct F {
float x;
void mem1(decltype((x)) p3); // p3 is a float&
void mem2(decltype((x)) p4) const; // p4 is a float&
};
#+end_src

#+begin_src c++
int x;
[x=42.0]<decltype(x) a> // float
(decltype((x)) b) // float&
-> decltype((x)) // const float&
#+end_src

CWG, straw-poll, C++23, plenary-approved

** [[https://wg21.link/p2582][P2582]] Wording for class template argument deduction from inherited constructors (Timur Doumler)
#+begin_quote
This paper provides wording for class template argument deduction from inherited constructors.
#+end_quote
From [[https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1021r6.html][P1021R6]]

*** Before:
#+begin_src c++
template<class T>
struct Point { T x; T y; };

// Aggregate: Cannot deduce
Point<double> p{3.0, 4.0};
Point<double> p2{.x = 3.0, .y = 4.0};
#+end_src

*** After:
#+begin_src c++

template<class T>
struct Point { T x; T y; };

// Proposed: Aggregates deduce
Point p{3.0, 4.0};
Point p2{.x = 3.0, .y = 4.0};
#+end_src
CWG, straw-poll, C++23, plenary-approved

** [[https://wg21.link/p2585][P2585]] Improving default container formatting (Barry Revzin)
#+begin_quote
[P2286R8] adds support for formatting any range whose underlying type is formattable. Additionally, it adds support for different kinds of formatting that users can opt into, while also providing a default choice for associating containers that is more suited to what those containers represent.
#+end_quote

#+begin_quote
However, this distinction is a result of [P2286R8] explicitly providing formatters for all the standard library map and set containers, and applying those changes to them. This is something that users can do for their own containers as well, but which also means that it is something users have to do - if this is the behavior they want.
#+end_quote

LWG, C++23, tentatively-ready-for-plenary, IS, lwg-fullreview, B2 - improvement, size - medium, plenary-approved

** [[https://wg21.link/p2588][P2588]] Relax std::barrier phase completion step guarantees (Gonzalo Brito Gadeschi, Eric Niebler, Anthony Williams, Thomas Rodgers)
#+begin_quote
Unintended consequences of ~std::barrier~ ‚Äôs specification constrain implementations to run the ~CompletionFunction~ on the last thread that arrives at the barrier during the phase. This prevents ~std::barrier~ from benefiting from hardware acceleration for thread synchronization. Removing these constraints is a _breaking change_. This paper aims to find a sweet spot for the barrier specification that delivers the functionality that applications need while allowing efficient implementations.
#+end_quote

LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved

** [[https://wg21.link/p2590][P2590]] Explicit lifetime management (Timur Doumler, Richard Smith)
#+begin_quote
This paper proposes a new standard library facility
~std::start_lifetime_as~. For objects of sufficiently trivial types, this
facility can be used to efficiently create objects and start their lifetime to
give programs defined behaviour, without running any constructor code. This
proposal completes the functionality proposed in [P0593R6] and adopted for
C++20 by providing the standard library portion of that paper (only the core
language portion of that paper made it into C++20).
#+end_quote

CWG, LWG, C++23, tentatively-ready-for-plenary, lwg-fullreview, plenary-approved

** [[https://wg21.link/P2599][P2599]] mdspan::size_type should be index_type (Nevin Liber)
#+begin_quote
With the adoption of P2553R1, ~mdspan::size_type~ may now be a signed type.
~size_type~ is no longer an appropriate name for this type and it should be changed to ~index_type~.
#+end_quote

LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, mdspan

** [[https://wg21.link/p2602][P2602]] Poison Pills are Too Toxic (Barry Revzin)
Given the following declarations:

#+begin_src c++
struct A {
    friend auto begin(A const&) -> int const*;
    friend auto end(A const&)   -> int const*;
};

struct B {
    friend auto begin(B&) -> int*;
    friend auto end(B&) -> int*;
};
#+end_src

B and const A satisfy std::ranges::range, but A does not. The goal of this paper is that both of these should count as ranges.

LWG, ranges, C++23, IS, B2 - improvement, size - small, plenary-approved

** [[https://wg21.link/P2604][P2604]] mdspan: rename pointer and contiguous (Christian Trott)
#+begin_quote
During LWG review a few members of classes in the mdspan proposals were identified as problematic, this paper proposes renaming those members.
#+end_quote

*** ~pointer~ to ~data_handle_type~
*** ~data()~ to ~data_handle()~
*** ~contiguous~ to ~exhaustive~

LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, mdspan

** [[https://wg21.link/p2609][P2609]] Relaxing Ranges Just A Smidge (John Eivind Helset)
#+begin_quote
Ranges algorithms that take a function and a projection should, in the unary case, constrain the function to enable:
#+end_quote

#+begin_src c++
iter_value_t<It> x = *it;
f(proj(x));
#+end_src

#+begin_quote
Instead they are constrained to allow:
#+end_quote

#+begin_src c++
iter_value_t<projected<I,Proj>> u = proj(*it);
f(u);
#+end_src

#+begin_quote
And likewise in the binary case. This is caused by the composition of indirect callable concepts with projected, seen for example in the constraints of ranges::for_each as indirect_unary_invocable<projected<I,P>>.

A fix is proposed that introduces a type-trait and makes a slight change to the definitions of the indirect callable concepts, as well as iter_common_reference_t. The fix is a slight relaxation of the algorithmic constraints in ranges that does not break ABI.
#+end_quote

LWG, ranges, C++23, IS, B2 - improvement, size - small, plenary-approved

** [[https://wg21.link/p2613][P2613]] Add the missing =empty= to =mdspan= (Yihe Le)
#+begin_quote
This paper propose to fix a defect in [P0009R17]. During its LWG review, I found that even though the proposed std::mdspan type have a size() member function, it does not have an empty() member function, which makes it distinct from nearly all other STL containers. So this paper propose to add the missing member to increase consistency and performance of common operations.
#+end_quote

LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, mdspan

** [[https://wg21.link/p2614][P2614]] Deprecate numeric_limits::has_denorm (Matthias Kretz)
#+begin_quote
Since C is intent on obsoleting the ~*_HAS_SUBNORM~ macros, we should consider
the analogue change in C++: the deprecation of ~numeric_limits::has_denorm~. In
general, compile-time constants that describe floating-point behavior are
problematic, since behavior might change at runtime. Let‚Äôs also deprecate
~numeric_limits::has_denorm_loss~ while we‚Äôre at it.
#+end_quote
LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved

** [[https://wg21.link/p2644][P2644]] Get Fix of Broken Range-based for Loop Finally Done (Nicolai Josuttis)
#+begin_quote
This paper summarizes the fix for the still open issues cwg900, cwg1498,
ewg120. The issue is a bug that is 13 years old now, applies to one of the most
important control structures of Modern C++, and leads to confusion and
ill-formed programs due to unexpected undefined behavior and effort for
teaching and training.
#+end_quote


|                                                    | Before | After |
|----------------------------------------------------+--------+-------|
| ~for (auto e : getTmp().getRef())~                 | BROKEN | OK    |
| ~for (auto e : getVector()[0])~                    | BROKEN | OK    |
| ~for (auto valueElem : getMap()["key"])~           | BROKEN | OK    |
| ~for (auto e : get<0>(getTuple()))~                | BROKEN | OK    |
| ~for (auto e : getOptionalColl().value())~         | BROKEN | OK    |
| ~for (char c : get<string>(getVariant()))~         | BROKEN | OK    |
| ~for (auto s : std::span{arrOfConst()}.last(2))~   | BROKEN | OK    |
| ~for (auto e : std::span(getVector().data(), 2))~  | BROKEN | OK    |
| ~for (auto e: co_await coroReturningRef())~        | BROKEN | OK    |
| ~// assume getValue() returns value by reference:~ |        |       |
| ~for (char c : getData().value)~                   | OK     | OK    |
| ~for (char c : getData().getValue())~              | BROKEN | OK    |

CWG, C++23, plenary-approved

** [[https://wg21.link/p2652][P2652]] Disallow user specialization of allocator_traits (Pablo Halpern)
#+begin_quote
The allocator_traits class template was introduced in C++11 with two goals in mind:

1. Provide default implementations for allocator types and operations, thus minimizing the requirements on allocators [allocator.requirements], and

2. provide a mechanism by which future standards could extend the allocator interface without changing allocator requirements and thus obsoleting existing allocators.

The latter goal is undermined, however, by the standard currently allowing
user-defined specializations of std::allocator_traits. Although the standard
requires that any such specialization conform to the standard interface, it is
not practical to change the standard interface ‚Äì even by extending it ‚Äì without
breaking any existing user specializations. Indeed, the Sep 2022 C++23 CD,
N4919 contains an extension, allocate_at_least, that logically belongs in
std:::allocator_traits, but is expressed as an unrelated function because of
the problem of potential user-defined specializations.

This paper proposes that the standard remove the user‚Äôs latitude for specializing std::allocator_traits.

This paper is the proposed resolution to a US NB comment having the same title; it is targeted for C++23.
#+end_quote
LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved

** [[https://wg21.link/p2655][P2655]] common_reference_t of reference_wrapper Should Be a Reference Type (Hui Xie, S. Levent Yilmaz)
#+begin_quote
This paper proposes a fix that makes the ~common_reference_t<T&,reference_wrapper<T>>~ a reference type ~T&~.
#+end_quote

*** Before
#+begin_src c++
static_assert(same_as<
              common_reference_t<int&, reference_wrapper<int>>,
              int>);

static_assert(same_as<
              common_reference_t<int&, reference_wrapper<int>&>,
              int>);

static_assert(same_as<
              common_reference_t<int&, const reference_wrapper<int>&>,
              const int&>);
#+end_src

*** After
#+begin_src c++
static_assert(same_as<
              common_reference_t<int&, reference_wrapper<int>>,
              int&>);

static_assert(same_as<
              common_reference_t<int&, reference_wrapper<int>&>,
              int&>);

static_assert(same_as<
              common_reference_t<int&, const reference_wrapper<int>&>,
              int&>);
#+end_src
LWG, C++23, IS, B2 - improvement, size - small, plenary-approved

** [[https://wg21.link/p2674][P2674]] A trait for implicit lifetime types (Timur Doumler, Vittorio Romeo)
#+begin_quote
C++20 introduced the notion of implicit-lifetime types. There are certain
operations that are only valid for such types. We therefore need a way to check
whether a type is implicit-lifetime, and constrain on this property. This paper
proposes a new type trait std::is_implicit_lifetime to achieve this.
#+end_quote


LWG, C++23, tentatively-ready-for-plenary, IS, B3 - addition, size - small, plenary-approved

** [[https://wg21.link/p2675][P2675]] LWG3780: The Paper
format's width estimation is too approximate and not forward compatible

#+begin_quote
LWG3780 describes an issue with width in std::format estimation. This paper
offers more information
#+end_quote

LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved, format

** [[https://wg21.link/p2679][P2679]] Fixing std::start_lifetime_as for arrays (Timur Doumler, Arthur O'Dwyer, Richard Smith)
#+begin_quote
std::start_lifetime_as and std::start_lifetime_as_array, facilities to
explicitly start the lifetime of an object of implicit-lifetime type inside a
block of suitably aligned storage, was introduced in [P2590R2] and voted into
C++23. We propose to fix some remaining issues before C++23 ships. We also
discuss possible changes to the API that were considered but rejected.
#+end_quote

CWG, LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved

** [[https://wg21.link/P2693][P2693]] Formatting thread::id and stacktrace (Corentin Jabot, Victor Zverovich)
#+begin_quote
This paper provides wording in reply to NB comments suggesting to adopt P1636R2
(Formatters for library types) and to add formatters for std::stacktrace.
#+end_quote

LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - medium, plenary-approved, format

** [[https://wg21.link/P2711][P2711]] Ruminations on explicit multi-param constructors of views (Ville Voutilainen)
#+begin_quote
This paper is about LWG 3714, Non-single-argument constructors for range adaptors should not be explicit.

We have C++20 views, none of which have explicit multi-param constructors, and some newer C++23 views which do. This is an obscure and rarely-noticeable difference. This paper looks at some aspects of it.
#+end_quote
LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - medium, plenary-approved

** [[https://wg21.link/p2713][P2713]] Escaping improvements in std::format (Victor Zverovich)
#+begin_quote
This paper provides wording for the resolution of national body comments [US38-098] and [FR005-134] per direction voted in SG16 Unicode and LEWG.
#+end_quote

LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size -small, plenary-approved, format

** [[https://wg21.link/p2736][P2736]] Referencing the Unicode Standard (Corentin Jabot)
#+begin_quote
We propose to reference The Unicode Standard instead of ISO 10646. This
proposal has no impact on implementations. This resolves NB comments FR-010-133
and FR-021-013
#+end_quote

CWG, LWG, C++23, nb-comment, plenary-approved

** [[https://wg21.link/p2763][P2763]] =layout_stride= static extents default constructor fix (Christian Trott, Damien Lebrun-Gran...
#+begin_quote
During work on the padded layouts project an oversight in the layout_stride definition was discovered for a corner case. Specifically, the default constructor of a layout_stride with fully static extents will produce an invalid mapping.
#+end_quote

LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size-small, plenary-approved, mdspan

** [[https://wg21.link/p2770][P2770]] Stashing stashing iterators for proper flattening (Tim Song)
#+begin_quote
This paper provides wording to resolve [LWG3698], [LWG3700], [LWG3791], and NB comment US 61-126.
#+end_quote

LWG, C++23, plenary-approved

** [[https://wg21.link/p2787][P2787]] =pmr::generator= - Promise Types are not Values (Steve Downey)
#+begin_quote
The type returned from a coroutine is not a value semantic container. It
nonetheless can satisfy the requirements for supporting pmr generators. It is
useful to provide a pmr alias to make the requirement to use pmr allocators
visible in the typesystem
#+end_quote

*** Before
#+begin_src c++
std::pmr::monotonic_buffer_resource                          mbr;
std::pmr::polymorphic_allocator<>                            pa{&mbr};
std::generator<int, void, std::pmr::polymorphic_allocator<>> g =
    pmr_requiring_coroutine(std::allocator_arg, pa);
#+end_src

*** After
#+begin_src c++
std::pmr::monotonic_buffer_resource mbr;
std::pmr::polymorphic_allocator<>   pa{&mbr};

std::pmr::generator<int> g = pmr_requiring_coroutine(std::allocator_arg, pa);
#+end_src

LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved

** [[https://wg21.link/p2788][P2788]] Linkage for modular constants (S. Davis Herring)
#+begin_quote
National body comment US 8-036 points out an unfortunate interaction between C++98 linkage rules and C++20 modules. This paper explains the interaction in more detail, motivates a choice among the suggestions offered by the comment, and provides wording for that choice.
#+end_quote

** [[https://wg21.link/p2789][P2789]] C++ Standard Library Ready Issues to be moved in Issaquah, Feb.¬†2023 (Jonathan Wakely)
LWG, info, C++23, plenary-approved

** [[https://wg21.link/p2790][P2790]] C++ Standard Library Immediate Issues to be moved in Issaquah, Feb.¬†2023 (Jonathan Wakely)
LWG, info, C++23, plenary-approved

** [[https://wg21.link/p2796][P2796]] Core Language Working Group "ready" Issues for the February, 2023 meeting (Jens Maurer)
CWG, C++23, plenary-approved

** [[https://wg21.link/p2797][P2797]] Proposed resolution for CWG2692 Static and explicit object member functions with the same parameter-type-lists (Ga≈°per A≈æman, Barry Revzin)
#+begin_quote
This document proposes a resolution to [CWG2692]. This also touches the proposed resolution to [CWG2687].
#+end_quote


CWG, C++23, plenary-approved
