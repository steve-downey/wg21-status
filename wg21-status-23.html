<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>C++ 23 Status Report</title>
<meta name="author" content="Steve Downey"/>
<meta name="description" content="
"/>
<meta name="keywords" content=" "/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="./my_theme.css" id="theme"/>

<link rel="stylesheet" href="./vivendi-tinted.css"/>

<link rel="stylesheet" href="./footer.css"/>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<link rel="stylesheet" type="text/css" href="./vivendi-tinted.css" />
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide" data-background="./C++23_new.png">

</section>


<section>
<section id="slide-orgc6bc33c">
<h2 id="orgc6bc33c">C++ 23 Status Report</h2>
<p>
This is a summary of what was approved for C++23.
</p>

<p>
All of the quoted text and example code is from the papers linked in the headings by the authors of the papers.
</p>

<p>
I've selected text to describe the purpose of the paper, usually quoting the abstract, and taking illustritive code that the paper provides to show the intent. Please see the linked papers for details.
</p>

<p>
The "Major" Section is my judgement, influenced by a few friends, about what I thought was most interesting or important in C++ 23.
</p>


</section>
</section>
<section>
<section id="slide-orgc7271e3">
<h2 id="orgc7271e3">Major (in my opinion)</h2>
<ul>
<li>11 papers total</li>

</ul>

</section>
</section>
<section>
<section id="slide-p2644-get-fix-of-broken-range-based-for-loop-finally-done-nicolai-josuttis">
<h4 id="p2644-get-fix-of-broken-range-based-for-loop-finally-done-nicolai-josuttis"><a href="https://wg21.link/p2644">P2644</a> Get Fix of Broken Range-based for Loop Finally Done (Nicolai Josuttis)</h4>
<blockquote>
<p>
This paper summarizes the fix for the still open issues cwg900, cwg1498,
ewg120. The issue is a bug that is 13 years old now, applies to one of the most
important control structures of Modern C++, and leads to confusion and
ill-formed programs due to unexpected undefined behavior and effort for
teaching and training.
</p>
</blockquote>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Before</th>
<th scope="col" class="org-left">After</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>for (auto e : getTmp().getRef())</code></td>
<td class="org-left">BROKEN</td>
<td class="org-left">OK</td>
</tr>

<tr>
<td class="org-left"><code>for (auto e : getVector()[0])</code></td>
<td class="org-left">BROKEN</td>
<td class="org-left">OK</td>
</tr>

<tr>
<td class="org-left"><code>for (auto valueElem : getMap()["key"])</code></td>
<td class="org-left">BROKEN</td>
<td class="org-left">OK</td>
</tr>

<tr>
<td class="org-left"><code>for (auto e : get&lt;0&gt;(getTuple()))</code></td>
<td class="org-left">BROKEN</td>
<td class="org-left">OK</td>
</tr>

<tr>
<td class="org-left"><code>for (auto e : getOptionalColl().value())</code></td>
<td class="org-left">BROKEN</td>
<td class="org-left">OK</td>
</tr>

<tr>
<td class="org-left"><code>for (char c : get&lt;string&gt;(getVariant()))</code></td>
<td class="org-left">BROKEN</td>
<td class="org-left">OK</td>
</tr>

<tr>
<td class="org-left"><code>for (auto s : std::span{arrOfConst()}.last(2))</code></td>
<td class="org-left">BROKEN</td>
<td class="org-left">OK</td>
</tr>

<tr>
<td class="org-left"><code>for (auto e : std::span(getVector().data(), 2))</code></td>
<td class="org-left">BROKEN</td>
<td class="org-left">OK</td>
</tr>

<tr>
<td class="org-left"><code>for (auto e: co_await coroReturningRef())</code></td>
<td class="org-left">BROKEN</td>
<td class="org-left">OK</td>
</tr>

<tr>
<td class="org-left"><code>// assume getValue() returns value by reference:</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>for (char c : getData().value)</code></td>
<td class="org-left">OK</td>
<td class="org-left">OK</td>
</tr>

<tr>
<td class="org-left"><code>for (char c : getData().getValue())</code></td>
<td class="org-left">BROKEN</td>
<td class="org-left">OK</td>
</tr>
</tbody>
</table>

<p>
tags: CWG, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p0323-stdexpected-vicente-botet-jf-bastien">
<h4 id="p0323-stdexpected-vicente-botet-jf-bastien"><a href="https://wg21.link/p0323">P0323</a> <code>std::expected</code> (Vicente Botet, JF Bastien, Jonathan Wakely)</h4>
<blockquote>
<p>
Class template <code>expected&lt;T, E&gt;</code> is a vocabulary type which contains an expected value of type <code>T</code>, or an error <code>E</code>. The class skews towards behaving like a <code>T</code>, because its intended use is when the expected type is contained. When something unexpected occurs, more typing is required. When all is good, code mostly looks as if a <code>T</code> were being handled.
</p>
</blockquote>
<p>
tags: LWG, C++23, IS, B3 - addition, size - large, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p0798r2-monadic-operations-for-stdoptional-simon-brand">
<h4 id="p0798r2-monadic-operations-for-stdoptional-simon-brand"><a href="https://wg21.link/p0798">P0798</a> Monadic operations for std::optional (Sy Brand)</h4>
<blockquote>
<p>
std::optional will be a very important vocabulary type in C++17 and up. Some uses of it can be very verbose and would benefit from operations which allow functional composition. I propose adding map, and_then, and or_else member functions to std::optional to support this monadic style of programming.
</p>
</blockquote>
</section>
</section>
<section>
<section id="slide-orgebfb1fb">
<h5 id="orgebfb1fb">Example</h5>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">optional</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">image</span>&gt; <span style="color: #feacd0;">get_cute_cat</span>(<span style="color: #b6a0ff; font-weight: bold;">const</span> <span style="color: #6ae4b9; font-weight: bold;">image</span>&amp; <span style="color: #00d3d0;">img</span>) {
    <span style="color: #b6a0ff; font-weight: bold;">return</span> crop_to_cat(img)
        .and_then(add_bow_tie)
        .and_then(make_eyes_sparkle)
        .map(make_smaller)
        .map(add_rainbow);
}
</pre>
</div>
</section>
</section>
<section>
<section id="slide-orgef85116">
<h5 id="orgef85116">Quote</h5>
<blockquote>
<p>
Here is a list of programming languages which have a optional-like type without a monadic interface or syntactic sugar:
</p>

<ul>
<li>C++</li>

<li>I couldn’t find any others</li>

</ul>
</blockquote>
</section>
</section>
<section>
<section id="slide-orgaa903f4">
<h5 id="orgaa903f4">Monadic interface</h5>
<dl>
<dt>map</dt><dd><code>map</code> applies a function to the value stored in the optional and returns the result wrapped in an optional. If there is no stored value, then it returns an empty optional.</dd>
<dt>and_then</dt><dd><code>and_then</code> is like map, but it is used on functions which may not return a value.</dd>
<dt>or_else</dt><dd><code>or_else</code> returns the optional if it has a value, otherwise it calls a given function. This allows you do things like logging or throwing exceptions in monadic contexts:</dd>

</dl>


<p>
tags: LWG, SG14, C++23, IS, size - small, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p0847-deducing-this-gašper-ažman-simon-brand-ben-deane-barry-revzin">
<h4 id="p0847-deducing-this-gašper-ažman-simon-brand-ben-deane-barry-revzin"><a href="https://wg21.link/p0847">P0847</a> Deducing this (Gašper Ažman, Sy Brand, Ben Deane, Barry Revzin)</h4>
<blockquote>
<p>
We propose a new mechanism for specifying or deducing the value category of an instance of a class — in other words, a way to tell from within a member function whether the object it’s invoked on is an lvalue or an rvalue; whether it is const or volatile; and the object’s type.
</p>
</blockquote>

<blockquote>
<p>
A non-static member function can be declared to take as its first parameter an explicit object parameter, denoted with the prefixed keyword this. Once we elevate the object parameter to a proper function parameter, it can be deduced following normal function template deduction rules:
</p>
</blockquote>

</section>
</section>
<section>
<section id="slide-org467b88d">
<h5 id="org467b88d">Example</h5>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">struct</span> <span style="color: #6ae4b9; font-weight: bold;">X</span> {
    <span style="color: #6ae4b9; font-weight: bold;">void</span> <span style="color: #00d3d0;">foo</span>(<span style="color: #b6a0ff; font-weight: bold;">this</span> X <span style="color: #b6a0ff; font-weight: bold;">const</span>&amp; self, <span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #00d3d0;">i</span>);

    <span style="color: #b6a0ff; font-weight: bold;">template</span> &lt;<span style="color: #b6a0ff; font-weight: bold;">typename</span> <span style="color: #6ae4b9; font-weight: bold;">Self</span>&gt;
    <span style="color: #6ae4b9; font-weight: bold;">void</span> <span style="color: #00d3d0;">bar</span>(<span style="color: #b6a0ff; font-weight: bold;">this</span> Self&amp;&amp; self);
};

<span style="color: #b6a0ff; font-weight: bold;">struct</span> <span style="color: #6ae4b9; font-weight: bold;">D</span> : <span style="color: #6ae4b9; font-weight: bold;">X</span> {};

<span style="color: #6ae4b9; font-weight: bold;">void</span> <span style="color: #feacd0;">ex</span>(<span style="color: #6ae4b9; font-weight: bold;">X</span>&amp; <span style="color: #00d3d0;">x</span>, <span style="color: #6ae4b9; font-weight: bold;">D</span> <span style="color: #b6a0ff; font-weight: bold;">const</span>&amp; <span style="color: #00d3d0;">d</span>) {
    x.foo(42);     <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">'self' is bound to 'x', 'i' is 42</span>
    x.bar();       <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">deduces Self as X&amp;, calls X::bar&lt;X&amp;&gt;</span>
    move(x).bar(); <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">deduces Self as X, calls X::bar&lt;X&gt;</span>

    d.foo(17); <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">'self' is bound to 'd'</span>
    d.bar();   <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">deduces Self as D const&amp;, calls X::bar&lt;D const&amp;&gt;</span>
}
</pre>
</div>

</section>
</section>
<section>
<section id="slide-org7355a84">
<h5 id="org7355a84">Example</h5>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #6ae4b9; font-weight: bold;">vector</span> <span style="color: #00d3d0;">captured</span> = {1, 2, 3, 4};
[<span style="color: #00bcff;">captured</span>](<span style="color: #b6a0ff; font-weight: bold;">this</span> <span style="color: #b6a0ff; font-weight: bold;">auto</span>&amp;&amp; self) -&gt; <span style="color: #b6a0ff; font-weight: bold;">decltype</span>(<span style="color: #b6a0ff; font-weight: bold;">auto</span>) {
  <span style="color: #b6a0ff; font-weight: bold;">return</span> forward_like&lt;<span style="color: #b6a0ff; font-weight: bold;">decltype</span>(self)&gt;(captured);
}

[<span style="color: #00bcff;">captured</span>]&lt;<span style="color: #b6a0ff; font-weight: bold;">class</span> <span style="color: #6ae4b9; font-weight: bold;">Self</span>&gt;(<span style="color: #b6a0ff; font-weight: bold;">this</span> Self&amp;&amp; self) -&gt; <span style="color: #b6a0ff; font-weight: bold;">decltype</span>(<span style="color: #b6a0ff; font-weight: bold;">auto</span>) {
  <span style="color: #b6a0ff; font-weight: bold;">return</span> forward_like&lt;<span style="color: #6ae4b9; font-weight: bold;">Self</span>&gt;(captured);
}
</pre>
</div>


<p>
tags: CWG, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p1132r2-out_ptr---a-scalable-output-pointer-abstraction-jeanheyd-meneide-todor-buyukliev-isabell">
<h4 id="p1132r2-out_ptr---a-scalable-output-pointer-abstraction-jeanheyd-meneide-todor-buyukliev-isabell"><a href="https://wg21.link/p1132">P1132</a> out_ptr - a scalable output pointer abstraction (JeanHeyd Meneide, Todor Buyukliev, Isabella Muerte)</h4>
<blockquote>
<p>
out_ptr is an abstraction to bring both C APIs and smart pointers back into the promised land by creating a temporary pointer-to-pointer that updates the smart pointer when it destructs.
</p>
</blockquote>
<ul class="org-ul">
<li><a id="org6d4bfc9"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #6ae4b9; font-weight: bold;">error_num</span> <span style="color: #feacd0;">c_api_create_handle</span>(<span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #00d3d0;">seed_value</span>, <span style="color: #6ae4b9; font-weight: bold;">int</span>** <span style="color: #00d3d0;">p_handle</span>);
<span style="color: #6ae4b9; font-weight: bold;">void</span>      <span style="color: #feacd0;">c_api_delete_handle</span>(<span style="color: #6ae4b9; font-weight: bold;">int</span>* <span style="color: #00d3d0;">handle</span>);

<span style="color: #b6a0ff; font-weight: bold;">struct</span> <span style="color: #6ae4b9; font-weight: bold;">resource_deleter</span> {
    <span style="color: #6ae4b9; font-weight: bold;">void</span> <span style="color: #b6a0ff; font-weight: bold;">operator</span><span style="color: #feacd0;">()</span>(<span style="color: #6ae4b9; font-weight: bold;">int</span>* <span style="color: #00d3d0;">handle</span>) { c_api_delete_handle(handle); }
};

<span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">unique_ptr</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>, <span style="color: #6ae4b9; font-weight: bold;">resource_deleter</span>&gt; <span style="color: #00d3d0;">resource</span>(<span style="color: #00bcff;">nullptr</span>);
<span style="color: #6ae4b9; font-weight: bold;">error_num</span> <span style="color: #00d3d0;">err</span> = c_api_create_handle(24, <span style="color: #00bcff;">std</span>::out_ptr(resource));
<span style="color: #b6a0ff; font-weight: bold;">if</span> (err == C_API_ERROR_CONDITION) {
    <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">handle errors</span>
}
<span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">resource.get() the out-value from the C API function</span>
</pre>
</div>
<p>
tags: LWG, C++23, IS, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p1206r1-rangesto-a-function-to-convert-any-range-to-a-container-corentin-jabot-eric-niebler-c">
<h4 id="p1206r1-rangesto-a-function-to-convert-any-range-to-a-container-corentin-jabot-eric-niebler-c"><a href="https://wg21.link/p1206">P1206</a> ranges::to: A function to convert any range to a container (Corentin Jabot, Eric Niebler, Casey Carter)</h4>
<blockquote>
<p>
We propose a function to copy or materialize any range (containers and views alike) to a container.
</p>
</blockquote>
</section>
</section>
<section>
<section id="slide-org41db469">
<h5 id="org41db469">Before/After Table</h5>
<p>
Before:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">map</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>, widget&gt;                           <span style="color: #00d3d0;">map</span> = get_widgets_map();
<span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">vector</span>&lt;<span style="color: #b6a0ff; font-weight: bold;">typename</span> <span style="color: #b6a0ff; font-weight: bold;">decltype</span>(map)::value_type&gt; <span style="color: #00d3d0;">vec</span>;
vec.reserve(map.size());
<span style="color: #00bcff;">ranges</span>::move(map, <span style="color: #00bcff;">std</span>::back_inserter(vec));
</pre>
</div>
<p>
After:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">vec</span> = get_widgets_map() | <span style="color: #00bcff;">ranges</span>::<span style="color: #6ae4b9; font-weight: bold;">to</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">vector</span>&gt;
</pre>
</div>
<p>
tags: LWG, ranges, C++23, IS, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2286-formatting-ranges-barry-revzin">
<h4 id="p2286-formatting-ranges-barry-revzin"><a href="https://wg21.link/p2286">P2286</a> Formatting Ranges (Barry Revzin)</h4>
<blockquote>
<p>
[LWG3478] addresses the issue of what happens when you split a string and the last character in the string is the delimiter that you are splitting on. One of the things I wanted to look at in research in that issue is: what do other languages do here?
</p>

<p>
For most languages, this is a pretty easy proposition. Do the split, print the results. This is usually only a few lines of code.
</p>
</blockquote>
</section>
</section>
<section>
<section id="slide-org4dbd58d">
<h5 id="org4dbd58d">Python</h5>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #f78fe7; font-weight: bold;">print</span>(<span style="color: #79a8ff;">"xyx"</span>.split(<span style="color: #79a8ff;">"x"</span>))
</pre>
</div>

<pre class="example" id="org7578668">
['', 'y', '']
</pre>

</section>
</section>
<section>
<section id="slide-org8ede94b">
<h5 id="org8ede94b">Java</h5>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b6a0ff; font-weight: bold;">import</span> <span style="color: #00bcff;">java</span>.<span style="color: #00bcff;">util</span>.<span style="color: #6ae4b9; font-weight: bold;">Arrays</span>;

<span style="color: #b6a0ff; font-weight: bold;">class</span> <span style="color: #6ae4b9; font-weight: bold;">Main</span> {
  <span style="color: #b6a0ff; font-weight: bold;">public</span> <span style="color: #b6a0ff; font-weight: bold;">static</span> <span style="color: #6ae4b9; font-weight: bold;">void</span> <span style="color: #feacd0;">main</span>(<span style="color: #6ae4b9; font-weight: bold;">String</span> <span style="color: #00d3d0;">args</span>[]) {
    System.out.println(<span style="color: #79a8ff;">"xyx"</span>.split(<span style="color: #79a8ff;">"x"</span>));
    System.out.println(Arrays.toString(<span style="color: #79a8ff;">"xyx"</span>.split(<span style="color: #79a8ff;">"x"</span>)));
  }
}
</pre>
</div>

<pre class="example" id="orge64603f">
[Ljava.lang.String;@76ed5528
[, y]
</pre>
</section>
</section>
<section>
<section id="slide-orgda5af3c">
<h5 id="orgda5af3c">rust</h5>
<div class="org-src-container">

<pre class="src src-rust"><span style="color: #b6a0ff; font-weight: bold;">use</span> <span style="color: #00bcff;">itertools</span>::<span style="color: #6ae4b9; font-weight: bold;">Itertools</span>;

<span style="color: #b6a0ff; font-weight: bold;">fn</span> <span style="color: #feacd0;">main</span>() {
    <span style="color: #f78fe7; font-weight: bold;">println!</span>(<span style="color: #79a8ff;">"</span><span style="color: #79a8ff; font-style: italic;">{:?}</span><span style="color: #79a8ff;">"</span>, <span style="color: #79a8ff;">"xyx"</span>.split(<span style="color: #79a8ff;">'x'</span>));
    <span style="color: #f78fe7; font-weight: bold;">println!</span>(<span style="color: #79a8ff;">"[</span><span style="color: #79a8ff; font-style: italic;">{}</span><span style="color: #79a8ff;">]"</span>, <span style="color: #79a8ff;">"xyx"</span>.split(<span style="color: #79a8ff;">'x'</span>).format(<span style="color: #79a8ff;">", "</span>));
    <span style="color: #f78fe7; font-weight: bold;">println!</span>(<span style="color: #79a8ff;">"</span><span style="color: #79a8ff; font-style: italic;">{:?}</span><span style="color: #79a8ff;">"</span>, <span style="color: #79a8ff;">"xyx"</span>.split(<span style="color: #79a8ff;">'x'</span>).collect::&lt;<span style="color: #6ae4b9; font-weight: bold;">Vec</span>&lt;_&gt;&gt;());
}
</pre>
</div>

<pre class="example" id="orgd8131f9">
Split(SplitInternal { start: 0, end: 3, matcher: CharSearcher { haystack: "xyx", finger: 0, finger_back: 3, needle: 'x', utf8_size: 1, utf8_encoded: [120, 0, 0, 0] }, allow_trailing_empty: true, finished: false })
[, y, ]
["", "y", ""]
</pre>

</section>
</section>
<section>
<section id="slide-orgbfd4675">
<h5 id="orgbfd4675">C++</h5>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ff7f9f;">#include</span> <span style="color: #79a8ff;">&lt;iostream&gt;</span>
<span style="color: #ff7f9f;">#include</span> <span style="color: #79a8ff;">&lt;string&gt;</span>
<span style="color: #ff7f9f;">#include</span> <span style="color: #79a8ff;">&lt;ranges&gt;</span>

<span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #feacd0;">main</span>() {
    <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">need to predeclare this because we can't split an rvalue string</span>
    <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">string</span> <span style="color: #00d3d0;">s</span>     = <span style="color: #79a8ff;">"xyx"</span>;
    <span style="color: #b6a0ff; font-weight: bold;">auto</span>        <span style="color: #00d3d0;">parts</span> = s | <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">views</span>::split(<span style="color: #79a8ff;">'x'</span>);

    <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"["</span>;
    <span style="color: #6ae4b9; font-weight: bold;">char</span> <span style="color: #b6a0ff; font-weight: bold;">const</span>* <span style="color: #00d3d0;">delim</span> = <span style="color: #79a8ff;">""</span>;
    <span style="color: #b6a0ff; font-weight: bold;">for</span> (<span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">part</span> : parts) {
        <span style="color: #00bcff;">std</span>::cout &lt;&lt; delim;
        <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">this finally works</span>
        <span style="color: #b6a0ff; font-weight: bold;">for</span> (<span style="color: #6ae4b9; font-weight: bold;">char</span> <span style="color: #00d3d0;">c</span> : part) {
            <span style="color: #00bcff;">std</span>::cout &lt;&lt; c;
        }
        delim = <span style="color: #79a8ff;">", "</span>;
    }
    <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"]\n"</span>;
}
</pre>
</div>
<pre class="example" id="orgfe2db7e">
[, y, ]
</pre>
</section>
</section>
<section>
<section id="slide-orgd5c2d94">
<h5 id="orgd5c2d94">lib fmt</h5>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ff7f9f;">#include</span> <span style="color: #79a8ff;">&lt;ranges&gt;</span>
<span style="color: #ff7f9f;">#include</span> <span style="color: #79a8ff;">&lt;string&gt;</span>
<span style="color: #ff7f9f;">#include</span> <span style="color: #79a8ff;">&lt;fmt/ranges.h&gt;</span>

<span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #feacd0;">main</span>() {
    <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">string</span> <span style="color: #00d3d0;">s</span> = <span style="color: #79a8ff;">"xyx"</span>;
    <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">parts</span> = s | <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">views</span>::split(<span style="color: #79a8ff;">'x'</span>);

    <span style="color: #00bcff;">fmt</span>::print(<span style="color: #79a8ff;">"{}\n"</span>, parts);
    <span style="color: #00bcff;">fmt</span>::print(<span style="color: #79a8ff;">"&lt;&lt;{}&gt;&gt;\n"</span>, <span style="color: #00bcff;">fmt</span>::join(parts, <span style="color: #79a8ff;">"--"</span>));
}
</pre>
</div>
<pre class="example" id="org9355824">
[[], ['y'], []]
&lt;&lt;[]--['y']--[]&gt;&gt;
</pre>

<p>
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2465-standard-library-modules-std-and-std.all-stephan-t.-lavavej-gabriel-dos-reis-bjarne-stro">
<h4 id="p2465-standard-library-modules-std-and-std.all-stephan-t.-lavavej-gabriel-dos-reis-bjarne-stro"><a href="https://wg21.link/p2412">P2465</a> Standard Library Modules std and std.all (Stephan T. Lavavej, Gabriel Dos Reis, Bjarne Stroustrup, Jonathan Wakely)</h4>
<blockquote>
<p>
Header files are a major source of complexity, errors caused by dependencies, and slow compilation.
Modules address all three problems, but are currently hard to use because the standard library is not
offered in a module form. This note presents logical arguments and a few measurements that
demonstrates that <b>import std</b> of a module <b>std</b> presenting all of the standard library can compile many
times faster than plain old <b>#include &lt;iostream&gt;</b>.
</p>
</blockquote>
</section>
</section>
<section>
<section id="slide-org4aff221">
<h5 id="org4aff221">As adopted</h5>
<blockquote>
<p>
This paper provides Standardese for two named modules: <code>std</code> and <code>std.compat</code>.
</p>

<p>
<code>import std;</code> imports everything in namespace std from C++ headers (e.g.
<code>std::sort</code> from <code>&lt;algorithm&gt;</code>) and C wrapper headers (e.g. <code>std::fopen</code> from
<code>&lt;cstdio&gt;</code>). It also imports <code>::operator new</code> etc. from <code>&lt;new&gt;</code>.
</p>

<p>
<code>import std.compat;</code> imports all of the above, plus the global namespace
counterparts for the C wrapper headers (e.g. <code>::fopen</code>).
</p>
</blockquote>

<p>
tags: CWG, LWG, straw-poll, C++23, tentatively-ready-for-plenary, IS, modular-standard-library, size - large, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2093-formatted-output-victor-zverovich">
<h4 id="p2093-formatted-output-victor-zverovich"><a href="https://wg21.link/p2093">P2093</a> Formatted output (Victor Zverovich)</h4>
<blockquote>
<p>

</p>

<p>
A new I/O-agnostic text formatting library was introduced in C++20 ([FORMAT]). This paper proposes integrating it with standard I/O facilities via a simple and intuitive API achieving the following goals:
</p>

<ul>
<li>Usability</li>

<li>Unicode support</li>

<li>Good performance</li>

<li>Small binary footprint</li>

</ul>
</blockquote>
</section>
</section>
<section>
<section id="slide-orga2dc875">
<h5 id="orga2dc875">Before/After Table</h5>
<div class="outline-text-5" id="text-orga2dc875">
</div>
<ul class="org-ul">
<li><a id="orge285589"></a>Before:<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #00bcff;">std</span>::format(<span style="color: #79a8ff;">"Hello, {}!"</span>, name);
</pre>
</div>
</li>
<li><a id="org7e0b0c3"></a>After:<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::print(<span style="color: #79a8ff;">"Hello, {}!"</span>, name);
</pre>
</div>
<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2128-multidimensional-subscript-operator-corentin-jabot-isabella-muerte-daisy-hollman-christ">
<h4 id="p2128-multidimensional-subscript-operator-corentin-jabot-isabella-muerte-daisy-hollman-christ"><a href="https://wg21.link/p2128">P2128</a> Multidimensional subscript operator (Corentin Jabot, Isabella Muerte, Daisy Hollman, Christian Trott, Mark Hoemmen)</h4>
<blockquote>
<p>
We propose that user-defined types can define a subscript operator with multiple arguments
to better support multi-dimensional containers and views.
</p>
</blockquote>
</section>
</section>
<section>
<section id="slide-org0c748ce">
<h5 id="org0c748ce">Before</h5>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">template</span> &lt;<span style="color: #b6a0ff; font-weight: bold;">class</span> <span style="color: #6ae4b9; font-weight: bold;">ElementType</span>, <span style="color: #b6a0ff; font-weight: bold;">class</span> <span style="color: #6ae4b9; font-weight: bold;">Extents</span>&gt;
<span style="color: #b6a0ff; font-weight: bold;">class</span> <span style="color: #6ae4b9; font-weight: bold;">mdspan</span> {
    <span style="color: #b6a0ff; font-weight: bold;">template</span> &lt;<span style="color: #b6a0ff; font-weight: bold;">class</span><span style="color: #feacd0;">...</span> <span style="color: #6ae4b9; font-weight: bold;">IndexType</span>&gt;
    <span style="color: #b6a0ff; font-weight: bold;">constexpr</span> <span style="color: #6ae4b9; font-weight: bold;">reference</span> <span style="color: #b6a0ff; font-weight: bold;">operator</span><span style="color: #feacd0;">()</span>(<span style="color: #6ae4b9; font-weight: bold;">IndexType</span><span style="color: #feacd0;">...</span>);
};
<span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #feacd0;">main</span>() {
    <span style="color: #6ae4b9; font-weight: bold;">int</span>  <span style="color: #00d3d0;">buffer</span>[2 * 3 * 4] = {};
    <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">s</span>                 = mdspan&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>, <span style="color: #6ae4b9; font-weight: bold;">extents</span>&lt;2, 3, 4&gt;&gt;(buffer);
    s(1, 1, 1)             = 42;
}
</pre>
</div>
</section>
</section>
<section>
<section id="slide-org50cc611">
<h5 id="org50cc611">After</h5>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">template</span> &lt;<span style="color: #b6a0ff; font-weight: bold;">class</span> <span style="color: #6ae4b9; font-weight: bold;">ElementType</span>, <span style="color: #b6a0ff; font-weight: bold;">class</span> <span style="color: #6ae4b9; font-weight: bold;">Extents</span>&gt;
 <span style="color: #b6a0ff; font-weight: bold;">class</span> <span style="color: #6ae4b9; font-weight: bold;">mdspan</span> {
    <span style="color: #b6a0ff; font-weight: bold;">template</span> &lt;<span style="color: #b6a0ff; font-weight: bold;">class</span><span style="color: #feacd0;">...</span> <span style="color: #6ae4b9; font-weight: bold;">IndexType</span>&gt;
    <span style="color: #b6a0ff; font-weight: bold;">constexpr</span> <span style="color: #6ae4b9; font-weight: bold;">reference</span> <span style="color: #b6a0ff; font-weight: bold;">operator</span><span style="color: #feacd0;">[]</span>(<span style="color: #6ae4b9; font-weight: bold;">IndexType</span><span style="color: #feacd0;">...</span>);
};
<span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #feacd0;">main</span>() {
    <span style="color: #6ae4b9; font-weight: bold;">int</span>  <span style="color: #00d3d0;">buffer</span>[2 * 3 * 4] = {};
    <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">s</span>                 = mdspan&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>, <span style="color: #6ae4b9; font-weight: bold;">extents</span>&lt;2, 3, 4&gt;&gt;(buffer);
    s[1, 1, 1]             = 42;
}
</pre>
</div>
<p>
tags: CWG, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p0009r9-mdspan-a-non-owning-multidimensional-array-reference-h.-carter-edwards-bryce-adelstein-l">
<h4 id="p0009r9-mdspan-a-non-owning-multidimensional-array-reference-h.-carter-edwards-bryce-adelstein-l"><a href="https://wg21.link/p0009">P0009</a> mdspan: A Non-Owning Multidimensional Array Reference (H. Carter Edwards, Bryce Adelstein</h4>
<blockquote>
<p>
This paper proposes adding to the C++ Standard Library a multidimensional array view, <code>mdspan</code>, along with classes, class templates, and constants for describing and creating multidimensional array views. It also proposes adding the submdspan function that “slices” (returns an <code>mdspan</code> that views a subset of) an existing mdspan.
</p>
</blockquote>

<blockquote>
<p>
The <code>mdspan</code> class template can represent arbitrary mixes of compile-time or run-time extents. Its element type can be any complete object type that is neither an abstract class type nor an array type. It has two customization opportunities for users: the <u>layout mapping</u> and the <u>accessor</u>. The layout mapping specifies the formula, and properties of the formula, for mapping a multidimensional index to an element of the array. The accessor governs how elements are read and written.
</p>
</blockquote>
<p>
tags: LWG, C++23, linear-algebra, tentatively-ready-for-plenary, IS, size - large, plenary-approved, mdspan
</p>

</section>
</section>
<section>
<section id="slide-orgcd98b0f">
<h2 id="orgcd98b0f">Core Working Group Features</h2>
<div class="outline-text-2" id="text-orgcd98b0f">
</div>
</section>
</section>
<section>
<section id="slide-org441007e">
<h3 id="org441007e">constexpr</h3>
<ul>
<li>5 Papers</li>

</ul>
</section>
</section>
<section>
<section id="slide-p0533r4-constexpr-for-cmath-and-cstdlib-edward-j.-rosten-oliver-j.-rosten">
<h5 id="p0533r4-constexpr-for-cmath-and-cstdlib-edward-j.-rosten-oliver-j.-rosten"><a href="https://wg21.link/p0533">P0533</a> constexpr for &lt;cmath&gt; and &lt;cstdlib&gt; (Edward J. Rosten, Oliver J. Rosten)</h5>
<blockquote>
<p>
We propose simple criteria for selecting functions in &lt;cmath&gt; which should be
declared constexpr.  There is a small degree of overlap with &lt;cstdlib&gt;. The aim
is to transparently select a sufficiently large portion of &lt;cmath&gt; in order to
be useful but without placing too much burden on compiler vendors.
</p>
</blockquote>

<ul class="org-ul">
<li><a id="orgf17ecc7"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">constexpr</span> <span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #feacd0;">foo</span>(<span style="color: #6ae4b9; font-weight: bold;">float</span> <span style="color: #00d3d0;">x</span>) {
<span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #00d3d0;">a</span>{}; <span style="color: #6ae4b9; font-weight: bold;">int</span>* <span style="color: #00d3d0;">pa</span>{&amp;a};
<span style="color: #00bcff;">std</span>::frexpr(x, pa);
<span style="color: #b6a0ff; font-weight: bold;">return</span> a;
}

<span style="color: #b6a0ff; font-weight: bold;">constexpr</span> <span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #00d3d0;">i</span>{foo(0.5f)}.
</pre>
</div>

<p>
tags: CWG, LWG, C++23, IS, B3 - addition, size - medium, plenary-approved, constexpr
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2448-relaxing-some-constexpr-restrictions-barry-revzin">
<h5 id="p2448-relaxing-some-constexpr-restrictions-barry-revzin"><a href="https://wg21.link/p2448">P2448</a> Relaxing some constexpr restrictions (Barry Revzin)</h5>
<blockquote>
<p>
There are two rules about constexpr programming that make code ill-formed or ill-formed (no diagnostic required) when functions or function templates are marked constexpr that might never evaluate to a constant expression. But… so what if they don’t? The goal of this paper is to stop diagnosing problems that don’t exist.
</p>
</blockquote>
<p>
tags: CWG, straw-poll, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p1938-if-consteval-barry-revzin-daveed-vandevoorde-richard-smith">
<h5 id="p1938-if-consteval-barry-revzin-daveed-vandevoorde-richard-smith"><a href="https://wg21.link/p1938">P1938</a> if consteval (Barry Revzin, Daveed Vandevoorde, Richard Smith)</h5>
<blockquote>
<p>
We propose a new form of if statement which is spelled:
</p>

<p>
<code>if consteval { }</code>
</p>
</blockquote>
<ul class="org-ul">
<li><a id="org2974ab0"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">consteval</span> <span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #feacd0;">f</span>(<span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #00d3d0;">i</span>) { <span style="color: #b6a0ff; font-weight: bold;">return</span> i; }

<span style="color: #b6a0ff; font-weight: bold;">constexpr</span> <span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #feacd0;">g</span>(<span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #00d3d0;">i</span>) {
    <span style="color: #b6a0ff; font-weight: bold;">if</span> <span style="color: #b6a0ff; font-weight: bold;">consteval</span> {
        <span style="color: #b6a0ff; font-weight: bold;">return</span> f(i) + 1; <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">ok: immediate function context</span>
    } <span style="color: #b6a0ff; font-weight: bold;">else</span> {
        <span style="color: #b6a0ff; font-weight: bold;">return</span> 42;
    }
}

<span style="color: #b6a0ff; font-weight: bold;">consteval</span> <span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #feacd0;">h</span>(<span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #00d3d0;">i</span>) {
    <span style="color: #b6a0ff; font-weight: bold;">return</span> f(i) + 1; <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">ok: immediate function context</span>
}
</pre>
</div>
<p>
tags: CWG, LWG, C++23, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2242-non-literal-variables-and-labels-and-gotos-in-constexpr-functions-ville-voutilainen">
<h5 id="p2242-non-literal-variables-and-labels-and-gotos-in-constexpr-functions-ville-voutilainen"><a href="https://wg21.link/p2242">P2242</a> Non-literal variables (and labels and gotos) in constexpr functions (Ville Voutilainen)</h5>
<blockquote>
<p>
This paper proposes to strike the restriction that a constexpr function cannot contain a definition of a variable of non-literal type (or of static or thread storage duration), or a goto statement, or an identifier label. The rationale is briefly that the mere presence of the aforementioned things in a function is not in and of itself problematic; we can allow them to be present, as long as constant evaluation doesn't evaluate them.
</p>
</blockquote>
<ul class="org-ul">
<li><a id="org69c715c"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">template</span> &lt;<span style="color: #b6a0ff; font-weight: bold;">typename</span> <span style="color: #6ae4b9; font-weight: bold;">T</span>&gt;
<span style="color: #b6a0ff; font-weight: bold;">constexpr</span> <span style="color: #6ae4b9; font-weight: bold;">bool</span> <span style="color: #feacd0;">f</span>() {
    <span style="color: #b6a0ff; font-weight: bold;">if</span> (<span style="color: #00bcff;">std</span>::is_constant_evaluated()) {
        <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">...</span>
        <span style="color: #b6a0ff; font-weight: bold;">return</span> <span style="color: #00bcff;">true</span>;
    } <span style="color: #b6a0ff; font-weight: bold;">else</span> {
        <span style="color: #6ae4b9; font-weight: bold;">T</span> <span style="color: #00d3d0;">t</span>;
        <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">...</span>
        <span style="color: #b6a0ff; font-weight: bold;">return</span> <span style="color: #00bcff;">true</span>;
    }
}
<span style="color: #b6a0ff; font-weight: bold;">struct</span> <span style="color: #6ae4b9; font-weight: bold;">nonliteral</span> {
    <span style="color: #feacd0;">nonliteral</span>();
};
<span style="color: #b6a0ff; font-weight: bold;">static_assert</span>(f&lt;<span style="color: #6ae4b9; font-weight: bold;">nonliteral</span>&gt;());
</pre>
</div>
<p>
tags: CWG, C++23, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2280-using-unknown-references-in-constant-expressions-barry-revzin">
<h5 id="p2280-using-unknown-references-in-constant-expressions-barry-revzin"><a href="https://wg21.link/p2280">P2280</a> Using unknown references in constant expressions (Barry Revzin)</h5>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">template</span> &lt;<span style="color: #b6a0ff; font-weight: bold;">typename</span> <span style="color: #6ae4b9; font-weight: bold;">T</span>, <span style="color: #6ae4b9; font-weight: bold;">size_t</span> <span style="color: #00d3d0;">N</span>&gt;
<span style="color: #b6a0ff; font-weight: bold;">constexpr</span> <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #feacd0;">array_size</span>(<span style="color: #6ae4b9; font-weight: bold;">T</span> (&amp;)[N]) -&gt; <span style="color: #6ae4b9; font-weight: bold;">size_t</span> {
    <span style="color: #b6a0ff; font-weight: bold;">return</span> N;
}

<span style="color: #6ae4b9; font-weight: bold;">void</span> <span style="color: #feacd0;">check</span>(<span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #b6a0ff; font-weight: bold;">const</span> (&amp;<span style="color: #00d3d0;">param</span>)[3]) {
    <span style="color: #6ae4b9; font-weight: bold;">int</span>            <span style="color: #00d3d0;">local</span>[] = {1, 2, 3};
    <span style="color: #b6a0ff; font-weight: bold;">constexpr</span> <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">s0</span>      = array_size(local); <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">ok</span>
    <span style="color: #b6a0ff; font-weight: bold;">constexpr</span> <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">s1</span>      = array_size(param); <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">error</span>
}
</pre>
</div>
<blockquote>
<p>
The proposal is to allow all these cases to just work. That is, if during constant evaluation, we run into a reference with unknown origin, this is still okay, we keep going. Similarly, if we run into a pointer with unknown origin, we allow indirecting through it.
</p>
</blockquote>

<p>
tags: CWG, straw-poll, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-org6570da8">
<h3 id="org6570da8">Text Translation</h3>
<ul>
<li>12 Papers</li>

</ul>
</section>
</section>
<section>
<section id="slide-p1949-c-identifier-syntax-using-unicode-standard-annex-31-steve-downey">
<h5 id="p1949-c-identifier-syntax-using-unicode-standard-annex-31-steve-downey"><a href="https://wg21.link/p1949">P1949</a> C++ Identifier Syntax using Unicode Standard Annex 31 (Steve Downey)</h5>
<blockquote>
<p>
Adopt Unicode Annex 31 as part of C++ 23.
</p>

<ul>
<li>That C++ identifiers match the pattern (XID_Start + _ ) + XID_Continue*.</li>
<li>That portable source is required to be normalized as NFC.</li>
<li>That using unassigned code points be ill-formed.</li>

</ul>

<p>
In addition adopt this proposal as a Defect Report against C++ 20 and earlier.
</p>
</blockquote>
<ul class="org-ul">
<li><a id="org9f99ea8"></a>Examples<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #6ae4b9; font-weight: bold;">bool</span> &#128119; = <span style="color: #00bcff;">true</span>; <span style="color: #ff9f80; font-style: italic;">//  </span><span style="color: #ff9f80; font-style: italic;">Construction Worker</span>
<span style="color: #6ae4b9; font-weight: bold;">bool</span> &#128119;&#8205;&#9792; = <span style="color: #00bcff;">false</span>; <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">Woman Construction Worker ({Construction Worker}{ZWJ}{Female Sign})</span>
<span style="color: #6ae4b9; font-weight: bold;">int</span> &#9200; = 0; <span style="color: #ff9f80; font-style: italic;">//</span><span style="color: #ff9f80; font-style: italic;">not valid</span>
<span style="color: #6ae4b9; font-weight: bold;">int</span> &#128336; = 0;

<span style="color: #6ae4b9; font-weight: bold;">int</span> &#9760; = 0; <span style="color: #ff9f80; font-style: italic;">//</span><span style="color: #ff9f80; font-style: italic;">not valid</span>
<span style="color: #6ae4b9; font-weight: bold;">int</span> &#128128; = 0;

<span style="color: #6ae4b9; font-weight: bold;">int</span> &#9995; = 0; <span style="color: #ff9f80; font-style: italic;">//</span><span style="color: #ff9f80; font-style: italic;">not valid</span>
<span style="color: #6ae4b9; font-weight: bold;">int</span> &#128074; = 0;

<span style="color: #6ae4b9; font-weight: bold;">int</span> &#9992; = 0; <span style="color: #ff9f80; font-style: italic;">//</span><span style="color: #ff9f80; font-style: italic;">not valid</span>
<span style="color: #6ae4b9; font-weight: bold;">int</span> &#128640; = 0;

<span style="color: #6ae4b9; font-weight: bold;">int</span> &#9785; = 0; <span style="color: #ff9f80; font-style: italic;">//</span><span style="color: #ff9f80; font-style: italic;">not valid</span>
<span style="color: #6ae4b9; font-weight: bold;">int</span> &#128512; = 0;

</pre>
</div>

<p>
All Invalid After p1949
</p>

<p>
tags: CWG, C++23, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2071-named-universal-character-escapes-tom-honermann-peter-bindels">
<h5 id="p2071-named-universal-character-escapes-tom-honermann-peter-bindels"><a href="https://wg21.link/p2071">P2071</a> Named universal character escapes (Tom Honermann, R. Martinho Fernandes, Peter Bindels, Corentin Jabot, Steve Downey)</h5>
<blockquote>
<p>
A proposal to extend universal character names from hexadecimal sequences to include the official names and formal aliases of Unicode codepoints.
</p>
</blockquote>
<ul class="org-ul">
<li><a id="orgfb99cb7"></a>Before/After Table<br />
<ul class="org-ul">
<li><a id="org151ed69"></a>Before:<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">UTF-32 character literal with U+0100 {LATIN CAPITAL LETTER A WITH MACRON}</span>
U<span style="color: #79a8ff;">'\u0100'</span>
<span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">UTF-8 string literal with U+0100 {LATIN CAPITAL LETTER A WITH MACRON} U+0300 {COMBINING GRAVE ACCENT}</span>
<span style="color: #00bcff;">u8</span><span style="color: #79a8ff;">"\u0100\u0300"</span>
</pre>
</div>
</li>
<li><a id="org93464d4"></a>After:<br />
<div class="org-src-container">

<pre class="src src-c++">U<span style="color: #fec43f; font-weight: bold;">'</span>\N{LATIN CAPITAL LETTER A WITH MACRON}<span style="color: #fec43f; font-weight: bold;">'</span> <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">Equivalent to U'\u0100'</span>
<span style="color: #00bcff;">u8</span><span style="color: #79a8ff;">"\N{LATIN CAPITAL LETTER A WITH MACRON}\N{COMBINING GRAVE ACCENT}"</span> <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">Equivalent to u8"\u0100\u0300"</span>
</pre>
</div>

<p>
tags: CWG, straw-poll, C++23, plenary-approved
</p>
</li>
</ul>
</li>
</ul>


</section>
</section>
<section>
<section id="slide-p2201-mixed-string-literal-concatenation-jens-maurer">
<h5 id="p2201-mixed-string-literal-concatenation-jens-maurer"><a href="https://wg21.link/p2201">P2201</a> Mixed string literal concatenation (Jens Maurer)</h5>
<blockquote>
<p>
String concatenation involving string-literals with encoding-prefixes mixing L"", u8"", u"", and U"" is currently conditionally-supported with implementation-defined behavior.
[&#x2026;]
No meaningful use-case for such mixed concatenations is known.
</p>

<p>
This paper makes such mixed concatenations ill-formed.
</p>
</blockquote>
<p>
tags: CWG, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2223-trimming-whitespaces-before-line-splicing-corentin-jabot">
<h5 id="p2223-trimming-whitespaces-before-line-splicing-corentin-jabot"><a href="https://wg21.link/p2223">P2223</a> Trimming whitespaces before line splicing (Corentin Jabot)</h5>
<blockquote>
<p>
We propose to make trailing whitespaces after \ non-significant.
</p>
</blockquote>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #feacd0;">main</span>() {
<span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #00d3d0;">i</span> = 1
<span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">\</span>
<span style="color: #ff9f80; font-style: italic;">+ 42</span>
;
<span style="color: #b6a0ff; font-weight: bold;">return</span> i;
}
</pre>
</div>
<p>
tags: CWG, C++23, SG22, plenary-approved
</p>


</section>
</section>
<section>
<section id="slide-p2246-character-encoding-of-diagnostic-text-aaron-ballman">
<h5 id="p2246-character-encoding-of-diagnostic-text-aaron-ballman"><a href="https://wg21.link/p2246">P2246</a> Character encoding of diagnostic text (Aaron Ballman)</h5>
<blockquote>
<p>
The standard provides a few mechanisms that suggest an implementation issues a diagnostic based on
text written in the source code. However, the standard does not uniformly address what should happen
if the execution character set of the compiler cannot represent the text in the source character set.
</p>
</blockquote>

<blockquote>
<p>
Because the display of diagnostic messages should be merely a matter of Quality of Implementation, the
proposal is to place no character set related requirements on the diagnostic output with the
understanding that implementations will do what makes the most sense for their situation when issuing
diagnostics in terms of which characters need to be escaped or otherwise handled in a special way.
</p>
</blockquote>
<p>
tags: CWG, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2290-delimited-escape-sequences-corentin-jabot">
<h5 id="p2290-delimited-escape-sequences-corentin-jabot"><a href="https://wg21.link/p2290">P2290</a> Delimited escape sequences (Corentin Jabot)</h5>
<blockquote>
<p>
We propose an additional, clearly delimited syntax for octal, hexadecimal and universal
character name escape sequences.
</p>
</blockquote>
<blockquote>
<p>
We propose new syntaxes \u{}, \o{}, \x{} usable in places where \u, \x, \nnn currently are.
\o{} accepts an arbitrary number of octal digits while \u{} and \x{} accept an arbitrary number
of hexadecimal digit.
</p>
</blockquote>
<p>
tags: CWG, straw-poll, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2314-character-sets-and-encodings-jens-maurer">
<h5 id="p2314-character-sets-and-encodings-jens-maurer"><a href="https://wg21.link/p2314">P2314</a> Character sets and encodings (Jens Maurer)</h5>
<blockquote>
<p>
This paper implements the following changes:
</p>
<ul>
<li>Switch C++ to a modified "model C" approach for universal-character-names as described in the C99 Rationale v5.10, section 5.2.1.</li>
<li>Introduce the term "literal encoding". For purposes of the C++ specification, the actual set of characters is not relevant, but the sequence of code units (i.e. the encoding) specified by a given character or string literal are. The terms "execution (wide) character set" are retained to describe the locale-dependent runtime character set used by functions such as isalpha.</li>
<li>(Not a wording change) Do not attempt to treat all string literals the same; their treatment depends on (phase 7) context.</li>

</ul>
</blockquote>
<ul class="org-ul">
<li><a id="org2145a98"></a>Before/After Table<br />
<p>
Before:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ff7f9f;">#define</span> <span style="color: #feacd0;">S</span>(<span style="color: #00d3d0;">x</span>) # x
<span style="color: #b6a0ff; font-weight: bold;">const</span> <span style="color: #6ae4b9; font-weight: bold;">char</span> * <span style="color: #00d3d0;">s1</span> = S(K&#246;ppe);       <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">"K\\u00f6ppe"</span>
<span style="color: #b6a0ff; font-weight: bold;">const</span> <span style="color: #6ae4b9; font-weight: bold;">char</span> * <span style="color: #00d3d0;">s2</span> = S(K\u00f6ppe);  <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">"K\\u00f6ppe"</span>
</pre>
</div>
<p>
After:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ff7f9f;">#define</span> <span style="color: #feacd0;">S</span>(<span style="color: #00d3d0;">x</span>) # x
<span style="color: #b6a0ff; font-weight: bold;">const</span> <span style="color: #6ae4b9; font-weight: bold;">char</span> * <span style="color: #00d3d0;">s1</span> = S(K&#246;ppe);       <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">"K&#246;ppe"</span>
<span style="color: #b6a0ff; font-weight: bold;">const</span> <span style="color: #6ae4b9; font-weight: bold;">char</span> * <span style="color: #00d3d0;">s2</span> = S(K\u00f6ppe);  <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">"K&#246;ppe"</span>
</pre>
</div>
<p>
tags: CWG, C++23, plenary-approved
</p>
</li>
</ul>


</section>
</section>
<section>
<section id="slide-p2316-consistent-character-literal-encoding-corentin-jabot">
<h5 id="p2316-consistent-character-literal-encoding-corentin-jabot"><a href="https://wg21.link/p2316">P2316</a> Consistent character literal encoding (Corentin Jabot)</h5>
<blockquote>
<p>
Character literals in preprocessor conditional should behave like they do in C++ expression.
</p>
</blockquote>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ff7f9f;">#if</span> <span style="color: #79a8ff;">'A'</span> == <span style="color: #79a8ff;">'\x41'</span>
<span style="color: #ff9f80; font-style: italic;">//</span><span style="color: #ff9f80; font-style: italic;">...</span>
<span style="color: #ff7f9f;">#endif</span>
<span style="color: #b6a0ff; font-weight: bold;">if</span> (<span style="color: #79a8ff;">'A'</span> == <span style="color: #b6a0ff; font-weight: bold;">0x</span><span style="color: #00bcff;">41</span>){}
</pre>
</div>
<p>
tags: CWG, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2362-make-obfuscating-wide-character-literals-ill-formed-peter-brett-corentin-jabot">
<h5 id="p2362-make-obfuscating-wide-character-literals-ill-formed-peter-brett-corentin-jabot"><a href="https://wg21.link/p2362">P2362</a> Make obfuscating wide character literals ill-formed (Peter Brett, Corentin Jabot)</h5>
<blockquote>
<p>
C++ currently permits writing a wide character literal with multiple characters or characters that
cannot fit into a single <code>wchar_t</code> codeunit. For example:
</p>
</blockquote>
<ul class="org-ul">
<li><a id="orgd631df2"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #6ae4b9; font-weight: bold;">wchar_t</span> <span style="color: #00d3d0;">a</span> = L<span style="color: #79a8ff;">'&#129318;'</span>; <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">\u{1F926}</span>
<span style="color: #6ae4b9; font-weight: bold;">wchar_t</span> <span style="color: #00d3d0;">b</span> = L<span style="color: #fec43f; font-weight: bold;">'</span>ab<span style="color: #fec43f; font-weight: bold;">'</span>;
<span style="color: #6ae4b9; font-weight: bold;">wchar_t</span> <span style="color: #00d3d0;">c</span> = L<span style="color: #79a8ff;">'&#233;'</span>; <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">\u{65}\u{301};</span>
</pre>
</div>
<blockquote>
<p>
Make these literals ill-formed.
</p>
</blockquote>

<p>
tags: CWG, straw-poll, C++23, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2460-relax-requirements-on-wchar_t-to-match-existing-practices-corentin-jabot">
<h5 id="p2460-relax-requirements-on-wchar_t-to-match-existing-practices-corentin-jabot"><a href="https://wg21.link/p2460">P2460</a> Relax requirements on wchar_t to match existing practices (Corentin Jabot)</h5>
<blockquote>
<p>
We propose to remove the constraints put on the encoding associated with <code>wchar_t</code> in the core wording.
</p>
</blockquote>

<ul class="org-ul">
<li><a id="orga89dd0a"></a>Proposal<br />
<p>
Type wchar_t is a distinct type that has an implementation-defined signed or unsigned integer type as its underlying type. <del>The values of type wchar_t can represent distinct codes for all members of the largest extended character set
specified among the supported locales.</del>
</p>

<p>
tags: CWG, LWG, straw-poll, C++23, tentatively-ready-for-plenary, IS, lwg-fullreview, B2 - improvement, size - small, plenary-approved, &#x2026;
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2295-correct-utf-8-handling-during-phase-1-of-translation-corentin-jabot">
<h5 id="p2295-correct-utf-8-handling-during-phase-1-of-translation-corentin-jabot"><a href="https://wg21.link/p2295">P2295</a> Correct UTF-8 handling during phase 1 of translation (Corentin Jabot, Peter Brett)</h5>
<blockquote>
<p>
We propose that UTF-8 source files should be supported by all C++ compilers.
</p>
</blockquote>
<p>
tags: CWG, straw-poll, C++23, plenary-approved
</p>


</section>
</section>
<section>
<section id="slide-p2513-char8_t-compatibility-and-portability-fixes-jeanheyd-meneide-tom-honermann">
<h5 id="p2513-char8_t-compatibility-and-portability-fixes-jeanheyd-meneide-tom-honermann"><a href="https://wg21.link/p2513">P2513</a> char8_t Compatibility and Portability Fixes (JeanHeyd Meneide, Tom Honermann)</h5>
<blockquote>
<p>
char8_t has compatibility problems and issues during deployment that people have had to spend energy working around. This paper aims to alleviate some of those compatibility problems, for both C and C++, around string and character literals for the char8_t type.
</p>
</blockquote>
<p>
tags: CWG, straw-poll, C++23, B2 - improvement, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-org67d699e">
<h3 id="org67d699e">Other CWG</h3>
<ul>
<li>32 Papers</li>

</ul>
</section>
</section>
<section>
<section id="slide-p0849-autox-decay_copy-in-the-language-zhihao-yuan">
<h5 id="p0849-autox-decay_copy-in-the-language-zhihao-yuan"><a href="https://wg21.link/p0849">P0849</a> auto(x): DECAY_COPY in the language (Zhihao Yuan)</h5>
<blockquote>
<p>
This paper proposes auto(x) and auto{x} for transforming x into a prvalue with the same value as-if passed as a function argument by value. When users asked for this functionality, we claimed that the DECAY_COPY notion in the standard serves such purpose, but it is for exposition only.
</p>
</blockquote>
<ul class="org-ul">
<li><a id="org5660bf0"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">instead of:</span>
<span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">subparser</span> = parser;
subparser.add_option(<span style="color: #feacd0;">...</span>);

<span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">you can write:</span>
<span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">subparser</span> = <span style="color: #b6a0ff; font-weight: bold;">auto</span>(parser).add_option(<span style="color: #feacd0;">...</span>);
</pre>
</div>

<p>
tags: CWG, LWG, C++23, IS, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p1272-byteswapping-for-funnuf-isabella-muerte">
<h5 id="p1272-byteswapping-for-funnuf-isabella-muerte"><a href="https://wg21.link/p1272">P1272</a> Byteswapping for fun&amp;&amp;nuf (Isabella Muerte)</h5>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">namespace</span> <span style="color: #00bcff;">std</span> {
    <span style="color: #b6a0ff; font-weight: bold;">template</span> &lt;<span style="color: #b6a0ff; font-weight: bold;">class</span> <span style="color: #6ae4b9; font-weight: bold;">IntegerType</span>&gt;
    <span style="color: #b6a0ff; font-weight: bold;">constexpr</span> <span style="color: #6ae4b9; font-weight: bold;">IntegerType</span> <span style="color: #feacd0;">byteswap</span> (<span style="color: #6ae4b9; font-weight: bold;">IntegerType</span> <span style="color: #00d3d0;">value</span>) <span style="color: #b6a0ff; font-weight: bold;">noexcept</span>;
}
<span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">Where std::is_integral_v&lt;IntegerType&gt; is true.</span>
</pre>
</div>
<p>
tags: CWG, LWG, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p1401-narrowing-contextual-conversions-to-bool-andrzej-krzemienski">
<h5 id="p1401-narrowing-contextual-conversions-to-bool-andrzej-krzemienski"><a href="https://wg21.link/p1401">P1401</a> Narrowing contextual conversions to bool (Andrzej Krzemienski)</h5>
<blockquote>
<p>
This paper proposes to allow narrowing conversions in <b>contextually converted constant expressions of type `bool`</b>.
</p>
</blockquote>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Today</th>
<th scope="col" class="org-left">If accepted</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>if constexpr(bool(flags &amp; Flags::Exec))</code></td>
<td class="org-left"><code>if constexpr(flags &amp; Flags::Exec)</code></td>
</tr>

<tr>
<td class="org-left"><code>if constexpr(flags &amp; Flags::Exec != 0)</code></td>
<td class="org-left"><code>if constexpr(flags &amp; Flags::Exec)</code></td>
</tr>

<tr>
<td class="org-left"><code>static_assert(N % 4 != 0);</code></td>
<td class="org-left"><code>static_assert(N % 4);</code></td>
</tr>

<tr>
<td class="org-left"><code>static_assert(bool(N));</code></td>
<td class="org-left"><code>static_assert(N);</code></td>
</tr>
</tbody>
</table>

<p>
tags: CWG, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p1467-extended-floating-point-types-michał-dominiak-david-olsen">
<h5 id="p1467-extended-floating-point-types-michał-dominiak-david-olsen"><a href="https://wg21.link/p1467">P1467</a> Extended floating-point types (Michał Dominiak, David Olsen)</h5>
<blockquote>
<p>
This paper introduces the notion of <u>extended floating-point types</u>, modeled
after extended integer types. To accomodate them, this paper also attempts to
rewrite the current rules for floating-point types, to enable well-defined
interactions between all the floating-point types. The end goal of this paper,
together with [P1468], is to have a language to enable <code>&lt;cstdint&gt;</code>-like aliases
for implementation specific floating point types, that can model more binary
layouts than just a single fundamental type (the previously proposed short
float) can provide for
</p>
</blockquote>
<p>
tags: CWG, LWG, straw-poll, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p1675-rethrow_exception-must-be-allowed-to-copy-billy-oneal">
<h5 id="p1675-rethrow_exception-must-be-allowed-to-copy-billy-oneal"><a href="https://wg21.link/p1675">P1675</a> rethrow_exception must be allowed to copy (Billy O'Neal)</h5>
<blockquote>
<p>
The <code>current_exception</code> wording was carefully written to allow both ABIs like
MSVC++’s where the exception objects are generally constructed on the stack,
and ABIs like the Itanium C++ ABI where the exception objects are generally
constructed on the heap (and possibly reference counted).  Implementations are
given the freedom they need to (possibly) copy the exception object into the
memory held by the exception_ptr, and similar. See
<a href="http://eel.is/c++draft/propagation#8">http://eel.is/c++draft/propagation#8</a>.
</p>

<p>
Unfortunately, such care was not taken for <code>rethrow_exception</code>.
</p>
</blockquote>

<p>
tags: CWG, LWG, C++23, B2 - improvement, size - small, plenary-approved
</p>


</section>
</section>
<section>
<section id="slide-p1774-portable-optimisation-hints-timur-doumler">
<h5 id="p1774-portable-optimisation-hints-timur-doumler"><a href="https://wg21.link/p1774">P1774</a> Portable optimisation hints (Timur Doumler)</h5>
<blockquote>
<p>
We propose a standard facility providing the semantics of existing compiler intrinsics such as
<code>__builtin_assume</code> (Clang) and <code>__assume</code> (MSVC, Intel) that tell the compiler to assume a
given C++ expression without evaluating it, and to optimise based on this assumption. This is
very useful for high-performance and low-latency applications in order to generate both faster
and smaller code.
</p>
</blockquote>

<p>
tags: CWG, straw-poll, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p1847-make-declaration-order-layout-mandated-pal-balog">
<h5 id="p1847-make-declaration-order-layout-mandated-pal-balog"><a href="https://wg21.link/p1847">P1847</a> Make declaration order layout mandated (Pal Balog)</h5>
<blockquote>
<p>
The current rules allow implementations freedom to reorder members in the layout if they have different
access control. To our knowledge no implementation actually used that freedom. We propose to fix this
established industry practice in the standard as mandatory.
</p>
</blockquote>
<p>
tags: CWG, C++23, plenary-approved
</p>


</section>
</section>
<section>
<section id="slide-p2036-changing-scope-for-lambda-trailing-return-type-barry-revzin">
<h5 id="p2036-changing-scope-for-lambda-trailing-return-type-barry-revzin"><a href="https://wg21.link/p2036">P2036</a> Changing scope for lambda trailing-return-type (Barry Revzin)</h5>
<blockquote>
<p>
This paper proposes that name lookup in the trailing-return-type of a lambda
first consider that lambda’s captures before looking further outward. We may
not know at the time of parsing the return type which names actually are
captured, so this paper proposes to treat all capturable entities as if they
were captured.
</p>
</blockquote>
<p>
tags: CWG, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2156-allow-duplicate-attributes-erich-keane">
<h5 id="p2156-allow-duplicate-attributes-erich-keane"><a href="https://wg21.link/p2156">P2156</a> Allow Duplicate Attributes (Erich Keane)</h5>
<blockquote>
<p>
The standard attributes noreturn, carries dependency, and deprecated all
specify that they cannot appear more than once in an attribute-list, but there
is no such prohibition if they appear in separate attribute-specifiers within a
single attributespecifier-seq. Since intuitively these cases are equivalent,
they should be treated the same, accepting duplicates in both or neither.
</p>
</blockquote>
<p>
tags: CWG, C++23, plenary-approved
</p>


</section>
</section>
<section>
<section id="slide-p2173-attributes-on-lambda-expressions-daveed-vandevoorde-inbal-levi-ville-voutilainen">
<h5 id="p2173-attributes-on-lambda-expressions-daveed-vandevoorde-inbal-levi-ville-voutilainen"><a href="https://wg21.link/p2173">P2173</a> Attributes on Lambda-Expressions (Daveed Vandevoorde, Inbal Levi, Ville Voutilainen)</h5>
<blockquote>
<p>
This paper proposes a fix for
<a href="http://open-std.org/JTC1/SC22/WG21/docs/cwg_toc.html#2097">Core Issue 2097</a>,
to allow attributes for lambdas, those attributes appertaining to the function
call operator of the lambda.
</p>
</blockquote>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">lm</span> = [] [[<span style="color: #00bcff;">nodiscard</span>, <span style="color: #00bcff;">vendor</span>::attr]] () -&gt; <span style="color: #6ae4b9; font-weight: bold;">int</span> { <span style="color: #b6a0ff; font-weight: bold;">return</span> 42; };
</pre>
</div>
<p>
tags: CWG, straw-poll, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2186-removing-garbage-collection-support-jf-bastien-alisdair-meredith">
<h5 id="p2186-removing-garbage-collection-support-jf-bastien-alisdair-meredith"><a href="https://wg21.link/p2186">P2186</a> Removing Garbage Collection Support (JF Bastien, Alisdair Meredith)</h5>
<blockquote>
<p>
We propose removing (not deprecating) C++'s Garbage Collection support. Specifically, these five library functions:
</p>
<ul>
<li>declare_reachable</li>
<li>undeclare_reachable</li>
<li>declare_no_pointers</li>
<li>undeclare_no_pointers</li>
<li>get_pointer_safety</li>

</ul>

<p>
As well as the pointer_safety enum, the \_\_STDCPP_STRICT_POINTER_SAFETY\_&ensp;macro, and the Core Language wording.
</p>
</blockquote>
<p>
tags: CWG, LWG, C++23, IS, plenary-approved
</p>


</section>
</section>
<section>
<section id="slide-p2266-simpler-implicit-move-arthur-odwyer">
<h5 id="p2266-simpler-implicit-move-arthur-odwyer"><a href="https://wg21.link/p2266">P2266</a> Simpler implicit move (Arthur O'Dwyer)</h5>
<blockquote>
<p>
In C++20, return statements can implicitly move from local variables of rvalue reference type; but a defect in the wording means that implicit move fails to apply to functions that return references. C++20’s implicit move is specified via a complicated process involving two overload resolutions, which is hard to implement, causing implementation divergence. We fix the defect and simplify the spec by saying that a returned move-eligible id-expression is always an xvalue.
</p>
</blockquote>
<p>
tags: CWG, straw-poll, C++23, plenary-approved
</p>



</section>
</section>
<section>
<section id="slide-p2324-labels-at-the-end-of-compound-statements-c-compatibility-martin-uecker">
<h5 id="p2324-labels-at-the-end-of-compound-statements-c-compatibility-martin-uecker"><a href="https://wg21.link/p2324">P2324</a> Labels at the end of compound statements (C compatibility) (Martin Uecker)</h5>
<blockquote>
<p>
WG14 adopted a change for C2X that allows placement of labels everywhere inside a compound
statement (N2508). While this improves compatibility with C++ which previously diverged from C
by allowing labels in front of declarations, there is still a remaining incompatibility: C now does
allow labels at the end of a compound statement, while C++ does not. It is proposed to change the
C++ grammar to remove this remaining difference.
</p>
</blockquote>
<ul class="org-ul">
<li><a id="org9640df6"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #6ae4b9; font-weight: bold;">void</span> <span style="color: #feacd0;">foo</span>(<span style="color: #6ae4b9; font-weight: bold;">void</span>)
{
<span style="color: #00bcff;">first</span>: <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">allowed in C++, now also allowed in C</span>
<span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #00d3d0;">x</span>;
<span style="color: #00bcff;">second</span>: <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">allowed in both C++ and C</span>
x = 1;
<span style="color: #00bcff;">last</span>: <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">not allowed in C++, but now allowed in C</span>
}
</pre>
</div>
<p>
tags: CWG, straw-poll, C++23, size - small, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2327-de-deprecating-volatile-compound-assignment-paul-bendixen-jens-maurer-arthur-odwyer-be">
<h5 id="p2327-de-deprecating-volatile-compound-assignment-paul-bendixen-jens-maurer-arthur-odwyer-be"><a href="https://wg21.link/p2327">P2327</a> De-deprecating volatile compound assignment (Paul Bendixen, Jens Maurer, Arthur O'Dwyer, Ben Saks)</h5>
<blockquote>
<p>
The C++ 20 standard deprecated many functionalities of the volatile keyword. This was due to
P1152[Bastien, 2019]. The reasoning is given in the R0 version of the paper[Bastien, 2018].
</p>

<p>
The deprecation was not received too well in the embedded community as volatile is commonly
used for communicating with peripheral devices in microcontrollers[van Ooijen, 2020].
</p>

<p>
The purpose of this paper is to give a solution that will not undo what was achieved with
P1152, and still keep the parts that are critical to the embedded community.
</p>
</blockquote>
<p>
tags: CWG, straw-poll, C++23, plenary-approved
</p>


</section>
</section>
<section>
<section id="slide-p2334-add-support-for-preprocessing-directives-elifdef-and-elifndef-melanie-blower">
<h5 id="p2334-add-support-for-preprocessing-directives-elifdef-and-elifndef-melanie-blower"><a href="https://wg21.link/p2334">P2334</a> Add support for preprocessing directives elifdef and elifndef (Melanie Blower)</h5>
<blockquote>
<p>
This paper is being submitted as a liaison activity from WG14 C Language Working Group. The proposal
was discussed in the March 2021 meeting and approved (15 in favor, 1 opposed, 4 abstentions) for
inclusion into C23. This paper is being proposed to WG21 to avoid preprocessor incompatibilities with C
and because the utility is valuable to C++ users of the preprocessor.
</p>
</blockquote>
<p>
tags: CWG, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2360-extend-init-statement-to-allow-alias-declaration-jens-maurer">
<h5 id="p2360-extend-init-statement-to-allow-alias-declaration-jens-maurer"><a href="https://wg21.link/p2360">P2360</a> Extend init-statement to allow alias-declaration (Jens Maurer)</h5>
<ul class="org-ul">
<li><a id="org3a04a26"></a>Before:<br />
<div class="org-src-container">

<pre class="src src-c++">  <span style="color: #b6a0ff; font-weight: bold;">for</span> (<span style="color: #b6a0ff; font-weight: bold;">typedef</span> <span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #6ae4b9; font-weight: bold;">T</span>; <span style="color: #6ae4b9; font-weight: bold;">T</span> <span style="color: #6ae4b9; font-weight: bold;">e</span> : v)
    <span style="color: #ff9f80; font-style: italic;">/* </span><span style="color: #ff9f80; font-style: italic;">something</span><span style="color: #ff9f80; font-style: italic;"> */</span>;
</pre>
</div>
</li>
<li><a id="org52481bf"></a>After:<br />
<div class="org-src-container">

<pre class="src src-c++">  <span style="color: #b6a0ff; font-weight: bold;">for</span> (<span style="color: #b6a0ff; font-weight: bold;">using</span> <span style="color: #6ae4b9; font-weight: bold;">T</span> = <span style="color: #6ae4b9; font-weight: bold;">int</span>; T <span style="color: #6ae4b9; font-weight: bold;">e</span> : v)
    <span style="color: #ff9f80; font-style: italic;">/* </span><span style="color: #ff9f80; font-style: italic;">something</span><span style="color: #ff9f80; font-style: italic;"> */</span>;
</pre>
</div>
<p>
tags: CWG, C++23, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2437-support-for-warning-aaron-ballman">
<h5 id="p2437-support-for-warning-aaron-ballman"><a href="https://wg21.link/p2437">P2437</a> Support for #warning (Aaron Ballman)</h5>
<blockquote>
<p>
Almost all major C++ compilers support the #warning preprocessing directive to
generate a diagnostic message from the preprocessor without stopping
translation, as <code>#error</code> does, which can be useful for code authors who want to
warn consumers of the code about non-fatal concerns.
</p>
</blockquote>

<blockquote>
<p>
WG14 considered a similar proposal as part of WG14 N2686 at our Sept 2021
meeting and adopted the feature into C23 (straw poll results were: 17 in favor,
0 oppose, 1 abstain). The WG21 proposal is functionally identical to the WG14
proposal, with the only difference being due to existing variance in
specification around how <code>#error</code> causes translation to stop.
</p>
</blockquote>
<p>
tags: CWG, straw-poll, C++23, size - tiny, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2468-the-equality-operator-you-are-looking-for-barry-revzin-bjarne-stroustrup-cameron-dacamar">
<h5 id="p2468-the-equality-operator-you-are-looking-for-barry-revzin-bjarne-stroustrup-cameron-dacamar"><a href="https://wg21.link/p2468">P2468</a> The Equality Operator You Are Looking For (Barry Revzin, Bjarne Stroustrup, Cameron DaCamara, Daveed Vandevoorde, Gabriel Dos Reis, Herb Sutter, Jason Merrill, Jonathan Caves, Richard Smith, Ville Voutilainen)</h5>
<blockquote>
<p>
This paper details some changes to make rewriting equality in expressions less of a breaking change
</p>
</blockquote>
<blockquote>
<ul>
<li>If you want an operator== that is used for rewrites (automatically reversed, and != automatically generated), write only an operator==, and make sure its return type is bool.</li>

<li>If you want an operator== that is not used for rewrites, write both an operator== and a matching operator!=.</li>

<li>operator&lt;=&gt; is always used for rewrites (from &lt;, &lt;=, &gt;, &gt;=); if you don’t want rewrites, don’t write an operator&lt;=&gt;.</li>

</ul>
</blockquote>
<p>
tags: CWG, straw-poll, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2493-missing-feature-test-macros-for-c20-core-papers-barry-revzin">
<h5 id="p2493-missing-feature-test-macros-for-c20-core-papers-barry-revzin"><a href="https://wg21.link/p2493">P2493</a> Missing feature test macros for C++20 core papers (Barry Revzin)</h5>
<blockquote>
<p>
As Jonathan Wakely pointed out on the SG10 mailing list, neither [P0848R3] (Conditionally Trivial Special Member Functions) nor [P1330R0] ( Changing the active member of a union inside constexpr) provided a feature-test macro.
</p>
</blockquote>

<blockquote>
<p>
This paper proposes Richard’s second suggestion: bump __cpp_concepts and __cpp_constexpr to 202002L
</p>
</blockquote>
<p>
tags: CWG, straw-poll, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2582-wording-for-class-template-argument-deduction-from-inherited-constructors-timur-doumler">
<h5 id="p2582-wording-for-class-template-argument-deduction-from-inherited-constructors-timur-doumler"><a href="https://wg21.link/p2582">P2582</a> Wording for class template argument deduction from inherited constructors (Timur Doumler)</h5>
<blockquote>
<p>
This paper provides wording for class template argument deduction from inherited constructors.
</p>
</blockquote>
<p>
From <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1021r6.html">P1021R6</a>
</p>

<ul class="org-ul">
<li><a id="orge6a401f"></a>Before:<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">template</span>&lt;<span style="color: #b6a0ff; font-weight: bold;">class</span> <span style="color: #6ae4b9; font-weight: bold;">T</span>&gt;
<span style="color: #b6a0ff; font-weight: bold;">struct</span> <span style="color: #6ae4b9; font-weight: bold;">Point</span> { <span style="color: #6ae4b9; font-weight: bold;">T</span> <span style="color: #00d3d0;">x</span>; <span style="color: #6ae4b9; font-weight: bold;">T</span> <span style="color: #00d3d0;">y</span>; };

<span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">Aggregate: Cannot deduce</span>
<span style="color: #6ae4b9; font-weight: bold;">Point</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">double</span>&gt; <span style="color: #00d3d0;">p</span>{3.0, 4.0};
<span style="color: #6ae4b9; font-weight: bold;">Point</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">double</span>&gt; <span style="color: #00d3d0;">p2</span>{.x = 3.0, .y = 4.0};
</pre>
</div>
</li>

<li><a id="org2732095"></a>After:<br />
<div class="org-src-container">

<pre class="src src-c++">
<span style="color: #b6a0ff; font-weight: bold;">template</span>&lt;<span style="color: #b6a0ff; font-weight: bold;">class</span> <span style="color: #6ae4b9; font-weight: bold;">T</span>&gt;
<span style="color: #b6a0ff; font-weight: bold;">struct</span> <span style="color: #6ae4b9; font-weight: bold;">Point</span> { <span style="color: #6ae4b9; font-weight: bold;">T</span> <span style="color: #00d3d0;">x</span>; <span style="color: #6ae4b9; font-weight: bold;">T</span> <span style="color: #00d3d0;">y</span>; };

<span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">Proposed: Aggregates deduce</span>
<span style="color: #6ae4b9; font-weight: bold;">Point</span> <span style="color: #00d3d0;">p</span>{3.0, 4.0};
<span style="color: #6ae4b9; font-weight: bold;">Point</span> <span style="color: #00d3d0;">p2</span>{.x = 3.0, .y = 4.0};
</pre>
</div>
<p>
tags: CWG, straw-poll, C++23, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p0330r3-literal-suffixes-for-ptrdiff_t-and-size_t-jeanheyd-meneide-rein-halbersma">
<h5 id="p0330r3-literal-suffixes-for-ptrdiff_t-and-size_t-jeanheyd-meneide-rein-halbersma"><a href="https://wg21.link/p0330">P0330</a> Literal Suffixes for ptrdiff_t and size_t (JeanHeyd Meneide, Rein Halbersma)</h5>
<blockquote>
<p>
This paper proposes core language suffixes for size_t and its associated signed type.
</p>
</blockquote>

<ul class="org-ul">
<li><a id="orgc060cae"></a>Before<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">vector</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&gt; <span style="color: #00d3d0;">v</span>{0, 1, 2, 3};
<span style="color: #b6a0ff; font-weight: bold;">for</span> (<span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">i</span> = 0u, <span style="color: #00d3d0;">s</span> = v.size(); i &lt; s; ++i) {
    <span style="color: #ff9f80; font-style: italic;">/* </span><span style="color: #ff9f80; font-style: italic;">use both i and v[i]</span><span style="color: #ff9f80; font-style: italic;"> */</span>
}
&#9888;&#65039; - Compiles on 32-bit, truncates (maybe with warnings) on 64-bit
<span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">vector</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&gt; v{0, 1, 2, 3};
<span style="color: #b6a0ff; font-weight: bold;">for</span> (<span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">i</span> = 0, <span style="color: #00d3d0;">s</span> = v.size(); i &lt; s; ++i) {
    <span style="color: #ff9f80; font-style: italic;">/* </span><span style="color: #ff9f80; font-style: italic;">use both i and v[i]</span><span style="color: #ff9f80; font-style: italic;"> */</span>
}
&#10060; - Compilation error

</pre>
</div>
</li>
<li><a id="orgfeb6749"></a>After<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">vector</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&gt; <span style="color: #00d3d0;">v</span>{0, 1, 2, 3};
<span style="color: #b6a0ff; font-weight: bold;">for</span> (<span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">i</span> = 0uz, <span style="color: #00d3d0;">s</span> = v.size(); i &lt; s; ++i) {
    <span style="color: #ff9f80; font-style: italic;">/* </span><span style="color: #ff9f80; font-style: italic;">use both i and v[i]</span><span style="color: #ff9f80; font-style: italic;"> */</span>
}
</pre>
</div>
<p>
LWG, C++23, tiny, plenary-approved
</p>


<p>
tags: C++23, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p1102-down-with-alex-christensen-jf-bastien">
<h5 id="p1102-down-with-alex-christensen-jf-bastien"><a href="https://wg21.link/p1102">P1102</a> Down with <code>()</code>! (Alex Christensen, JF Bastien)</h5>
<blockquote>
<p>
A proposal for removing unnecessary ()’s from C++ lambdas.
</p>
</blockquote>

<p>
tags: C++23, IS, plenary-approved
</p>


</section>
</section>
<section>
<section id="slide-p0943-support-c-atomics-in-c-hans-j.-boehm">
<h5 id="p0943-support-c-atomics-in-c-hans-j.-boehm"><a href="https://wg21.link/p0943">P0943</a> Support C atomics in C++ (Hans-J. Boehm)</h5>
<blockquote>
<p>
We propose to define what it means to include the C <code>&lt;stdatomic.h&gt;</code> header from C++ code. The goal is to enable "shared" headers that use atomics, and can be included from either C or C++ code.
</p>
</blockquote>
<p>
tags: C++23, IS, B2 - improvement, size - small, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p1048-a-proposal-for-a-type-trait-to-detect-scoped-enumerations-juan-alday">
<h5 id="p1048-a-proposal-for-a-type-trait-to-detect-scoped-enumerations-juan-alday"><a href="https://wg21.link/p1048">P1048</a> A proposal for a type trait to detect scoped enumerations (Juan Alday)</h5>
<blockquote>
<p>
This paper proposes <code>is_scoped_enum</code>, a new trait for the C++ Standard Library, to detect
whether a type is a scoped enumeration.
</p>
</blockquote>
<p>
tags: C++23, IS, B3 - addition, size - small, plenary-approved
</p>



</section>
</section>
<section>
<section id="slide-p1169-static-operator-barry-revzin-casey-carter">
<h5 id="p1169-static-operator-barry-revzin-casey-carter"><a href="https://wg21.link/p1169">P1169</a> static operator() (Barry Revzin, Casey Carter)</h5>
<blockquote>
<p>
The proposal is to just allow the ability to make the call operator a static member function, instead of requiring it to be a non-static member function. We have many years of experience with member-less function objects being useful.
</p>
</blockquote>

<p>
tags: CWG, LWG, straw-poll, C++23, tentatively-ready-for-plenary, IS, B3 - addition, size - medium, plenary-approved, expedited-library-&#x2026;
</p>



</section>
</section>
<section>
<section id="slide-p1467-extended-floating-point-types-michał-dominiak-david-olsen">
<h5 id="p1467-extended-floating-point-types-michał-dominiak-david-olsen"><a href="https://wg21.link/p1467">P1467</a> Extended floating-point types (Michał Dominiak, David Olsen)</h5>
<blockquote>
<p>
This paper introduces the notion of <u>extended floating-point types</u>, modeled
after extended integer types. To accomodate them, this paper also attempts to
rewrite the current rules for floating-point types, to enable well-defined
interactions between all the floating-point types. The end goal of this paper,
together with [P1468], is to have a language to enable <code>&lt;cstdint&gt;</code>-like aliases
for implementation specific floating point types, that can model more binary
layouts than just a single fundamental type (the previously proposed short
float) can provide for
</p>
</blockquote>
<p>
tags: CWG, LWG, straw-poll, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p1642-freestanding-library-easy-utilities-ben-craig">
<h5 id="p1642-freestanding-library-easy-utilities-ben-craig"><a href="https://wg21.link/p1642">P1642</a> Freestanding Library: Easy [utilities] (Ben Craig)</h5>
<blockquote>
<p>
This paper proposes adding many of the facilities in the <code>[utilities]</code>, <code>[ranges]</code>, and <code>[iterators]</code> clause to the freestanding subset of C++. The paper will be adding only complete entities, and will not tackle partial classes. For example, classes like <code>pair</code> and <code>tuple</code> are being added, but trickier classes like <code>optional</code>, <code>variant</code>, and <code>bitset</code> will come in another paper.
</p>

<p>
The <code>&lt;memory&gt;</code> header depends on facilities in <code>&lt;ranges&gt;</code> and <code>&lt;iterator&gt;</code>, so those headers (and clauses) are addressed as well.
</p>
</blockquote>
<p>
tags: CWG, LWG, SG14, C++23, tentatively-ready-for-plenary, freestanding, IS, B2 - improvement, size - medium, plenary-approved
</p>


</section>
</section>
<section>
<section id="slide-p1787-declarations-and-where-to-find-them-s.-davis-herring">
<h5 id="p1787-declarations-and-where-to-find-them-s.-davis-herring"><a href="https://wg21.link/p1787">P1787</a> Declarations and where to find them (S. Davis Herring)</h5>
<blockquote>
<p>
The current descriptions of scope and name lookup are confusing, incomplete, and at times incorrect.
</p>
</blockquote>

<p>
tags: modules, C++23, IS, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p1938-if-consteval-barry-revzin-daveed-vandevoorde-richard-smith">
<h5 id="p1938-if-consteval-barry-revzin-daveed-vandevoorde-richard-smith"><a href="https://wg21.link/p1938">P1938</a> if consteval (Barry Revzin, Daveed Vandevoorde, Richard Smith)</h5>
<blockquote>
<p>
We propose a new form of if statement which is spelled:
</p>

<p>
<code>if consteval { }</code>
</p>
</blockquote>
<ul class="org-ul">
<li><a id="org8ef4ccb"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">consteval</span> <span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #feacd0;">f</span>(<span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #00d3d0;">i</span>) { <span style="color: #b6a0ff; font-weight: bold;">return</span> i; }

<span style="color: #b6a0ff; font-weight: bold;">constexpr</span> <span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #feacd0;">g</span>(<span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #00d3d0;">i</span>) {
    <span style="color: #b6a0ff; font-weight: bold;">if</span> <span style="color: #b6a0ff; font-weight: bold;">consteval</span> {
        <span style="color: #b6a0ff; font-weight: bold;">return</span> f(i) + 1; <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">ok: immediate function context</span>
    } <span style="color: #b6a0ff; font-weight: bold;">else</span> {
        <span style="color: #b6a0ff; font-weight: bold;">return</span> 42;
    }
}

<span style="color: #b6a0ff; font-weight: bold;">consteval</span> <span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #feacd0;">h</span>(<span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #00d3d0;">i</span>) {
    <span style="color: #b6a0ff; font-weight: bold;">return</span> f(i) + 1; <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">ok: immediate function context</span>
}
</pre>
</div>
<p>
tags: CWG, LWG, C++23, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2036-changing-scope-for-lambda-trailing-return-type-barry-revzin">
<h5 id="p2036-changing-scope-for-lambda-trailing-return-type-barry-revzin"><a href="https://wg21.link/p2036">P2036</a> Changing scope for lambda trailing-return-type (Barry Revzin)</h5>
<blockquote>
<p>
This paper proposes that name lookup in the trailing-return-type of a lambda
first consider that lambda’s captures before looking further outward. We may
not know at the time of parsing the return type which names actually are
captured, so this paper proposes to treat all capturable entities as if they
were captured.
</p>
</blockquote>
<p>
tags: CWG, C++23, plenary-approved
</p>



</section>
</section>
<section>
<section id="slide-p2564-consteval-needs-to-propagate-up-barry-revzin">
<h5 id="p2564-consteval-needs-to-propagate-up-barry-revzin"><a href="https://wg21.link/p2564">P2564</a> consteval needs to propagate up (Barry Revzin)</h5>
<blockquote>
<p>
This paper proposes avoiding the consteval coloring problem (or, at least, mitigating its annoyances) by allowing certain existing constexpr functions to implicitly become consteval functions when those functions can already only be invoked during compile time anyway.
</p>

<p>
Specifically, these three rules:
</p>

<ol>
<li>If a constexpr function contains a call to an immediate function outside of an immediate function context, and that call itself isn’t a constant expression, said constexpr function implicitly becomes a consteval function. This is intended to include lambdas, function template specializations, special member functions, and should cover member initializers as well.</li>

<li>If an expression-id designates a consteval function without it being an immediate call in such a context, it also makes the context implicitly consteval. Such expression-id’s are also allowed in contexts that are manifestly constant evaluated.</li>

<li>Other manifestly constant evaluated contexts (like constant-expression and the condition of a constexpr if statement) are now considered to be immediate function contexts.</li>

</ol>
</blockquote>

<p>
tags: CWG, straw-poll, C++23, nb-comment, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2579-mitigation-strategies-for-p2036-changing-scope-for-lambda-trailing-return-type-corentin">
<h5 id="p2579-mitigation-strategies-for-p2036-changing-scope-for-lambda-trailing-return-type-corentin"><a href="https://wg21.link/p2579">P2579</a> Mitigation strategies for P2036 ”Changing scope for lambda trailing-return-type” (Corentin Jabot)</h5>
<blockquote>
<p>
P2036R3 was adopted for C++23 and as a Defect Report, affecting C++11 and
greater. After implementing this paper in Clang, we observed the proposed
changes make ill-formed previously valid and relied upon code.
</p>
</blockquote>
<blockquote>
<p>
identifiers refered to captured variables but do not take the mutable keyword
into account
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">struct</span> <span style="color: #6ae4b9; font-weight: bold;">F</span> {
<span style="color: #6ae4b9; font-weight: bold;">float</span> <span style="color: #00d3d0;">x</span>;
<span style="color: #6ae4b9; font-weight: bold;">void</span> <span style="color: #feacd0;">mem1</span>(<span style="color: #b6a0ff; font-weight: bold;">decltype</span>((x)) <span style="color: #00d3d0;">p3</span>); <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">p3 is a float&amp;</span>
<span style="color: #6ae4b9; font-weight: bold;">void</span> <span style="color: #feacd0;">mem2</span>(<span style="color: #b6a0ff; font-weight: bold;">decltype</span>((x)) <span style="color: #00d3d0;">p4</span>) <span style="color: #b6a0ff; font-weight: bold;">const</span>; <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">p4 is a float&amp;</span>
};
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #00d3d0;">x</span>;
[<span style="color: #00d3d0;">x</span>=42.0]&lt;<span style="color: #b6a0ff; font-weight: bold;">decltype</span>(x) <span style="color: #00d3d0;">a</span>&gt; <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">float</span>
(<span style="color: #b6a0ff; font-weight: bold;">decltype</span>((x)) b) <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">float&amp;</span>
-&gt; <span style="color: #b6a0ff; font-weight: bold;">decltype</span>((x)) <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">const float&amp;</span>
</pre>
</div>

<p>
tags: CWG, straw-poll, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-org5c8910c">
<h2 id="org5c8910c">Library Working Group Features</h2>
<div class="outline-text-2" id="text-org5c8910c">
</div>
</section>
</section>
<section>
<section id="slide-org6fde1df">
<h3 id="org6fde1df">Ranges</h3>
<ul>
<li>36 Papers + 2 from "Major"</li>

</ul>
</section>
</section>
<section>
<section id="slide-p1659-starts_with-and-ends_with-christopher-di-bella">
<h5 id="p1659-starts_with-and-ends_with-christopher-di-bella"><a href="https://wg21.link/p1659">P1659</a> starts_with and ends_with (Christopher Di Bella)</h5>
<blockquote>
<p>
This proposal seeks to add std::ranges::starts_with and std::ranges::ends_with, which would work on arbitrary ranges, and also answer questions such as "are the starting elements of `r1` less than the elements of `r2`?" and "are the final elements of `r1` greater than the elements of `r2`?"
</p>
</blockquote>
<ul class="org-ul">
<li><a id="orgb1c2515"></a>Before/After Table<br />
<p>
Before:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">some_ints</span>      = <span style="color: #00bcff;">view</span>::iota(0, 50);
<span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">some_more_ints</span> = <span style="color: #00bcff;">view</span>::iota(0, 30);
<span style="color: #b6a0ff; font-weight: bold;">if</span> (<span style="color: #00bcff;">ranges</span>::mismatch(some_ints, some_more_ints).in2 == end(some_more_ints)) {
    <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">do something</span>
}
</pre>
</div>
<p>
After:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">some_ints</span>      = <span style="color: #00bcff;">view</span>::iota(0, 50);
<span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">some_more_ints</span> = <span style="color: #00bcff;">view</span>::iota(0, 30);
<span style="color: #b6a0ff; font-weight: bold;">if</span> (<span style="color: #00bcff;">ranges</span>::starts_with(some_ints, some_more_ints)) {
    <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">do something</span>
}
</pre>
</div>

<p>
tags: LWG, C++23, IS, size - small, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p1989-range-constructor-for-stdstring_view-2-constrain-harder-corentin-jabot">
<h5 id="p1989-range-constructor-for-stdstring_view-2-constrain-harder-corentin-jabot"><a href="https://wg21.link/p1989">P1989</a> Range constructor for std::string_view 2: Constrain Harder (Corentin Jabot)</h5>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">template</span>&lt;<span style="color: #b6a0ff; font-weight: bold;">class</span> <span style="color: #6ae4b9; font-weight: bold;">R</span>&gt;
<span style="color: #feacd0;">basic_string_view</span>(<span style="color: #6ae4b9; font-weight: bold;">R</span>&amp;&amp;)
-&gt; <span style="color: #6ae4b9; font-weight: bold;">basic_string_view</span>&lt;<span style="color: #00bcff;">ranges</span>::<span style="color: #6ae4b9; font-weight: bold;">range_value_t</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">R</span>&gt;&gt;;
</pre>
</div>
<p>
tags: LWG, ranges, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2321-zip-tim-song">
<h5 id="p2321-zip-tim-song"><a href="https://wg21.link/p2321">P2321</a> zip (Tim Song)</h5>
<blockquote>
<p>
This paper proposes
</p>
<ul>
<li>four views, zip, zip_transform, adjacent, and adjacent_transform,</li>
<li>changes to tuple and pair necessary to make them usable as proxy references (necessary for zip and adjacent), and</li>
<li>changes to vector&lt;bool&gt;::reference to make it usable as a proxy reference for writing,</li>

</ul>
</blockquote>

<ul class="org-ul">
<li><a id="orga00aefd"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">vector</span> <span style="color: #00d3d0;">v1</span> = {1, 2};
<span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">vector</span> <span style="color: #00d3d0;">v2</span> = {<span style="color: #79a8ff;">'a'</span>, <span style="color: #79a8ff;">'b'</span>, <span style="color: #79a8ff;">'c'</span>};
<span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">vector</span> <span style="color: #00d3d0;">v3</span> = {3, 4, 5};

<span style="color: #00bcff;">fmt</span>::print(<span style="color: #79a8ff;">"{}\n"</span>, <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">views</span>::zip(v1, v2));                              <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">{(1, 'a'), (2, 'b')}</span>
<span style="color: #00bcff;">fmt</span>::print(<span style="color: #79a8ff;">"{}\n"</span>, <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">views</span>::zip_transform(<span style="color: #00bcff;">std</span>::multiplies(), v1, v3)); <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">{3, 8}</span>
<span style="color: #00bcff;">fmt</span>::print(<span style="color: #79a8ff;">"{}\n"</span>, v2 | <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">views</span>::pairwise);                            <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">{('a', 'b'), ('b', 'c')}</span>
<span style="color: #00bcff;">fmt</span>::print(<span style="color: #79a8ff;">"{}\n"</span>, v3 | <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">views</span>::pairwise_transform(<span style="color: #00bcff;">std</span>::plus()));     <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">{7, 9}</span>
</pre>
</div>
<p>
tags: LWG, ranges, C++23, IS, B3 - addition, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2302-prefer-stdrangescontains-over-stdbasic_string_viewcontains-christopher-di-bella">
<h5 id="p2302-prefer-stdrangescontains-over-stdbasic_string_viewcontains-christopher-di-bella"><a href="https://wg21.link/p2302">P2302</a> Prefer std::ranges::contains over std::basic_string_view::contains (Christopher Di Bella)</h5>
<blockquote>
<p>
P2302 proposes two algorithms: one that checks whether or not a range contains an element, and one that checks whether or not a range contains a subrange
</p>
</blockquote>
<p>
Before:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">namespace</span> <span style="color: #00bcff;">stdr</span> = <span style="color: #00bcff;">std</span>::ranges;
<span style="color: #00bcff;">stdr</span>::find(haystack.begin(), haystack.end(), <span style="color: #79a8ff;">'o'</span>) != haystack.end()
<span style="color: #00bcff;">stdr</span>::find(haystack, <span style="color: #79a8ff;">'o'</span>) != <span style="color: #00bcff;">stdr</span>::end(haystack)
<span style="color: #b6a0ff; font-weight: bold;">not</span> <span style="color: #00bcff;">stdr</span>::search(haystack, long_needle).empty()
<span style="color: #b6a0ff; font-weight: bold;">not</span> <span style="color: #00bcff;">stdr</span>::search(haystack, long_needle, bind_back(<span style="color: #00bcff;">std</span>::modulo(), 4)).empty()
</pre>
</div>
<p>
After:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">namespace</span> <span style="color: #00bcff;">stdr</span> = <span style="color: #00bcff;">std</span>::ranges;
<span style="color: #00bcff;">stdr</span>::contains(haystack.begin(), haystack.end(), <span style="color: #79a8ff;">'o'</span>)
<span style="color: #00bcff;">stdr</span>::contains(haystack, <span style="color: #79a8ff;">'o'</span>)
<span style="color: #00bcff;">stdr</span>::contains_subrange(haystack, long_needle)
<span style="color: #00bcff;">stdr</span>::contains_subrange(haystack, long_needle, bind_back(<span style="color: #00bcff;">std</span>::modulo(), 4))
</pre>
</div>
<p>
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2322-rangesfold-barry-revzin">
<h5 id="p2322-rangesfold-barry-revzin"><a href="https://wg21.link/p2322">P2322</a> ranges::fold (Barry Revzin)</h5>
<blockquote>
<p>
While we do have an iterator-based version of fold in the standard library, it is currently named accumulate, defaults to performing + on its operands, and is found in the header &lt;numeric&gt;. But fold is much more than addition, so as described in the linked paper, it’s important to give it the more generic name and to avoid a default operator.
</p>
</blockquote>
<p>
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2387-pipe-support-for-user-defined-range-adaptors-barry-revzin">
<h5 id="p2387-pipe-support-for-user-defined-range-adaptors-barry-revzin"><a href="https://wg21.link/p2387">P2387</a> Pipe support for user-defined range adaptors (Barry Revzin)</h5>
<blockquote>
<p>
Walter Brown made an excellent observation: if we gave users the tools to write their own range adaptors that would properly inter-operate with standard library adaptors (as well as other users’ adaptors), then it becomes less important to provide more adaptors in the standard library.
</p>

<p>
The goal of this paper is provide that functionality: provide a standard customization mechanism for range adaptors, so that everybody can write their own adaptors.
</p>
</blockquote>

<p>
tags: LWG, ranges, C++23, IS, B2 - improvement, size - medium, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2325-views-should-not-be-required-to-be-default-constructible-barry-revzin">
<h5 id="p2325-views-should-not-be-required-to-be-default-constructible-barry-revzin"><a href="https://wg21.link/p2325">P2325</a> Views should not be required to be default constructible (Barry Revzin)</h5>
<blockquote>
<p>
Currently, the view concept is defined in 24.4.4 [range.view] as:
</p>
</blockquote>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">template</span> &lt;<span style="color: #b6a0ff; font-weight: bold;">class</span> <span style="color: #6ae4b9; font-weight: bold;">T</span>&gt;
<span style="color: #b6a0ff; font-weight: bold;">concept</span> <span style="color: #6ae4b9; font-weight: bold;">view</span> =
    <span style="color: #6ae4b9; font-weight: bold;">range</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">T</span>&gt; &amp;&amp;
    <span style="color: #6ae4b9; font-weight: bold;">movable</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">T</span>&gt; &amp;&amp;
    <span style="color: #6ae4b9; font-weight: bold;">default_initializable</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">T</span>&gt; &amp;&amp;
    <span style="color: #6ae4b9; font-weight: bold;">enable_view</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">T</span>&gt;;
</pre>
</div>
<ul class="org-ul">
<li><a id="org7eef56d"></a>Discussion<br />
<blockquote>
<p>
Three of these four criteria, I understand. A view clearly needs to be a range, and it’s important that they be movable for various operations to work. And the difference between a view and range is largely semantic, and so there needs to be an explicit opt-in in the form of enable_view.
</p>

<p>
But why does a view need to be default_initializable?
</p>
</blockquote>
<p>
tags: LWG, ranges, C++23, IS, B2 - improvement, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2367-remove-misuses-of-list-initialization-from-clause-24-tim-song">
<h5 id="p2367-remove-misuses-of-list-initialization-from-clause-24-tim-song"><a href="https://wg21.link/p2367">P2367</a> Remove misuses of list-initialization from Clause 24 (Tim Song)</h5>
<blockquote>
<p>
This paper provides wording for [LWG3524] and resolves related issues caused by the erroneous use of list-initialization in ranges wording.
</p>
</blockquote>

<blockquote>
<p>
As discussed in [LWG3524], the use of list-initialization in the ranges specification implies ordering guarantees that are unintended and unimplementable in ordinary C++, as well as narrowing checks that are unnecessary and sometimes unimplementable.
</p>
</blockquote>
<p>
tags: LWG, C++23, plenary-approved
</p>


</section>
</section>
<section>
<section id="slide-p2432-fix-istream_view-nicolai-josuttis">
<h5 id="p2432-fix-istream_view-nicolai-josuttis"><a href="https://wg21.link/P2432">P2432</a> Fix istream_view (Nicolai Josuttis)</h5>
<blockquote>
<p>
This paper fixes a fundamental design problem with the current helper function
std::ranges::istream_view&lt;&gt;() that cause multiple inconsistences and unnecessary code
overhead when declaring istream_view objects
</p>
</blockquote>
<p>
Before:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">ranges</span>::<span style="color: #6ae4b9; font-weight: bold;">istream_view</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&gt; <span style="color: #00d3d0;">v</span>{mystream}
 <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">ERROR</span>
</pre>
</div>
<p>
After:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">ranges</span>::<span style="color: #6ae4b9; font-weight: bold;">istream_view</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&gt; <span style="color: #00d3d0;">v</span>{mystream}
 <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">OK</span>
</pre>
</div>
<p>
tags: LWG, ranges, C++23, IS, B2 - improvement, size - small, plenary-approved
</p>


</section>
</section>
<section>
<section id="slide-p2415-what-is-a-view-barry-revzin-tim-song">
<h5 id="p2415-what-is-a-view-barry-revzin-tim-song"><a href="https://wg21.link/p2415">P2415</a> What is a view? (Barry Revzin, Tim Song)</h5>
<blockquote>
<p>
Once upon a time, a view was a cheaply copyable, non-owning range. We’ve already somewhat lost the “cheaply copyable” requirement since views don’t have to be copyable, and now this paper is suggesting that we also lose the non-owning part.
</p>
</blockquote>
<p>
tags: LWG, ranges, C++23, IS, B2 - improvement, size - medium, plenary-approved
</p>


</section>
</section>
<section>
<section id="slide-p2408-ranges-views-as-inputs-to-non-ranges-algorithms-david-olsen">
<h5 id="p2408-ranges-views-as-inputs-to-non-ranges-algorithms-david-olsen"><a href="https://wg21.link/p2408">P2408</a> Ranges views as inputs to non-Ranges algorithms (David Olsen)</h5>
<blockquote>
<p>
Change the iterator requirements for non-Ranges algorithms. For forward iterators and above that are constant iterators, instead of requiring that iterators meet certain <i>Cpp17&#x2026;Iterator</i> requirements, require that the iterators model certain iterator concepts. This makes iterators from several standard views usable with non-Ranges algorithms that require forward iterators or above, such as the parallel overloads of most algorithms.
</p>
</blockquote>
<p>
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2210-superior-string-splitting-barry-revzin">
<h5 id="p2210-superior-string-splitting-barry-revzin"><a href="https://wg21.link/p2210">P2210</a> Superior String Splitting (Barry Revzin)</h5>
<ul class="org-ul">
<li><a id="orge1b79da"></a>Proposal Part 1<br />
<blockquote>
<p>
This paper proposes the following:
Rename the existing <code>views::split</code> / <code>ranges::split_view</code> to <code>views::lazy_split</code> / <code>ranges::lazy_split_view</code>. Add <code>base()</code> member functions to the <code>inner-iterator</code> type to get back to the adapted range’s iterators.
</p>
</blockquote>
</li>

<li><a id="orgd6342eb"></a>Proposal Part 2<br />
<blockquote>
<ol>
<li>Introduce a new range adapter under the name <code>views::split</code> / <code>ranges::split_view</code> with the following design:

<ol>
<li>It can only support splitting forward-or-better ranges.</li>
<li>Splitting a <code>V</code> will yield ~subrange&lt;iterator_t&lt;V&gt;&gt;~s, ensuring that the adapted range’s category is preserved. Splitting a bidirectional range gives out bidirectional subranges. Spltiting a contiguous range gives out contiguous subranges.</li>
<li><code>views::split</code> will not be <code>const</code>-iterable.</li>

</ol></li>

</ol>
</blockquote>
</li>
<li><a id="orgcf8a5e2"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">ip</span> = <span style="color: #79a8ff;">"127.0.0.1"</span><span style="color: #00bcff;">s</span>;
<span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">parts</span> = ip | <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">views</span>::split(<span style="color: #79a8ff;">'.'</span>)
                | <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">views</span>::transform([](<span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">span</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">char</span> <span style="color: #b6a0ff; font-weight: bold;">const</span>&gt; <span style="color: #00d3d0;">s</span>){
                      <span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #00d3d0;">i</span>;
                      <span style="color: #00bcff;">std</span>::from_chars(s.data(), s.data() + s.size(), i);
                      <span style="color: #b6a0ff; font-weight: bold;">return</span> i;
                  });
</pre>
</div>
<p>
tags: LWG, ranges, C++23, IS, B2 - improvement, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2440-rangesiota-rangesshift_left-and-rangesshift_right-tim-song">
<h5 id="p2440-rangesiota-rangesshift_left-and-rangesshift_right-tim-song"><a href="https://wg21.link/p2440">P2440</a> ranges::iota, ranges::shift_left, and ranges::shift_right (Tim Song)</h5>
<blockquote>
<p>
This paper proposes adding the algorithms ranges::iota, ranges::shift_left, and ranges::shift_right, to match their std counterparts.
</p>
</blockquote>
<p>
tags: LWG, ranges, C++23, IS, B3 - addition, size - medium, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2443-viewschunk_by-tim-song">
<h5 id="p2443-viewschunk_by-tim-song"><a href="https://wg21.link/p2443">P2443</a> views::chunk_by (Tim Song)</h5>
<blockquote>
<p>
This paper proposes the range adaptor views::chunk_by as described in section 4.3 of [P2214R1].
</p>
</blockquote>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">vector</span> <span style="color: #00d3d0;">v</span> = {1, 2, 2, 3, 0, 4, 5, 2};
<span style="color: #00bcff;">fmt</span>::print(<span style="color: #79a8ff;">"{}\n"</span>, v | <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">views</span>::chunk_by(<span style="color: #00bcff;">ranges</span>::less_equal{}));   <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">[[1, 2, 2, 3], [0, 4, 5], [2]]</span>
</pre>
</div>

<p>
tags: LWG, ranges, C++23, IS, B3 - addition, size - medium, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2328-join_view-should-join-all-views-of-ranges-tim-song">
<h5 id="p2328-join_view-should-join-all-views-of-ranges-tim-song"><a href="https://wg21.link/P2328">P2328</a> join_view should join all views of ranges (Tim Song)</h5>
<blockquote>
<p>
This paper proposes relaxing the constraint on join_view to support joining ranges of prvalue non-view ranges.
</p>
</blockquote>
<p>
tags: LWG, ranges, C++23, IS, B2: Improvement, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2442-windowing-range-adaptors-viewschunk-and-viewsslide-tim-song">
<h5 id="p2442-windowing-range-adaptors-viewschunk-and-viewsslide-tim-song"><a href="https://wg21.link/p2442">P2442</a> Windowing range adaptors: views::chunk and views::slide (Tim Song)</h5>
<blockquote>
<p>
This paper proposes two range adaptors, views::chunk and views::slide, as described in section 3.5 of [P2214R0].
</p>
</blockquote>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">vector</span> <span style="color: #00d3d0;">v</span> = {1, 2, 3, 4, 5};
<span style="color: #00bcff;">fmt</span>::print(<span style="color: #79a8ff;">"{}\n"</span>, v | <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">views</span>::chunk(2));   <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">[[1, 2], [3, 4], [5]]</span>
<span style="color: #00bcff;">fmt</span>::print(<span style="color: #79a8ff;">"{}\n"</span>, v | <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">views</span>::slide(2));   <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">[[1, 2], [2, 3], [3, 4], [4, 5]]</span>
</pre>
</div>
<p>
tags: LWG, ranges, C++23, IS, B3 - addition, size - medium, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2441-viewsjoin_with-barry-revzin">
<h5 id="p2441-viewsjoin_with-barry-revzin"><a href="https://wg21.link/p2441">P2441</a> views::join_with (Barry Revzin)</h5>
<blockquote>
<p>
The behavior of <code>views::join_with</code> is an inverse of <code>views::split</code>. That is, given a range <code>r</code> and a pattern <code>p</code>, <code>r | views::split(p) | views::join_with(p)</code> should yield a range consisting of the same elements as <code>r</code>.
</p>
</blockquote>
<p>
tags: LWG, ranges, C++23, IS, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2446-viewsmove-barry-revzin">
<h5 id="p2446-viewsmove-barry-revzin"><a href="https://wg21.link/p2446">P2446</a> views::move (Barry Revzin)</h5>
<blockquote>
<p>
<code>as_rvalue_view</code> presents a view of an underlying sequence with the same behavior as the underlying sequence except that its elements are rvalues. Some generic algorithms can be called with a as_rvalue_view to replace copying with moving.
</p>

<p>
The name views::as_rvalue denotes a range adaptor object ([range.adaptor.object]).
</p>
</blockquote>
<p>
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2494-relaxing-range-adaptors-to-allow-for-move-only-types-michał-dominiak">
<h5 id="p2494-relaxing-range-adaptors-to-allow-for-move-only-types-michał-dominiak"><a href="https://wg21.link/p2494">P2494</a> Relaxing range adaptors to allow for move only types (Michał Dominiak)</h5>
<blockquote>
<p>
Currently, many range adaptors require that the user-provided types they store must be copy constructible, which is also required by the assignment wrapper they use, copyable-box.
</p>
</blockquote>

<blockquote>
<p>
Similarly to how [P2325R3] turned semiregular-box into copyable-box, this paper proposes to turn copyable-box into movable-box. This name is probably not ideal, because it still turns types that happen to be copy constructible into copyable types, but it follows from the prior changes to the wrapper.
</p>
</blockquote>
<p>
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2502-stdgenerator-synchronous-coroutine-generator-for-ranges-casey-carter">
<h5 id="p2502-stdgenerator-synchronous-coroutine-generator-for-ranges-casey-carter"><a href="https://wg21.link/P2502">P2502</a> std::generator: Synchronous Coroutine Generator for Ranges (Casey Carter)</h5>
<blockquote>
<p>
We propose a standard library type std::generator which implements a coroutine generator
that models std::ranges::input_range.
</p>
</blockquote>
<ul class="org-ul">
<li><a id="orgbce1c17"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">generator</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&gt; <span style="color: #feacd0;">fib</span>() {
    <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">a</span> = 0, <span style="color: #00d3d0;">b</span> = 1;
    <span style="color: #b6a0ff; font-weight: bold;">while</span> (<span style="color: #00bcff;">true</span>) {
        <span style="color: #b6a0ff; font-weight: bold;">co_yield</span> <span style="color: #00bcff;">std</span>::exchange(a, <span style="color: #00bcff;">std</span>::exchange(b, a + b));
    }
}
<span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #feacd0;">answer_to_the_universe</span>() {
    <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">rng</span> = fib() | <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">views</span>::drop(6) | <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">views</span>::take(3);
    <span style="color: #b6a0ff; font-weight: bold;">return</span> <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">ranges</span>::fold_left(<span style="color: #00bcff;">std</span>::move(range), 0, <span style="color: #00bcff;">std</span>::plus{});
}
</pre>
</div>
<p>
tags: LWG, coroutines, ranges, C++23, tentatively-ready-for-plenary, IS, B1 - focus, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2281-clarifying-range-adaptor-objects-tim-song">
<h5 id="p2281-clarifying-range-adaptor-objects-tim-song"><a href="https://wg21.link/p2281">P2281</a> Clarifying range adaptor objects (Tim Song)</h5>
<blockquote>
<p>
The wording below clarifies that the partial application performed by range adaptor objects is essentially identical to that performed by bind_front. (Indeed, it is effectively a limited version of bind_back.) In particular, this means that the bound arguments are captured by copy or move, and never by reference. Invocation of the pipeline then either copies or moves the bound entities, depending on the value category of the pipeline.
</p>
</blockquote>
<ul class="org-ul">
<li><a id="orgad5e711"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">c</span> = <span style="color: #ff9f80; font-style: italic;">/* </span><span style="color: #ff9f80; font-style: italic;">some range</span><span style="color: #ff9f80; font-style: italic;"> */</span>;
<span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">f</span> = <span style="color: #ff9f80; font-style: italic;">/* </span><span style="color: #ff9f80; font-style: italic;">expensive-to-copy function object</span><span style="color: #ff9f80; font-style: italic;"> */</span>;
c | transform(f); <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">copies f and then move it into the view</span>

<span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">t</span> = transform(f); <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">copies f</span>
c | t;                 <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">copies f again from t</span>
c | <span style="color: #00bcff;">std</span>::move(t);      <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">moves f from t</span>
</pre>
</div>
<p>
tags: LWG, C++23, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p0429r6-a-standard-flatmap-zach-laine">
<h5 id="p0429r6-a-standard-flatmap-zach-laine"><a href="https://wg21.link/p0429">P0429</a> A Standard flatmap (Zach Laine)&#x2026;</h5>
<blockquote>
<p>
This paper outlines what a (mostly) API-compatible, non-node-based map might
look like. Rather than presenting a final design, this paper is intended as a
starting point for discussion and as a basis for future work. Specifically,
there is no mention of <code>multimap</code>, <code>set</code>, or <code>multiset</code>.
</p>
</blockquote>

<p>
The final paper has wording for a map based on contiguous storage of keys and data.
tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p1222-a-standard-flatset-zach-laine">
<h5 id="p1222-a-standard-flatset-zach-laine"><a href="https://wg21.link/p1222">P1222</a> A Standard flatset (Zach Laine)</h5>
<blockquote>
<p>
This paper outlines what a (mostly) API-compatible, non-node-based set might look like.
</p>
</blockquote>
<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p1899-stride_view-christopher-di-bella">
<h5 id="p1899-stride_view-christopher-di-bella"><a href="https://wg21.link/p1899">P1899</a> stride_view (Christopher Di Bella)</h5>
<blockquote>
<p>
The ability to use algorithms over an evenly-spaced subset of a range has been missed in the STL for a quarter of a century. Given that there’s no way to compose a strided range adaptor in C++20, this should be adopted for C++23.
</p>
</blockquote>
<p>
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, plenary-approved, expedited-library-evolution-electronic-poll
</p>

</section>
</section>
<section>
<section id="slide-p2017-conditionally-safe-ranges-barry-revzin">
<h5 id="p2017-conditionally-safe-ranges-barry-revzin"><a href="https://wg21.link/p2017">P2017</a> Conditionally safe ranges (Barry Revzin)</h5>
<blockquote>
<p>
Several range adapters semantically behave as if they have a single member of some templated view type. If that underlying view type is a <code>borrowed_range</code>, the range adapter itself can be transitively borrowed.
</p>
</blockquote>
<p>
tags: ranges, C++23, IS, size - small, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2164-viewsenumerate-corentin-jabot">
<h5 id="p2164-viewsenumerate-corentin-jabot"><a href="https://wg21.link/p2164">P2164</a> views::enumerate (Corentin Jabot)</h5>
<blockquote>
<p>
<u>A struct with 2 members, how hard can it be?</u>
</p>
</blockquote>

<blockquote>
<p>
We propose a view <code>enumerate</code> whose value type is a <del>struct with 2 members index and value</del> <u>tuple of two elements</u>
representing respectively the position and value of the elements in the adapted range.
</p>
</blockquote>
<p>
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B3 - addition, size - medium, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2165-comparing-pair-and-tuples-corentin-jabot">
<h5 id="p2165-comparing-pair-and-tuples-corentin-jabot"><a href="https://wg21.link/p2165">P2165</a> Compatibility between <code>tuple</code>, <code>pair</code> and <u>tuple-like</u> objects (Corentin Jabot)</h5>
<blockquote>
<p>
We propose to make pair constructible from <code>tuple</code> and <code>std::array</code> We mandate
<code>tuple_cat</code> and friends to be compatible with these types, and associative
containers more compatible with them. The changes proposed in this paper make
the use of <code>std::pair</code> unnecessary in new code
</p>
</blockquote>

<p>
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, lwg-fullreview, B2 - improvement, size - medium, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2278-cbegin-should-always-return-a-constant-iterator-barry-revzin">
<h5 id="p2278-cbegin-should-always-return-a-constant-iterator-barry-revzin"><a href="https://wg21.link/p2278">P2278</a> cbegin should always return a constant iterator (Barry Revzin)</h5>
<blockquote>
<p>
<code>cbegin</code> should always return a constant iterator.
</p>
</blockquote>

<ul class="org-ul">
<li><a id="org8a32ab0"></a>Proposal<br />
<blockquote>
<p>
We can resolve this by extending <code>std::ranges::cbegin</code> and <code>std::ranges::cend</code>
to conditionally wrap their provided range’s iterator/sentinel pairs to ensure
that the result is a constant iterator, and use these tools to build up a
views::as_const range adapter. This completely solves the problem without any
imposed boilerplate per range.
</p>
</blockquote>
<p>
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2374-viewscartesian_product-sy-brand">
<h5 id="p2374-viewscartesian_product-sy-brand"><a href="https://wg21.link/p2374">P2374</a> views::cartesian_product (Sy Brand, Michał Dominiak )</h5>
<blockquote>
<p>
This paper proposes std::ranges::cartesian_product_view for taking the cartesian product of multiple forward ranges.
</p>
</blockquote>

<ul class="org-ul">
<li><a id="orge3882d0"></a>Before<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">vector</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&gt; <span style="color: #00d3d0;">a</span>,<span style="color: #00d3d0;">b</span>,<span style="color: #00d3d0;">c</span>;
<span style="color: #b6a0ff; font-weight: bold;">for</span> (<span style="color: #b6a0ff; font-weight: bold;">auto</span>&amp;&amp; <span style="color: #00d3d0;">ea</span> : a) {
    <span style="color: #b6a0ff; font-weight: bold;">for</span> (<span style="color: #b6a0ff; font-weight: bold;">auto</span>&amp;&amp; <span style="color: #00d3d0;">eb</span> : b) {
        <span style="color: #b6a0ff; font-weight: bold;">for</span> (<span style="color: #b6a0ff; font-weight: bold;">auto</span>&amp;&amp; <span style="color: #00d3d0;">ec</span> : c) {
            use(ea,eb,ec);
        }
    }
}
</pre>
</div>
</li>
<li><a id="orgd1f34d5"></a>After<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">vector</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&gt; <span style="color: #00d3d0;">a</span>,<span style="color: #00d3d0;">b</span>,<span style="color: #00d3d0;">c</span>;
<span style="color: #b6a0ff; font-weight: bold;">for</span> (<span style="color: #b6a0ff; font-weight: bold;">auto</span>&amp;&amp; [<span style="color: #00bcff;">ea</span>,<span style="color: #00bcff;">eb</span>,<span style="color: #00bcff;">ec</span>] : <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">views</span>::cartesian_product(a,b,c)) {
    use(ea,eb,ec);
}
</pre>
</div>
<p>
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2404-relaxing-equality_comparable_withs-and-three_way_comparable_withs-common-reference-requir">
<h5 id="p2404-relaxing-equality_comparable_withs-and-three_way_comparable_withs-common-reference-requir"><a href="https://wg21.link/p2404">P2404</a> Relaxing equality_comparable_with's and three_way_comparable_with's common reference requir&#x2026;</h5>
<blockquote>
<p>
None of <code>equality_comparable_with</code>, <code>totally_ordered_with</code>, or
<code>three_way_comparable_with</code> support move-only types. For move-only types, these
concept’s common reference requirement currently ends up requiring that the two
types <code>const T&amp;</code> and <code>const U&amp;</code> can be converted to the non-reference
<code>common_reference_t</code>, meaning that it requires <code>T</code> and <code>U</code> to be copyable. This
common reference requirement should be relaxed to support these move-only
types, effectively turning the common reference requirement into a common
<u>supertype</u> requirement, as the original reason to require formable references
no longer exists.
</p>
</blockquote>
<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, expedited-library-evolution-electronic-poll
</p>

</section>
</section>
<section>
<section id="slide-p2474-viewsrepeat-michał-dominiak">
<h5 id="p2474-viewsrepeat-michał-dominiak"><a href="https://wg21.link/p2474">P2474</a> views::repeat (Michał Dominiak)</h5>
<blockquote>
<p>
This paper proposes a new range factory, views::repeat, which creates a range that repeats the same value either infinitely, or a specified number of times.
</p>
</blockquote>

<p>
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B3 - addition, size - small, plenary-approved, expedited-library-evolution-&#x2026;
</p>

</section>
</section>
<section>
<section id="slide-p2499-string_view-range-constructor-should-be-explicit-james-touton">
<h5 id="p2499-string_view-range-constructor-should-be-explicit-james-touton"><a href="https://wg21.link/p2499">P2499</a> string_view range constructor should be explicit (James Touton)</h5>
<blockquote>
<p>
P1989R2 added a new constructor to <code>basic_string_view</code> that allows for implicit conversion from any contiguous range of the corresponding character type. This implicit conversion relies on the premise that a range of <code>char</code> is inherently string-like. While that premise holds in some situations, it is hardly universally true, and the implicit conversion is likely to cause problems. This paper proposes making the conversion explicit instead of implicit in order to avoid misleading programmers.
</p>
</blockquote>
<p>
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2520-move_iterator-should-be-a-random-access-iterator-barry-revzin">
<h5 id="p2520-move_iterator-should-be-a-random-access-iterator-barry-revzin"><a href="https://wg21.link/p2520">P2520</a> move_iterator should be a random access iterator (Barry Revzin)</h5>
<blockquote>
<p>
<code>move_iterator&lt;T*&gt;</code> should be a random access iterator
</p>
</blockquote>
<p>
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved, expedited-library-evoluti&#x2026;
</p>

</section>
</section>
<section>
<section id="slide-p2540-empty-product-for-certain-views-steve-downey">
<h5 id="p2540-empty-product-for-certain-views-steve-downey"><a href="https://wg21.link/p2540">P2540</a> Empty Product for certain Views (Steve Downey)</h5>
<blockquote>
<p>
This paper argues that the Cartesian product of no ranges should be a single
empty tuple, which is the identity element for Cartesian products. Other
product-like views, however, should not automatically have their identity be
the result, and in particular for zip, as it would introduce unsound
inconsistencies.
</p>
</blockquote>


<p>
tags: LWG, ranges, C++23, tentatively-ready-for-plenary, IS, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2602-poison-pills-are-too-toxic-barry-revzin">
<h5 id="p2602-poison-pills-are-too-toxic-barry-revzin"><a href="https://wg21.link/p2602">P2602</a> Poison Pills are Too Toxic (Barry Revzin)</h5>
<p>
Given the following declarations:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">struct</span> <span style="color: #6ae4b9; font-weight: bold;">A</span> {
    <span style="color: #b6a0ff; font-weight: bold;">friend</span> <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #feacd0;">begin</span>(<span style="color: #6ae4b9; font-weight: bold;">A</span> <span style="color: #b6a0ff; font-weight: bold;">const</span>&amp;) -&gt; <span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #b6a0ff; font-weight: bold;">const</span>*;
    <span style="color: #b6a0ff; font-weight: bold;">friend</span> <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #feacd0;">end</span>(<span style="color: #6ae4b9; font-weight: bold;">A</span> <span style="color: #b6a0ff; font-weight: bold;">const</span>&amp;)   -&gt; <span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #b6a0ff; font-weight: bold;">const</span>*;
};

<span style="color: #b6a0ff; font-weight: bold;">struct</span> <span style="color: #6ae4b9; font-weight: bold;">B</span> {
    <span style="color: #b6a0ff; font-weight: bold;">friend</span> <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #feacd0;">begin</span>(<span style="color: #6ae4b9; font-weight: bold;">B</span>&amp;) -&gt; <span style="color: #6ae4b9; font-weight: bold;">int</span>*;
    <span style="color: #b6a0ff; font-weight: bold;">friend</span> <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #feacd0;">end</span>(<span style="color: #6ae4b9; font-weight: bold;">B</span>&amp;) -&gt; <span style="color: #6ae4b9; font-weight: bold;">int</span>*;
};
</pre>
</div>

<p>
B and const A satisfy std::ranges::range, but A does not. The goal of this paper is that both of these should count as ranges.
</p>

<p>
tags: LWG, ranges, C++23, IS, B2 - improvement, size - small, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2609-relaxing-ranges-just-a-smidge-john-eivind-helset">
<h5 id="p2609-relaxing-ranges-just-a-smidge-john-eivind-helset"><a href="https://wg21.link/p2609">P2609</a> Relaxing Ranges Just A Smidge (John Eivind Helset)</h5>
<blockquote>
<p>
Ranges algorithms that take a function and a projection should, in the unary case, constrain the function to enable:
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #6ae4b9; font-weight: bold;">iter_value_t</span>&lt;It&gt; <span style="color: #00d3d0;">x</span> = *it;
f(proj(x));
</pre>
</div>

<blockquote>
<p>
Instead they are constrained to allow:
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #6ae4b9; font-weight: bold;">iter_value_t</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">projected</span>&lt;I,Proj&gt;&gt; <span style="color: #00d3d0;">u</span> = proj(*it);
f(u);
</pre>
</div>

<blockquote>
<p>
And likewise in the binary case. This is caused by the composition of indirect callable concepts with projected, seen for example in the constraints of ranges::for_each as indirect_unary_invocable&lt;projected&lt;I,P&gt;&gt;.
</p>

<p>
A fix is proposed that introduces a type-trait and makes a slight change to the definitions of the indirect callable concepts, as well as iter_common_reference_t. The fix is a slight relaxation of the algorithmic constraints in ranges that does not break ABI.
</p>
</blockquote>

<p>
tags: LWG, ranges, C++23, IS, B2 - improvement, size - small, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-org117ee05">
<h3 id="org117ee05"><code>mdspan</code></h3>
<ul>
<li>5 Papers + 1</li>

</ul>
</section>
</section>
<section>
<section id="slide-p2553-make-mdspan-size_type-controllable-christian-trott-damien-lebrun-grandie-mark-hoemmen-d">
<h5 id="p2553-make-mdspan-size_type-controllable-christian-trott-damien-lebrun-grandie-mark-hoemmen-d"><a href="https://wg21.link/p2553">P2553</a> Make mdspan size_type controllable (Christian Trott, Damien Lebrun-Grandie, Mark Hoemmen, K. R. Walker, Daniel Sunderland)</h5>
<blockquote>
<p>
P0009 explicitly sets the size_type of extents to size_t, which is then used by layout mappings and mdspan. While this matches span whose extent function returns size_t, this behavior has significant performance impact on various architectures where 64-bit integer throughput is significantly lower than 32-bit integer computation throughput.
</p>
</blockquote>

<p>
Proposal:
</p>

<blockquote>
<p>
All in all we prefer the option of making extents require the additional argument (2.2.2), with the next best thing being the introduction basic_extents and making extents an alias to basic_extents with size_t as the size_type. If LEWG would prefer the second option, the wording is largely the same with the following changes at the end:
</p>

<ul>
<li>Rename extents to basic_extents throughout P0009 and</li>

<li>Add an alias in [mdspan.syn]:</li>

</ul>
</blockquote>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">template</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">size_t</span> <span style="color: #feacd0;">...</span> <span style="color: #00d3d0;">Extents</span>&gt;
<span style="color: #b6a0ff; font-weight: bold;">using</span> <span style="color: #6ae4b9; font-weight: bold;">extents</span> = <span style="color: #6ae4b9; font-weight: bold;">basic_extents</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">size_t</span>, Extents<span style="color: #feacd0;">...</span>&gt;;
</pre>
</div>
<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, mdspan
</p>

</section>
</section>
<section>
<section id="slide-p2554-c-array-interoperability-of-mdspan-christian-trott-damien-lebrun-grandie-mark-hoemmen-k">
<h5 id="p2554-c-array-interoperability-of-mdspan-christian-trott-damien-lebrun-grandie-mark-hoemmen-k"><a href="https://wg21.link/p2554">P2554</a> C-Array Interoperability of MDSpan (Christian Trott, Damien Lebrun-Grandie, Mark Hoemmen, K. R. Walker, Daniel Sunderland)</h5>
<blockquote>
<p>
We cannot currently fix the multidimensional c-array construction, since it is UB to alias a nested C-Array with a element type pointer - per discussion on the C++ committee reflector in January 2022. However, in practice it works (on the compilers we tested e.g. clang-based and gcc) - and it may be something the committee changes in the future - i.e. make it not-UB. We propotyped this capability, which requires an additional constructor from c-array and a few deduction guides.
</p>

<p>
What we can fix today is the deduction from 1D c-array, by adding a deduction guide from c-array constraint to rank-1 arrays.
</p>
</blockquote>

<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, mdspan
</p>

</section>
</section>
<section>
<section id="slide-p2599-mdspansize_type-should-be-index_type-nevin-liber">
<h5 id="p2599-mdspansize_type-should-be-index_type-nevin-liber"><a href="https://wg21.link/P2599">P2599</a> mdspan::size_type should be index_type (Nevin Liber)</h5>
<blockquote>
<p>
With the adoption of P2553R1, <code>mdspan::size_type</code> may now be a signed type.
<code>size_type</code> is no longer an appropriate name for this type and it should be changed to <code>index_type</code>.
</p>
</blockquote>

<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, mdspan
</p>

</section>
</section>
<section>
<section id="slide-p2604-mdspan-rename-pointer-and-contiguous-christian-trott">
<h5 id="p2604-mdspan-rename-pointer-and-contiguous-christian-trott"><a href="https://wg21.link/P2604">P2604</a> mdspan: rename pointer and contiguous (Christian Trott)</h5>
<blockquote>
<p>
During LWG review a few members of classes in the mdspan proposals were identified as problematic, this paper proposes renaming those members.
</p>
</blockquote>

<ul class="org-ul">
<li><a id="org349a368"></a><code>pointer</code> to <code>data_handle_type</code><br /></li>
<li><a id="org6088496"></a><code>data()</code> to <code>data_handle()</code><br /></li>
<li><a id="org9bb1a23"></a><code>contiguous</code> to <code>exhaustive</code><br />
<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, mdspan
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2613-add-the-missing-empty-to-mdspan-yihe-le">
<h5 id="p2613-add-the-missing-empty-to-mdspan-yihe-le"><a href="https://wg21.link/p2613">P2613</a> Add the missing <code>empty</code> to <code>mdspan</code> (Yihe Le)</h5>
<blockquote>
<p>
This paper propose to fix a defect in [P0009R17]. During its LWG review, I found that even though the proposed std::mdspan type have a size() member function, it does not have an empty() member function, which makes it distinct from nearly all other STL containers. So this paper propose to add the missing member to increase consistency and performance of common operations.
</p>
</blockquote>

<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, mdspan
</p>

</section>
</section>
<section>
<section id="slide-org4157f5f">
<h3 id="org4157f5f">Output</h3>
<ul>
<li>8 Papers</li>

</ul>
</section>
</section>
<section>
<section id="slide-p1147-printing-volatile-pointers-bryce-adelstein-lelbach">
<h5 id="p1147-printing-volatile-pointers-bryce-adelstein-lelbach"><a href="https://wg21.link/p1147">P1147</a> Printing <code>volatile</code> Pointers (Bryce Adelstein Lelbach)</h5>
<blockquote>
<p>
Printing pointers to volatile types with standard library output streams has unexpected results. Consider the following code:
</p>
</blockquote>
<ul class="org-ul">
<li><a id="orgcabfa12"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ff7f9f;">#include</span> <span style="color: #79a8ff;">&lt;iostream&gt;</span>

<span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #feacd0;">main</span>() {
    <span style="color: #6ae4b9; font-weight: bold;">int</span>*          <span style="color: #00d3d0;">p0</span> = <span style="color: #b6a0ff; font-weight: bold;">reinterpret_cast</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>*&gt;(<span style="color: #b6a0ff; font-weight: bold;">0x</span><span style="color: #00bcff;">deadbeef</span>);
    <span style="color: #b6a0ff; font-weight: bold;">volatile</span> <span style="color: #6ae4b9; font-weight: bold;">int</span>* <span style="color: #00d3d0;">p1</span> = <span style="color: #b6a0ff; font-weight: bold;">reinterpret_cast</span>&lt;<span style="color: #b6a0ff; font-weight: bold;">volatile</span> <span style="color: #6ae4b9; font-weight: bold;">int</span>*&gt;(<span style="color: #b6a0ff; font-weight: bold;">0x</span><span style="color: #00bcff;">deadbeef</span>);

    <span style="color: #00bcff;">std</span>::cout &lt;&lt; p0 &lt;&lt; <span style="color: #00bcff;">std</span>::endl;
    <span style="color: #00bcff;">std</span>::cout &lt;&lt; p1 &lt;&lt; <span style="color: #00bcff;">std</span>::endl;
}
</pre>
</div>
<blockquote>
<p>
This produces the following output:
</p>

<pre class="example" id="org1881c5d">
0xdeadbeef
</pre>

<p>
1
</p>
</blockquote>
<p>
tags: LWG, C++23, IS, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2216-stdformat-improvements-victor-zverovich">
<h5 id="p2216-stdformat-improvements-victor-zverovich"><a href="https://wg21.link/p2216">P2216</a> std::format improvements (Victor Zverovich)</h5>
<blockquote>
<p>
This paper proposes the following improvements to the C++20 formatting facility:
</p>
<ul>
<li>Improving safety via compile-time format string checks</li>
<li>Reducing binary code size of format_to</li>

</ul>
</blockquote>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">string</span> <span style="color: #00d3d0;">s</span> = <span style="color: #00bcff;">std</span>::format(<span style="color: #79a8ff;">"{:d}"</span>, <span style="color: #79a8ff;">"I am not a number"</span>);
</pre>
</div>
<p>
Becomes ill-formed
tags: LWG, C++23, IS, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2372-fixing-locale-handling-in-chrono-formatters-victor-zverovich-corentin">
<h5 id="p2372-fixing-locale-handling-in-chrono-formatters-victor-zverovich-corentin"><a href="https://wg21.link/P2372">P2372</a> Fixing locale handling in chrono formatters (Victor Zverovich, Corentin Jabot)</h5>
<blockquote>
<p>
In C++20 "Extending &lt;chrono&gt; to Calendars and Time Zones" ([P0355]) and "Text Formatting" ([P0645]) proposals were integrated ([P1361]). Unfortunately during this integration a design issue was missed: std::format is locale-independent by default and provides control over locale via format specifiers but the new formatter specializations for chrono types are localized by default and don’t provide such control.
</p>
</blockquote>
<ul class="org-ul">
<li><a id="orgb0aba4b"></a>Solution<br />
<blockquote>
<p>
We propose fixing this issue by making chrono formatters locale-independent by default and providing the L specifier to opt into localized formatting in the same way as it is done for all other standard formatters (format.string.std).
</p>
</blockquote>
</li>
<li><a id="org5b6bbaf"></a>Before:<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">s</span> = <span style="color: #00bcff;">std</span>::format(<span style="color: #79a8ff;">"{:%S}"</span>, sec(4.2));
<span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">s == "04,200"</span>

<span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">s</span> = <span style="color: #00bcff;">std</span>::format(<span style="color: #79a8ff;">"{:L%S}"</span>, sec(4.2));
<span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">throws format_error</span>
</pre>
</div>
</li>
<li><a id="org09fa102"></a>After:<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">s</span> = <span style="color: #00bcff;">std</span>::format(<span style="color: #79a8ff;">"{:%S}"</span>, sec(4.2));
<span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">s == "04.200"</span>

<span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">s</span> = <span style="color: #00bcff;">std</span>::format(<span style="color: #79a8ff;">"{:L%S}"</span>, sec(4.2));
<span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">s == "04,200"</span>
</pre>
</div>

<p>
tags: LWG, C++23, IS, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2418-add-support-for-stdgenerator-like-types-to-stdformat-victor-zverovich">
<h5 id="p2418-add-support-for-stdgenerator-like-types-to-stdformat-victor-zverovich"><a href="https://wg21.link/p2418">P2418</a> Add support for std::generator-like types to std::format (Victor Zverovich)</h5>
<blockquote>
<p>
Unfortunately we cannot make std::generator formattable because it is neither const-iterable nor copyable and std::format takes arguments by const&amp;.
</p>
</blockquote>
<blockquote>
<p>
This paper proposes solving the issue by making std::format and other formatting functions take arguments by forwarding references.
</p>
</blockquote>
<p>
tags: LWG, C++23, IS, B2 - improvement, size - medium, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2508-exposing-stdbasic-format-string-barry-revzin">
<h5 id="p2508-exposing-stdbasic-format-string-barry-revzin"><a href="https://wg21.link/p2508">P2508</a> Exposing std::basic-format-string (Barry Revzin)</h5>
<blockquote>
<p>
In 20.20.1 [format.syn], replace the exposition-only names basic-format-string, format-string, and wformat-string with the non-exposition-only names basic_format_string, format_string, and wformat_string.
</p>
</blockquote>
<ul class="org-ul">
<li><a id="orgd0771bf"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">template</span> &lt;<span style="color: #b6a0ff; font-weight: bold;">typename</span><span style="color: #feacd0;">...</span> <span style="color: #6ae4b9; font-weight: bold;">Args</span>&gt;
<span style="color: #6ae4b9; font-weight: bold;">void</span> <span style="color: #feacd0;">log</span>(<span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">format_string</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">Args</span><span style="color: #feacd0;">...</span>&gt; <span style="color: #00d3d0;">s</span>, <span style="color: #6ae4b9; font-weight: bold;">Args</span>&amp;&amp;<span style="color: #feacd0;">...</span> <span style="color: #00d3d0;">args</span>) {
    <span style="color: #b6a0ff; font-weight: bold;">if</span> (logging_enabled) {
        log_raw(<span style="color: #00bcff;">std</span>::format(s, <span style="color: #00bcff;">std</span>::forward&lt;<span style="color: #6ae4b9; font-weight: bold;">Args</span>&gt;(args)<span style="color: #feacd0;">...</span>));
    }
}
</pre>
</div>
<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2419-clarify-handling-of-encodings-in-localized-formatting-of-chrono-types-victor-zverovich">
<h5 id="p2419-clarify-handling-of-encodings-in-localized-formatting-of-chrono-types-victor-zverovich"><a href="https://wg21.link/p2419">P2419</a> Clarify handling of encodings in localized formatting of chrono types (Victor Zverovich)</h5>
<blockquote>
<p>
C++20 added formatting of chrono types with std::format but left unspecified what happens during localized formatting when the locale and literal encodings do not match ([LWG3565]).
</p>
</blockquote>

<ul class="org-ul">
<li><a id="orga2b89c6"></a>Proposal<br />
<blockquote>
<p>
We propose clarifying the specification to prevent mojibake when possible by allowing implementation do transcoding or substituting the locale so that the result is in a consistent encoding.
</p>
</blockquote>
<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, lwg-fullreview, B2 - improvement, size - tiny, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2539-should-the-output-of-stdprint-to-a-terminal-be-synchronized-with-the-underlying-stream">
<h5 id="p2539-should-the-output-of-stdprint-to-a-terminal-be-synchronized-with-the-underlying-stream"><a href="https://wg21.link/p2539">P2539</a> Should the output of std::print to a terminal be synchronized with the underlying stream? (&#x2026;</h5>
<blockquote>
<p>
To prevent mojibake std::print may use a native Unicode API when writing to a terminal bypassing the stream buffer. During the review of [P2093] "Formatted output" Tim Song suggested that synchronizing std::print with the underlying stream may be beneficial for gradual adoption. This paper presents motivating examples, observes that this problem doesn’t normally happen in practice and proposes a minor update to the wording to provide a synchronization guarantee.
</p>
</blockquote>
<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2585-improving-default-container-formatting-barry-revzin">
<h5 id="p2585-improving-default-container-formatting-barry-revzin"><a href="https://wg21.link/p2585">P2585</a> Improving default container formatting (Barry Revzin)</h5>
<blockquote>
<p>
[P2286R8] adds support for formatting any range whose underlying type is formattable. Additionally, it adds support for different kinds of formatting that users can opt into, while also providing a default choice for associating containers that is more suited to what those containers represent.
</p>
</blockquote>

<blockquote>
<p>
However, this distinction is a result of [P2286R8] explicitly providing formatters for all the standard library map and set containers, and applying those changes to them. This is something that users can do for their own containers as well, but which also means that it is something users have to do - if this is the behavior they want.
</p>
</blockquote>

<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, lwg-fullreview, B2 - improvement, size - medium, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-org98890b6">
<h3 id="org98890b6">Constexpr</h3>
<ul>
<li>4 papers</li>

</ul>
</section>
</section>
<section>
<section id="slide-p1328-making-stdtype_infooperator-constexpr-peter-dimov">
<h5 id="p1328-making-stdtype_infooperator-constexpr-peter-dimov"><a href="https://wg21.link/p1328">P1328</a> Making std::type_info::operator== constexpr (Peter Dimov)</h5>
<blockquote>
<p>
This paper proposes std::type_info::operator== and operator!= be made constexpr, enabling practical, rather than theoretical, use of typeid in constant expressions.
</p>
</blockquote>
<p>
tags: LWG, C++23, IS, B3 - addition, size - tiny, plenary-approved
</p>


</section>
</section>
<section>
<section id="slide-p2231-missing-constexpr-in-stdoptional-and-stdvariant-barry-revzin">
<h5 id="p2231-missing-constexpr-in-stdoptional-and-stdvariant-barry-revzin"><a href="https://wg21.link/p2231">P2231</a> Missing <code>constexpr</code> in <code>std::optional</code> and <code>std::variant</code> (Barry Revzin)</h5>
<blockquote>
<p>
But even though the language provided the tools to make <code>std::optional</code> and <code>std::variant</code> completely <code>constexpr</code>-able, there was no such update to the library. This paper seeks to remedy that omission by simply adding <code>constexpr</code> to all the relevant places.
</p>
</blockquote>
<p>
tags: LWG, C++23, IS, B2 - improvement, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2273-making-stdunique_ptr-constexpr-andreas-fertig">
<h5 id="p2273-making-stdunique_ptr-constexpr-andreas-fertig"><a href="https://wg21.link/p2273">P2273</a> Making std::unique_ptr constexpr (Andreas Fertig)</h5>
<blockquote>
<p>
std::unique_ptr is currently not constexpr friendly. With the loosening of requirements on
constexpr in [P0784R10] and the ability to use new and delete in a constexpr­context, we should
also provide a constexpr std::unique_ptr.
</p>
</blockquote>
<ul class="org-ul">
<li><a id="org7e6a2f4"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">constexpr</span> <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #feacd0;">fun</span>() {
    <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">p</span> = <span style="color: #00bcff;">std</span>::make_unique&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&gt;(4);
    <span style="color: #b6a0ff; font-weight: bold;">return</span> *p;
}
<span style="color: #6ae4b9; font-weight: bold;">int</span> <span style="color: #feacd0;">main</span>() {
    <span style="color: #b6a0ff; font-weight: bold;">constexpr</span> <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">i</span> = fun();
    <span style="color: #b6a0ff; font-weight: bold;">static_assert</span>(4 == i);
}
</pre>
</div>

<p>
tags: LWG, C++23, B2 - improvement, plenary-approved, constexpr, expedited-library-evolution-electronic-poll
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2291-add-constexpr-modifiers-to-functions-to_chars-and-from_chars-for-integral-types-in-ch">
<h5 id="p2291-add-constexpr-modifiers-to-functions-to_chars-and-from_chars-for-integral-types-in-ch"><a href="https://wg21.link/p2291">P2291</a> Add Constexpr Modifiers to Functions <code>to_chars</code> and <code>from_chars</code> for Integral Types in <code>&lt;charconv&gt;</code> Header (Daniil Goncharov, Karaev Alexander)</h5>
<blockquote>
<p>
There is currently no standard way to make conversion between numbers and strings <i>at compile time</i>.
</p>

<p>
<code>std::to_chars</code> and <code>std::from_chars</code> are fundamental blocks for parsing and
formatting being localeindependent and non-throwing without memory allocation,
so they look like natural candidates for constexpr string conversions. The
paper proposes to make <code>std::to_chars</code> and <code>std::from_chars</code> functions for <b>integral
types</b> usable in constexpr context.
</p>
</blockquote>
<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved, constexpr, expedited-library-evolution-electronic-poll
</p>

</section>
</section>
<section>
<section id="slide-orgd52b202">
<h3 id="orgd52b202">Other Types and Utilities</h3>
<p>
35 papers
</p>

</section>
</section>
<section>
<section id="slide-p0288r4-any_invocable-ryan-mcdougall-matt-calabrese">
<h5 id="p0288r4-any_invocable-ryan-mcdougall-matt-calabrese"><a href="https://wg21.link/p0288">P0288</a> any_invocable (Ryan McDougall, Matt Calabrese)</h5>
<blockquote>
<p>
This paper proposes a conservative, move-only equivalent of std::function.
</p>
</blockquote>


<p>
tags: LWG, C++23, IS, large, plenary-approved
</p>


</section>
</section>
<section>
<section id="slide-p0401r1-providing-size-feedback-in-the-allocator-interface-chris-kennelly-jonathan-wakely">
<h5 id="p0401r1-providing-size-feedback-in-the-allocator-interface-chris-kennelly-jonathan-wakely"><a href="https://wg21.link/p0401r1">P0401R1</a> Providing size feedback in the Allocator interface (Chris Kennelly, Jonathan Wakely)</h5>
<p>
LWG, C++23, size - small, plenary-approved
</p>
<ul class="org-ul">
<li><a id="org8d6e100"></a><a href="https://wg21.link/p0401">P0401</a> Providing size feedback in the Allocator interface (Chris Kennelly, Jonathan Wakely)<br />
<blockquote>
<p>
Utilize size feedback from Allocator to reduce spurious reallocations
</p>
</blockquote>

<p>
tags: LWG, C++23, small, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p0448r2-a-strstream-replacement-using-spanchart-as-buffer-peter-sommerlad">
<h5 id="p0448r2-a-strstream-replacement-using-spanchart-as-buffer-peter-sommerlad"><a href="https://wg21.link/p0448">P0448</a> A strstream replacement using <code>span&lt;charT&gt;</code> as buffer (Peter Sommerlad)</h5>
<blockquote>
<p>
This paper proposes a class template <code>basic_spanbuf</code> and the corresponding stream
class templates to enable the use of streams on externally provided memory
buffers. No ownership or re-allocation support is given. For those features we
have string-based streams
</p>
</blockquote>
<ul class="org-ul">
<li><a id="org53453ac"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #6ae4b9; font-weight: bold;">char</span>        <span style="color: #00d3d0;">input</span>[] = <span style="color: #79a8ff;">"10 20 30"</span>;
<span style="color: #6ae4b9; font-weight: bold;">ispanstream</span> <span style="color: #00d3d0;">is</span>{<span style="color: #6ae4b9; font-weight: bold;">span</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">char</span>&gt;{input}};
<span style="color: #6ae4b9; font-weight: bold;">int</span>         <span style="color: #00d3d0;">i</span>;
is &gt;&gt; i;
ASSERT_EQUAL(10, i);
is &gt;&gt; i;
ASSERT_EQUAL(20, i);
is &gt;&gt; i;
ASSERT_EQUAL(30, i);
is &gt;&gt; i;
ASSERT(<span style="color: #ff5f59; font-weight: bold;">!</span>is);
</pre>
</div>

<p>
tags: LWG, C++23, size - large, plenary-approved
</p>
</li>
</ul>


</section>
</section>
<section>
<section id="slide-p0627r3-function-to-mark-unreachable-code-melissa-mears">
<h5 id="p0627r3-function-to-mark-unreachable-code-melissa-mears"><a href="https://wg21.link/p0627">P0627</a> Function to mark unreachable code (Melissa Mears)</h5>
<blockquote>
<p>
This proposal introduces a new standard library function, std::unreachable, for
marking locations in code execution as being known by the programmer to be
unreachable.
</p>
</blockquote>

<ul class="org-ul">
<li><a id="orga907468"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++">[[<span style="color: #00bcff;">noreturn</span>]] <span style="color: #6ae4b9; font-weight: bold;">void</span> <span style="color: #feacd0;">kill_self</span>() {
    kill(getpid(), SIGKILL);
    <span style="color: #00bcff;">std</span>::unreachable();
}
</pre>
</div>
<p>
tags: LWG, C++23, IS, B3 - addition, size - small, plenary-approved, expedited-library-evolution-electronic-poll
</p>
</li>
</ul>


</section>
</section>
<section>
<section id="slide-p1072r2-basic_stringresize_default_init-chris-kennelly-mark-zeren">
<h5 id="p1072r2-basic_stringresize_default_init-chris-kennelly-mark-zeren"><a href="https://wg21.link/p1072">P1072</a> basic_string::resize_default_init (Chris Kennelly, Mark Zeren)</h5>
<blockquote>
<p>
Allow access to default initialized elements of basic_string.
</p>
</blockquote>
<ul class="org-ul">
<li><a id="org4dd72ef"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">string</span> <span style="color: #feacd0;">GeneratePattern</span>(<span style="color: #b6a0ff; font-weight: bold;">const</span> <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">string</span>&amp; <span style="color: #00d3d0;">pattern</span>, <span style="color: #6ae4b9; font-weight: bold;">size_t</span> <span style="color: #00d3d0;">count</span>) {
    <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">string</span> <span style="color: #00d3d0;">ret</span>;

    <span style="color: #b6a0ff; font-weight: bold;">const</span> <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">step</span> = pattern.size();
    <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">GOOD: No initialization</span>
    ret.resize_default_init(step * count);
    <span style="color: #b6a0ff; font-weight: bold;">for</span> (<span style="color: #6ae4b9; font-weight: bold;">size_t</span> <span style="color: #00d3d0;">i</span> = 0; i &lt; count; i++) {
        <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">GOOD: No bookkeeping</span>
        memcpy(ret.data() + i * step, pattern.data(), step);
    }

    <span style="color: #b6a0ff; font-weight: bold;">return</span> ret;
}
</pre>
</div>
<p>
tags: LWG, C++23, IS, plenary-approved
</p>
</li>
</ul>



</section>
</section>
<section>
<section id="slide-p1413-a-safer-interface-for-stdaligned_storage-cj-johnson">
<h5 id="p1413-a-safer-interface-for-stdaligned_storage-cj-johnson"><a href="https://wg21.link/p1413">P1413</a> A safer interface for std::aligned_storage (CJ Johnson)</h5>
<blockquote>
<p>
[] the standard library should provided two more symbols in the form of
typedefs that take in a single template type parameter and, on behalf of the
user, deduce the size and alignment of that type, passing in the values to
std::aligned_storage. The symbols should be <code>std::aligned_storage_for</code> and
<code>std::aligned_storage_for_t</code>. Like <code>std::aligned_storage</code> and
<code>std::aligned_storage_t</code>, they should be available in the <code>&lt;type_traits&gt;</code> header
of the standard library.
</p>
</blockquote>

<p>
tags: LWG, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p1425-iterators-pair-constructors-for-stack-and-queue-corentin-jabot">
<h5 id="p1425-iterators-pair-constructors-for-stack-and-queue-corentin-jabot"><a href="https://wg21.link/p1425">P1425</a> Iterators pair constructors for stack and queue (Corentin Jabot)</h5>
<blockquote>
<p>
This paper proposes to add iterators-pair constructors to <code>std::stack</code> and <code>std::queue</code>
</p>
</blockquote>
<ul class="org-ul">
<li><a id="orgee0450d"></a>Example<br />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Before</th>
<th scope="col" class="org-left">After</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>std::vector&lt;int&gt; v(42);</code></td>
<td class="org-left"><code>std::vector&lt;int&gt; v(42);</code></td>
</tr>

<tr>
<td class="org-left"><code>std::stack&lt;int&gt; s({v.begin(), v.end()});</code></td>
<td class="org-left"><code>std::stack s(v.begin(), v.end());</code></td>
</tr>

<tr>
<td class="org-left"><code>std::queue&lt;int&gt; q({v.begin(), v.end()});</code></td>
<td class="org-left"><code>std::queue q(v.begin(), v.end());</code></td>
</tr>
</tbody>
</table>


<p>
tags: LWG, C++23, B2 - improvement, size - small, plenary-approved
</p>
</li>
</ul>


</section>
</section>
<section>
<section id="slide-p1518-stop-overconstraining-allocators-in-container-deduction-guides-arthur-odwyer-mike-spertus">
<h5 id="p1518-stop-overconstraining-allocators-in-container-deduction-guides-arthur-odwyer-mike-spertus"><a href="https://wg21.link/p1518">P1518</a> Stop overconstraining allocators in container deduction guides (Arthur O'Dwyer, Mike Spertus)</h5>
<blockquote>
<p>
Discussion of flatmap’s deduction guides revealed that the deduction guides for sequence containers and container adaptors are needlessly overconstrained, making use cases such as pmr containers unnecessarily difficult.
</p>
</blockquote>

<p>
tags: LWG, C++23, IS, size - small, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p1951-default-arguments-for-pairs-forwarding-constructor-logan-r.-smith">
<h5 id="p1951-default-arguments-for-pairs-forwarding-constructor-logan-r.-smith"><a href="https://wg21.link/p1951">P1951</a> Default Arguments for pair's Forwarding Constructor (Logan R. Smith)</h5>
<blockquote>
<p>
This paper proposes defaulting the template arguments U1 and U2 in pair's forwarding constructor to T1 and T2 respectively, so that braced initializers may be used as constructor arguments to it.
</p>
</blockquote>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">pair</span>&lt;<span style="color: #00bcff;">std</span>::string, <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">vector</span>&lt;<span style="color: #00bcff;">std</span>::string&gt;&gt; <span style="color: #00d3d0;">p</span>(<span style="color: #79a8ff;">"hello"</span>, {});
</pre>
</div>
<p>
tags: LWG, C++23, IS, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2077-heterogeneous-erasure-overloads-for-associative-containers-konstantin-boyarinov-sergey-vi">
<h5 id="p2077-heterogeneous-erasure-overloads-for-associative-containers-konstantin-boyarinov-sergey-vi"><a href="https://wg21.link/p2077">P2077</a> Heterogeneous erasure overloads for associative containers (Konstantin Boyarinov, Sergey Vinogradov; Ruslan Arutyunyan)</h5>
<blockquote>
<p>
The authors propose heterogeneous erasure overloads for ordered and unordered associative containers, which add an ability to erase values or extract nodes without creating a temporary key_type object.
</p>
</blockquote>
<p>
tags: LWG, C++23, IS, B2: Improvement, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2136-invoker-zhihao-yuan">
<h5 id="p2136-invoker-zhihao-yuan"><a href="https://wg21.link/p2136">P2136</a> invoke&lt;R&gt; (Zhihao Yuan)</h5>
<blockquote>
<p>
This paper proposes invoke_r, a variant of std::invoke that allows specifying the return type, realizing the semantics of INVOKE&lt;R&gt; rather than INVOKE.
</p>
</blockquote>
<p>
tags: LWG, C++23, IS, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2166-a-proposal-to-prohibit-stdbasic_string-and-stdbasic_string_view-construction-from-nullp">
<h5 id="p2166-a-proposal-to-prohibit-stdbasic_string-and-stdbasic_string_view-construction-from-nullp"><a href="https://wg21.link/p2166">P2166</a> A Proposal to Prohibit std::basic_string and std::basic_string_view construction from nullptr (Yuriy Chernyshov)</h5>
<blockquote>
<p>
the behavior of std::basic_string::basic_string(const CharT* s) constructor is undefined if [s, s + Traits::length(s)) is not a valid range (for example, if s is a null pointer)
</p>
</blockquote>
<p>
tags: LWG, C++23, IS, size - small, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2251-require-span-basic_string_view-to-be-trivially-copyable-nevin-liber">
<h5 id="p2251-require-span-basic_string_view-to-be-trivially-copyable-nevin-liber"><a href="https://wg21.link/p2251">P2251</a> Require <code>span</code> &amp; <code>basic_string_view</code> to be Trivially Copyable (Nevin Liber)</h5>
<blockquote>
<p>
Given its definition, it is strongly implied that span &amp; basic_string_view are
trivially copyable, but that is not yet a requirement.
</p>
</blockquote>

<p>
tags: LWG, C++23, IS, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2255-a-type-trait-to-detect-reference-binding-to-temporary-tim-song">
<h5 id="p2255-a-type-trait-to-detect-reference-binding-to-temporary-tim-song"><a href="https://wg21.link/p2255">P2255</a> A type trait to detect reference binding to temporary (Tim Song)</h5>
<blockquote>
<p>
This paper proposes adding two new type traits with compiler support to detect when the initialization of a reference would bind it to a lifetime-extended temporary, and changing several standard library components to make such binding ill-formed when it would inevitably produce a dangling reference.
</p>
</blockquote>
<ul class="org-ul">
<li><a id="orgf9ea747"></a>Before<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">tuple</span>&lt;<span style="color: #b6a0ff; font-weight: bold;">const</span> <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">string</span>&amp;&gt;      <span style="color: #00d3d0;">x</span>(<span style="color: #79a8ff;">"hello"</span>);            <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">dangling</span>
<span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">function</span>&lt;<span style="color: #b6a0ff; font-weight: bold;">const</span> <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">string</span>&amp;()&gt; <span style="color: #00d3d0;">f</span> = [] { <span style="color: #b6a0ff; font-weight: bold;">return</span> <span style="color: #79a8ff;">""</span>; }; <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">OK</span>

f(); <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">dangling</span>
</pre>
</div>
</li>
<li><a id="orgaa4cd5f"></a>After<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">tuple</span>&lt;<span style="color: #b6a0ff; font-weight: bold;">const</span> <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">string</span>&amp;&gt;      <span style="color: #00d3d0;">x</span>(<span style="color: #79a8ff;">"hello"</span>);            <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">ill-formed</span>
<span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">function</span>&lt;<span style="color: #b6a0ff; font-weight: bold;">const</span> <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">string</span>&amp;()&gt; <span style="color: #00d3d0;">f</span> = [] { <span style="color: #b6a0ff; font-weight: bold;">return</span> <span style="color: #79a8ff;">""</span>; }; <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">ill-formed</span>
</pre>
</div>
<p>
tags: LWG, C++23, IS, small, plenary-approved, expedited-library-evolution-electronic-poll
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2301-add-a-pmr-alias-for-stdstacktrace-steve-downey">
<h5 id="p2301-add-a-pmr-alias-for-stdstacktrace-steve-downey"><a href="https://wg21.link/p2301">P2301</a> Add a pmr alias for std::stacktrace (Steve Downey)</h5>
<blockquote>
<p>
This paper proposes to add an alias in the pmr namespace defaulting the allocator used by the std::basic_stacktrace template to pmr::allocator. No changes to the api of std::stacktrace are necessary.
</p>
</blockquote>
<ul class="org-ul">
<li><a id="org341ac31"></a>Before<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #6ae4b9; font-weight: bold;">char</span> <span style="color: #00d3d0;">buffer</span>[1024];

<span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">pmr</span>::<span style="color: #6ae4b9; font-weight: bold;">monotonic_buffer_resource</span> <span style="color: #00d3d0;">pool</span>{
    <span style="color: #00bcff;">std</span>::data(buffer), <span style="color: #00bcff;">std</span>::size(buffer)};

<span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">basic_stacktrace</span>&lt;
    <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">pmr</span>::<span style="color: #6ae4b9; font-weight: bold;">polymorphic_allocator</span>&lt;<span style="color: #00bcff;">std</span>::stacktrace_entry&gt;&gt;
    <span style="color: #00d3d0;">trace</span>{&amp;pool};
</pre>
</div>
</li>
<li><a id="org9f9353e"></a>After<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #6ae4b9; font-weight: bold;">char</span> <span style="color: #00d3d0;">buffer</span>[1024];

<span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">pmr</span>::<span style="color: #6ae4b9; font-weight: bold;">monotonic_buffer_resource</span> <span style="color: #00d3d0;">pool</span>{
    <span style="color: #00bcff;">std</span>::data(buffer), <span style="color: #00bcff;">std</span>::size(buffer)};

<span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">pmr</span>::<span style="color: #6ae4b9; font-weight: bold;">stacktrace</span> <span style="color: #00d3d0;">trace</span>{&amp;pool};
</pre>
</div>

<p>
tags: LWG, C++23, tiny, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2340-clarifying-the-status-of-the-c-headers-thomas-köppe">
<h5 id="p2340-clarifying-the-status-of-the-c-headers-thomas-köppe"><a href="https://wg21.link/p2340">P2340</a> Clarifying the status of the ‘C headers' (Thomas Köppe)</h5>
<blockquote>
<p>
We propose to move the specification of “[depr.c.headers] C headers” from Annex D into the main document, and changing those headers’ status from “deprecated” to an explicitly discussed state “for foreign-language interoperability only”.
</p>
</blockquote>
<p>
tags: LWG, C++23, policy, IS, B2 - improvement, size - small, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2393-cleaning-up-integer-class-types-tim-song">
<h5 id="p2393-cleaning-up-integer-class-types-tim-song"><a href="https://wg21.link/p2393">P2393</a> Cleaning up integer-class types (Tim Song)</h5>
<blockquote>
<p>
This paper revamps the specification and use of integer-class types to resolve a number of issues, including [LWG3366], [LWG3376], and [LWG3575].
</p>
</blockquote>
<p>
tags: LWG, C++23, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2401-add-a-conditional-noexcept-specification-to-stdexchange-giuseppe-dangelo">
<h5 id="p2401-add-a-conditional-noexcept-specification-to-stdexchange-giuseppe-dangelo"><a href="https://wg21.link/p2401">P2401</a> Add a conditional noexcept specification to std::exchange (Giuseppe D'Angelo)</h5>
<blockquote>
<p>
We propose to add a noexcept-specification to std::exchange , which is currently lacking one.
</p>
</blockquote>
<p>
tags: LWG, C++23, IS, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2438-stdstringsubstr-federico-kircheis-tomasz-kamiński">
<h5 id="p2438-stdstringsubstr-federico-kircheis-tomasz-kamiński"><a href="https://wg21.link/p2438">P2438</a> <code>std::string::substr() &amp;&amp;</code> (Federico Kircheis, Tomasz Kamiński)</h5>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #feacd0;">foo</span>() -&gt; <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">string</span>;

<span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">b</span> = foo().substr(<span style="color: #ff9f80; font-style: italic;">/* */</span>);
</pre>
</div>

<p>
Before:
</p>
<blockquote>
<p>
foo() returns a temporary std::string. .substr creates a new string and copies the relevant content. At last, the temporary string returned by foo is released.
</p>
</blockquote>
<p>
After:
</p>
<blockquote>
<p>
foo() returns a std::string. .substr implementation can reuse the storage of the string returned by foo and leave it in a valid but unspecified state. At last, the temporary string returned by foo() is released.
</p>
</blockquote>
<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, expedited-library-evolution-electronic-poll
</p>

</section>
</section>
<section>
<section id="slide-p2445-forward_like-gašper-ažman">
<h5 id="p2445-forward_like-gašper-ažman"><a href="https://wg21.link/p2445">P2445</a> forward_like (Gašper Ažman)</h5>
<blockquote>
<p>
Deducing This [P0847R7] is expected to land in C++23.
Its examples use a hypothetical <code>std::forward_like&lt;decltype(self)&gt;(variable)</code> facility because
<code>std::forward&lt;decltype(v)&gt;(v)</code> is insufficient. This paper proposes <code>std::forward_like</code> to cater to
this scenario.
</p>
</blockquote>
<ul class="org-ul">
<li><a id="orgbe6210c"></a>Example<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">callback</span> = [<span style="color: #00d3d0;">m</span> = get_message(), &amp;<span style="color: #00d3d0;">scheduler</span>](<span style="color: #b6a0ff; font-weight: bold;">this</span> <span style="color: #b6a0ff; font-weight: bold;">auto</span>&amp;&amp; self) -&gt; <span style="color: #6ae4b9; font-weight: bold;">bool</span> {
    <span style="color: #b6a0ff; font-weight: bold;">return</span> scheduler.submit(<span style="color: #00bcff;">std</span>::forward_like&lt;<span style="color: #b6a0ff; font-weight: bold;">decltype</span>(self)&gt;(m));
};
callback();            <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">retry(callback)</span>
<span style="color: #00bcff;">std</span>::move(callback)(); <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">try-or-fail(rvalue)</span>
</pre>
</div>

<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, B3 - addition, size - small, plenary-approved
</p>
</li>
</ul>


</section>
</section>
<section>
<section id="slide-p2467-support-exclusive-mode-for-fstreams-jonathan-wakely">
<h5 id="p2467-support-exclusive-mode-for-fstreams-jonathan-wakely"><a href="https://wg21.link/P2467">P2467</a> Support exclusive mode for fstreams (Jonathan Wakely)</h5>
<blockquote>
<p>
Historically, C++ iostreams libraries had a <code>noreplace</code> open mode that corresponded to the <code>O_EXCL</code> flag for POSIX <code>open</code>. That mode was not included in the C++98 standard, presumably for portability reasons, because it wasn't in ISO C90.
</p>

<p>
Since then, ISO C added support for "exclusive" mode to <code>fopen</code>, so now C++'s <code>&lt;fstream&gt;</code> is missing a feature that is present in both ISO C and POSIX. We should fix this for C++23.
</p>
</blockquote>
<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, B3 - addition, plenary-approved, expedited-library-evolution-electronic-poll
</p>
</section>
</section>
<section>
<section id="slide-p2588-relax-stdbarrier-phase-completion-step-guarantees-gonzalo-brito-eric-a-niebler-anthony">
<h5 id="p2588-relax-stdbarrier-phase-completion-step-guarantees-gonzalo-brito-eric-a-niebler-anthony"><a href="https://wg21.link/p2588">P2588</a> Relax std::barrier phase completion step guarantees (Gonzalo Brito Gadeschi, Eric Niebler, Anthony Williams, Thomas Rodgers)</h5>
<blockquote>
<p>
Unintended consequences of <code>std::barrier</code> ’s specification constrain implementations to run the <code>CompletionFunction</code> on the last thread that arrives at the barrier during the phase. This prevents <code>std::barrier</code> from benefiting from hardware acceleration for thread synchronization. Removing these constraints is a <u>breaking change</u>. This paper aims to find a sweet spot for the barrier specification that delivers the functionality that applications need while allowing efficient implementations.
</p>
</blockquote>

<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2590-explicit-lifetime-management-timur-doumler-richard-smith">
<h5 id="p2590-explicit-lifetime-management-timur-doumler-richard-smith"><a href="https://wg21.link/p2590">P2590</a> Explicit lifetime management (Timur Doumler, Richard Smith)</h5>
<blockquote>
<p>
This paper proposes a new standard library facility
<code>std::start_lifetime_as</code>. For objects of sufficiently trivial types, this
facility can be used to efficiently create objects and start their lifetime to
give programs defined behaviour, without running any constructor code. This
proposal completes the functionality proposed in [P0593R6] and adopted for
C++20 by providing the standard library portion of that paper (only the core
language portion of that paper made it into C++20).
</p>
</blockquote>

<p>
tags: CWG, LWG, C++23, tentatively-ready-for-plenary, lwg-fullreview, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2614-deprecate-numeric_limitshas_denorm-matthias-kretz">
<h5 id="p2614-deprecate-numeric_limitshas_denorm-matthias-kretz"><a href="https://wg21.link/p2614">P2614</a> Deprecate numeric_limits::has_denorm (Matthias Kretz)</h5>
<blockquote>
<p>
Since C is intent on obsoleting the <code>*_HAS_SUBNORM</code> macros, we should consider
the analogue change in C++: the deprecation of <code>numeric_limits::has_denorm</code>. In
general, compile-time constants that describe floating-point behavior are
problematic, since behavior might change at runtime. Let’s also deprecate
<code>numeric_limits::has_denorm_loss</code> while we’re at it.
</p>
</blockquote>
<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, B2 - improvement, size - small, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2655-common_reference_t-of-reference_wrapper-should-be-a-reference-type-hui-xie-s.-levent-yilmaz">
<h5 id="p2655-common_reference_t-of-reference_wrapper-should-be-a-reference-type-hui-xie-s.-levent-yilmaz"><a href="https://wg21.link/p2655">P2655</a> common_reference_t of reference_wrapper Should Be a Reference Type (Hui Xie, S. Levent Yilmaz)</h5>
<blockquote>
<p>
This paper proposes a fix that makes the <code>common_reference_t&lt;T&amp;,reference_wrapper&lt;T&gt;&gt;</code> a reference type <code>T&amp;</code>.
</p>
</blockquote>

<ul class="org-ul">
<li><a id="org3334718"></a>Before<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">static_assert</span>(<span style="color: #6ae4b9; font-weight: bold;">same_as</span>&lt;
              <span style="color: #6ae4b9; font-weight: bold;">common_reference_t</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&amp;, <span style="color: #6ae4b9; font-weight: bold;">reference_wrapper</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&gt;&gt;,
              <span style="color: #6ae4b9; font-weight: bold;">int</span>&gt;);

<span style="color: #b6a0ff; font-weight: bold;">static_assert</span>(same_as&lt;
              <span style="color: #6ae4b9; font-weight: bold;">common_reference_t</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&amp;, <span style="color: #6ae4b9; font-weight: bold;">reference_wrapper</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&gt;&amp;&gt;,
              <span style="color: #6ae4b9; font-weight: bold;">int</span>&gt;);

<span style="color: #b6a0ff; font-weight: bold;">static_assert</span>(same_as&lt;
              <span style="color: #6ae4b9; font-weight: bold;">common_reference_t</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&amp;, <span style="color: #b6a0ff; font-weight: bold;">const</span> <span style="color: #6ae4b9; font-weight: bold;">reference_wrapper</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&gt;&amp;&gt;,
              <span style="color: #b6a0ff; font-weight: bold;">const</span> <span style="color: #6ae4b9; font-weight: bold;">int</span>&amp;&gt;);
</pre>
</div>
</li>

<li><a id="org0eddbc5"></a>After<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b6a0ff; font-weight: bold;">static_assert</span>(<span style="color: #6ae4b9; font-weight: bold;">same_as</span>&lt;
              <span style="color: #6ae4b9; font-weight: bold;">common_reference_t</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&amp;, <span style="color: #6ae4b9; font-weight: bold;">reference_wrapper</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&gt;&gt;,
              <span style="color: #6ae4b9; font-weight: bold;">int</span>&amp;&gt;);

<span style="color: #b6a0ff; font-weight: bold;">static_assert</span>(same_as&lt;
              <span style="color: #6ae4b9; font-weight: bold;">common_reference_t</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&amp;, <span style="color: #6ae4b9; font-weight: bold;">reference_wrapper</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&gt;&amp;&gt;,
              <span style="color: #6ae4b9; font-weight: bold;">int</span>&amp;&gt;);

<span style="color: #b6a0ff; font-weight: bold;">static_assert</span>(same_as&lt;
              <span style="color: #6ae4b9; font-weight: bold;">common_reference_t</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&amp;, <span style="color: #b6a0ff; font-weight: bold;">const</span> <span style="color: #6ae4b9; font-weight: bold;">reference_wrapper</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>&gt;&amp;&gt;,
              <span style="color: #6ae4b9; font-weight: bold;">int</span>&amp;&gt;);
</pre>
</div>
<p>
tags: LWG, C++23, IS, B2 - improvement, size - small, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2674-a-trait-for-implicit-lifetime-types-timur-doumler-vittorio-romeo">
<h5 id="p2674-a-trait-for-implicit-lifetime-types-timur-doumler-vittorio-romeo"><a href="https://wg21.link/p2674">P2674</a> A trait for implicit lifetime types (Timur Doumler, Vittorio Romeo)</h5>
<blockquote>
<p>
C++20 introduced the notion of implicit-lifetime types. There are certain
operations that are only valid for such types. We therefore need a way to check
whether a type is implicit-lifetime, and constrain on this property. This paper
proposes a new type trait std::is_implicit_lifetime to achieve this.
</p>
</blockquote>


<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, B3 - addition, size - small, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p1223-find_backward-zach-laine">
<h5 id="p1223-find_backward-zach-laine"><a href="https://wg21.link/p1223">P1223</a> find_backward (Zach Laine)</h5>
<blockquote>
<p>
Consider how finding the last element that is equal to ‘x‘ in a range is typically done (for all the examples below, we assume a valid range of elements [first, last), and an iterator it within that range):
</p>
</blockquote>

<blockquote>
<p>
Consider this instead:
<code>auto it = std::find_last(first, it, x);</code>
// Use it here&#x2026;
That’s better! It’s a lot less verbose.
</p>
</blockquote>
<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved, expedited-library-evolution-electronic-poll
</p>

</section>
</section>
<section>
<section id="slide-p1264-revising-the-wording-of-stream-input-operations-louis-dionne">
<h5 id="p1264-revising-the-wording-of-stream-input-operations-louis-dionne"><a href="https://wg21.link/p1264">P1264</a> Revising the wording of stream input operations (Louis Dionne)</h5>
<blockquote>
<p>
The wording in [istream], [istream.formatted] and [istream.unformatted] is very difficult to
follow when it comes to exceptions. Some requirements are specified more than once in different
locations, which makes it ambiguous how requirements should interact with each other.
</p>
</blockquote>
<p>
tags: LWG, C++23, IS, lwg-pending, B2 - improvement, size - medium, plenary-approved, lwg-wording-only
</p>


</section>
</section>
<section>
<section id="slide-p1679-string-contains-function-wim-leflere">
<h5 id="p1679-string-contains-function-wim-leflere"><a href="https://wg21.link/p1679">P1679</a> String Contains function (Wim Leflere)</h5>
<blockquote>
<p>
This paper proposes to add member function <code>contains</code> to class templates <code>basic_string</code> and <code>basic_string_view</code>. This function checks, whether or not a string contains a given substring.
</p>
</blockquote>

<p>
tags: C++23, IS, size - small, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p1682-stdto_underlying-jeanheyd-meneide">
<h5 id="p1682-stdto_underlying-jeanheyd-meneide"><a href="https://wg21.link/p1682">P1682</a> std::to_underlying (JeanHeyd Meneide)</h5>
<blockquote>
<p>
A proposal to add a short utility function to handle going from an enumeration to its underlying integral value for safety and ease of use.
</p>
</blockquote>
<p>
tags: C++23, IS, size - small, plenary-approved
</p>


</section>
</section>
<section>
<section id="slide-p2212-relax-requirements-for-time_pointclock-alexey-dmitriev-howard-hinnant">
<h5 id="p2212-relax-requirements-for-time_pointclock-alexey-dmitriev-howard-hinnant"><a href="https://wg21.link/p2212">P2212</a> Relax Requirements for time_point::clock (Alexey Dmitriev, Howard Hinnant)</h5>
<blockquote>
<p>
We propose to relax the requirements on the Clock template parameter of std::chrono::time_point.
</p>
</blockquote>

<p>
tags: C++23, IS, plenary-approved
</p>


</section>
</section>
<section>
<section id="slide-p2417-a-more-constexpr-bitset-daniil-goncharov">
<h5 id="p2417-a-more-constexpr-bitset-daniil-goncharov"><a href="https://wg21.link/p2417">P2417</a> A more constexpr bitset (Daniil Goncharov)</h5>
<blockquote>
<p>
constexpr bitset will allow to naturally use them as flags-mask in
constexpr/consteval functions. It's add, without limitations, new high-level
and more user-friendly class for bit mask in embedded developing.
</p>
</blockquote>

<ul class="org-ul">
<li><a id="orgf2c6158"></a>Proposal<br />
<blockquote>
<p>
Mark every member function except iostream operators. Make all of bitset::reference constexpr.
</p>
</blockquote>
<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, B3 - addition, size - medium, plenary-approved, constexpr, expedited-library-evolut&#x2026;
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2505-monadic-functions-for-stdexpected-jeff-garland">
<h5 id="p2505-monadic-functions-for-stdexpected-jeff-garland"><a href="https://wg21.link/p2505">P2505</a> Monadic Functions for std::expected (Jeff Garland)</h5>
<blockquote>
<p>
With the final plenary vote of P0798 Monadic Functions for std::optional complete, we now have an design inconsistency with std::expected. P0323 std::expected has now also been voted into the working draft for C++23. This proposal corrects the inconsistency by adding 4 functions to std::expected and is targeted at C++23. The author believes this should be treated as a consistency/bug fix still in scope for C++23.
</p>
</blockquote>

<ul class="org-ul">
<li><a id="orgf3d546f"></a>Proposal<br />
<p>
The following 3 functions are added to std::optional, but are currently not part of std::expected.
</p>

<dl>
<dt><code>and_then</code></dt><dd>compose a chain of functions returning an expected</dd>
<dt><code>or_else</code></dt><dd>returns if it has a value, otherwise it calls a function with the error type</dd>
<dt><code>transform</code></dt><dd>apply a function to change the value (and possibly the type)</dd>

</dl>

<p>
After feedback, this draft also proposes the addition of two additional functions for expected to facilitate additional cases:
</p>

<dl>
<dt><code>transform_error</code></dt><dd>apply a function to change the value, otherwise call a function with error type</dd>
<dt><code>error_or</code></dt><dd>a value to return when there is not an error</dd>

</dl>
<p>
tags: LWG, C++23, IS, lwg-fullreview, B2 - improvement, size - small, plenary-approved
</p>
</li>
</ul>

</section>
</section>
<section>
<section id="slide-p2517-add-a-conditional-noexcept-specification-to-stdapply-hewill-kang">
<h5 id="p2517-add-a-conditional-noexcept-specification-to-stdapply-hewill-kang"><a href="https://wg21.link/p2517">P2517</a> Add a conditional noexcept specification to std::apply (Hewill Kang)</h5>
<blockquote>
<p>
This paper proposes to add a noexcept-specification to <code>std::apply</code>.
</p>
</blockquote>

<blockquote>
<p>
<code>invoke(f, args...)</code> should be completely equivalent to <code>apply(f,
forward_as_tuple(args...))</code>, adding <code>noexcept</code> to <code>apply</code> can easily achieve
this and make it more consistent with <code>invoke</code>.
</p>
</blockquote>

<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, lwg-fullreview, plenary-approved
</p>

</section>
</section>
<section>
<section id="slide-p2549-stdunexpected-should-have-error-as-member-accessor-yihe-li">
<h5 id="p2549-stdunexpected-should-have-error-as-member-accessor-yihe-li"><a href="https://wg21.link/p2549">P2549</a> std::unexpected should have error() as member accessor (Yihe Li)</h5>

<ul class="org-ul">
<li><a id="org645358b"></a>Before change:<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #6ae4b9; font-weight: bold;">void</span> <span style="color: #feacd0;">fun</span>()
{
    <span style="color: #b6a0ff; font-weight: bold;">using</span> <span style="color: #b6a0ff; font-weight: bold;">namespace</span> <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">literals</span>;
    <span style="color: #b6a0ff; font-weight: bold;">using</span> <span style="color: #6ae4b9; font-weight: bold;">ET</span> = <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">expected</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>, <span style="color: #00bcff;">std</span>::string&gt;;
    <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">unex</span> = <span style="color: #00bcff;">std</span>::unexpected(<span style="color: #79a8ff;">"Oops"</span><span style="color: #00bcff;">s</span>);
    <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">wrapped</span> = unex.value(); <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">okay, get "Oops"</span>
    <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">ex</span> = ET(unex); <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">implicit, can also happen in parameter passing, etc.</span>
    <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">wrapped2</span> = ex.value(); <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">throws!</span>
}
</pre>
</div>
</li>

<li><a id="orgfe5b957"></a>After change:<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #6ae4b9; font-weight: bold;">void</span> <span style="color: #feacd0;">fun</span>()
{
    <span style="color: #b6a0ff; font-weight: bold;">using</span> <span style="color: #b6a0ff; font-weight: bold;">namespace</span> <span style="color: #00bcff;">std</span>::<span style="color: #00bcff;">literals</span>;
    <span style="color: #b6a0ff; font-weight: bold;">using</span> <span style="color: #6ae4b9; font-weight: bold;">ET</span> = <span style="color: #00bcff;">std</span>::<span style="color: #6ae4b9; font-weight: bold;">expected</span>&lt;<span style="color: #6ae4b9; font-weight: bold;">int</span>, <span style="color: #00bcff;">std</span>::string&gt;;
    <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">unex</span> = <span style="color: #00bcff;">std</span>::unexpected(<span style="color: #79a8ff;">"Oops"</span><span style="color: #00bcff;">s</span>);
    <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">wrapped</span> = unex.error(); <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">okay, get "Oops"</span>
    <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">ex</span> = ET(unex); <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">implicit, can also happen in parameter passing, etc.</span>
    <span style="color: #b6a0ff; font-weight: bold;">auto</span> <span style="color: #00d3d0;">wrapped2</span> = ex.error(); <span style="color: #ff9f80; font-style: italic;">// </span><span style="color: #ff9f80; font-style: italic;">okay, get "Oops" too.</span>
}
</pre>
</div>

<p>
tags: LWG, C++23, tentatively-ready-for-plenary, IS, plenary-approved
</p>
</li>
</ul>
</section>
</section>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/markdown/markdown.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/notes/notes.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/search/search.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/zoom/zoom.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,
width: 2400,
height: 1350,

transition: 'fade',
transitionSpeed: 'default',
showNotes: window.location.search.match( /print-pdf/gi ) ? 'separate-page' : false,

// Plugins with reveal.js 4.x
plugins: [ RevealMarkdown, RevealNotes, RevealSearch, RevealZoom ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
